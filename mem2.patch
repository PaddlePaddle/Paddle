diff --git a/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.cc b/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.cc
index 27c7563fee..7a740750cc 100644
--- a/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.cc
+++ b/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.cc
@@ -49,7 +49,7 @@ AutoGrowthBestFitAllocator::AutoGrowthBestFitAllocator(
     : underlying_allocator_(underlying_allocator),
       alignment_(alignment),
       chunk_size_(std::max(AlignedSize(chunk_size, alignment), alignment)),
-      allow_free_idle_chunk_(allow_free_idle_chunk) {}
+      allow_free_idle_chunk_(allow_free_idle_chunk) { reserved_bytes_ = 0;}
 
 phi::Allocation *AutoGrowthBestFitAllocator::AllocateImpl(
     size_t unaligned_size) {
@@ -90,6 +90,7 @@ phi::Allocation *AutoGrowthBestFitAllocator::AllocateImpl(
     try {
       chunks_.emplace_back(static_unique_ptr_cast<Allocation>(
           underlying_allocator_->Allocate(realloc_size)));
+      reserved_bytes_ += realloc_size;
     } catch (BadAlloc &ex) {
       if (FLAGS_free_when_no_cache_hit) throw ex;
       FreeIdleChunks();
@@ -153,6 +154,19 @@ void AutoGrowthBestFitAllocator::FreeImpl(phi::Allocation *allocation) {
                        block_it);
 
   delete allocation;
+  const static size_t limit = ((size_t)1 << 30) * 20; 
+  if (reserved_bytes_ > limit)
+  {
+     auto *ck = block_it->chunk_;
+     auto &blocks = ck->blocks_;
+     if (blocks.size() == 1 && blocks.begin()->is_free_)
+     {
+	auto &block = *blocks.begin();
+        free_blocks_.erase(std::make_pair(block.size_, block.ptr_));
+	reserved_bytes_ -= ck->allocation_->size();
+        chunks_.remove(*ck);
+     }
+  }
 
   if (FLAGS_free_idle_chunk) {
     FreeIdleChunks();
@@ -171,6 +185,7 @@ uint64_t AutoGrowthBestFitAllocator::FreeIdleChunks() {
       VLOG(2) << "Free chunk with size " << block.size_;
       bytes += block.size_;
       free_blocks_.erase(std::make_pair(block.size_, block.ptr_));
+      reserved_bytes_ -= chunk_it->allocation_->size();
       chunk_it = chunks_.erase(chunk_it);
     } else {
       ++chunk_it;
@@ -179,6 +194,16 @@ uint64_t AutoGrowthBestFitAllocator::FreeIdleChunks() {
   return bytes;
 }
 
+uint64_t AutoGrowthBestFitAllocator::GetAllocatedSize()
+{
+  uint64_t bytes = 0;
+  for (auto chunk_it = chunks_.begin(); chunk_it != chunks_.end(); ++chunk_it)
+  {
+    bytes += chunk_it->allocation_->size();
+  }
+  return bytes;
+}
+
 }  // namespace allocation
 }  // namespace memory
 }  // namespace paddle
diff --git a/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.h b/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.h
index dadf751bdf..b24f69873f 100644
--- a/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.h
+++ b/paddle/fluid/memory/allocation/auto_growth_best_fit_allocator.h
@@ -47,6 +47,8 @@ class AutoGrowthBestFitAllocator : public Allocator {
     return FreeIdleChunks();
   }
 
+  uint64_t GetAllocatedSize();
+
  private:
   uint64_t FreeIdleChunks();
 
@@ -68,7 +70,10 @@ class AutoGrowthBestFitAllocator : public Allocator {
   struct Chunk {
     explicit Chunk(DecoratedAllocationPtr allocation)
         : allocation_(std::move(allocation)) {}
-
+    bool operator == (const Chunk &value)
+    {
+      return this == &value;
+    }
     DecoratedAllocationPtr allocation_;
     List<Block> blocks_;
   };
@@ -92,7 +97,7 @@ class AutoGrowthBestFitAllocator : public Allocator {
   size_t alignment_;
   size_t chunk_size_;
   bool allow_free_idle_chunk_;
-
+  size_t reserved_bytes_;
   SpinLock spinlock_;
 };
 

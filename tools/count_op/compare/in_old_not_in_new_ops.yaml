- op: abs_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: add_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: add_position_encoding
  inputs: (Tensor X)
  attrs: (float alpha, float beta, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: affine_channel
  inputs: (Tensor X, Tensor Scale, Tensor Bias)
  attrs: (str data_layout, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: affine_channel_
  inputs: (Tensor X, Tensor Scale, Tensor Bias)
  attrs: (str data_layout, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: all_gather
  inputs: (Tensor x)
  attrs: (int ring_id, int nranks, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: all_reduce
  inputs: (Tensor x)
  attrs: (int ring_id, int reduce_type, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: all_to_all
  inputs: (Tensor x)
  attrs: (int ring_id, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: alloc_float_status
  inputs: ()
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(FloatStatus)

- op: alltoall
  inputs: (Tensor X)
  attrs: (int ring_id, bool use_calc_stream, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: anchor_generator
  inputs: (Tensor Input)
  attrs: (float[] anchor_sizes, float[] aspect_ratios, float[] variances, float[]
    stride, float offset, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Anchors), Tensor(Variances)

- op: array_to_lod_tensor
  inputs: (Tensor X, Tensor RankTable)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: assert
  inputs: (Tensor cond, Tensor[] data)
  attrs: (int64_t summarize, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: assign_pos
  inputs: (Tensor X, Tensor cum_count, Tensor eff_num_len)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: attention_lstm
  inputs: (Tensor X, Tensor C0, Tensor H0, Tensor AttentionWeight, Tensor AttentionBias,
    Tensor AttentionScalar, Tensor AttentionScalarBias, Tensor LSTMWeight, Tensor
    LSTMBias)
  attrs: (str gate_activation, str cell_activation, str candidate_activation, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Hidden), Tensor(Cell), Tensor(AttentionedX), Tensor(AttentionFCOut),
    Tensor(LSTMX), Tensor(LSTMOUT)
  optionals: H0,AttentionBias,AttentionScalar,AttentionScalarBias

- op: average_accumulates
  inputs: (Tensor param, Tensor in_sum_1, Tensor in_sum_2, Tensor in_sum_3, Tensor
    in_num_accumulates, Tensor in_old_num_accumulates, Tensor in_num_updates)
  attrs: (float average_window, int64_t max_average_window, int64_t min_average_window,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(out_sum_1), Tensor(out_sum_2), Tensor(out_sum_3), Tensor(out_num_accumulates),
    Tensor(out_old_num_accumulates), Tensor(out_num_updates)

- op: barrier
  inputs: (Tensor X)
  attrs: (int ring_id, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: batch_fc
  inputs: (Tensor Input, Tensor W, Tensor Bias)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: beam_search
  inputs: (Tensor pre_ids, Tensor pre_scores, Tensor ids, Tensor scores)
  attrs: (int level, int beam_size, int end_id, bool is_accumulated, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(selected_ids), Tensor(selected_scores), Tensor(parent_idx)
  optionals: ids,parent_idx

- op: beam_search_decode
  inputs: (Tensor|TensorArray? Ids, Tensor|TensorArray? Scores)
  attrs: (int beam_size, int end_id, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(SentenceIds), Tensor(SentenceScores)

- op: bernoulli_p
  inputs: ()
  attrs: (int64_t[] shape, int dtype, float p, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: bilateral_slice
  inputs: (Tensor X, Tensor Grid, Tensor Guide)
  attrs: (bool has_offset, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: bipartite_match
  inputs: (Tensor DistMat)
  attrs: (str match_type, float dist_threshold, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(ColToRowMatchIndices), Tensor(ColToRowMatchDist)

- op: block_multihead_attention
  inputs: (Tensor qkv, Tensor key_cache, Tensor value_cache, Tensor seq_lens_encoder,
    Tensor seq_lens_decoder, Tensor seq_lens_this_time, Tensor padding_offsets, Tensor
    cum_offsets, Tensor cu_seqlens_q, Tensor cu_seqlens_k, Tensor block_tables, Tensor
    pre_key_cache, Tensor pre_value_cache, Tensor rope_emb, Tensor mask, Tensor tgt_mask,
    Tensor cache_k_quant_scales, Tensor cache_v_quant_scales, Tensor cache_k_dequant_scales,
    Tensor cache_v_dequant_scales, Tensor qkv_out_scale, Tensor qkv_bias, Tensor out_shift,
    Tensor out_smooth)
  attrs: (int max_seq_len, int block_size, bool use_neox_style, bool dynamic_cachekv_quant,
    int quant_round_type, float quant_max_bound, float quant_min_bound, float out_scale,
    str compute_dtype, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(fmha_out), Tensor(qkv_out), Tensor(key_cache_out), Tensor(value_cache_out)
  optionals: pre_key_cache,pre_value_cache,rope_emb,mask,tgt_mask,cache_k_quant_scales,cache_v_quant_scales,cache_k_dequant_scales,cache_v_dequant_scales,qkv_out_scale,qkv_bias,out_shift,out_smooth

- op: box_clip
  inputs: (Tensor Input, Tensor ImInfo)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Output)

- op: box_decoder_and_assign
  inputs: (Tensor PriorBox, Tensor PriorBoxVar, Tensor TargetBox, Tensor BoxScore)
  attrs: (float box_clip, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(DecodeBox), Tensor(OutputAssignBox)
  optionals: PriorBoxVar

- op: bpr_loss
  inputs: (Tensor X, Tensor Label)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: brelu_
  inputs: (Tensor x)
  attrs: (float t_min, float t_max, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: broadcast
  inputs: (Tensor x)
  attrs: (int ring_id, int root, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: broadcast_p
  inputs: (Tensor X)
  attrs: (int64_t[] shape, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: c_comm_init
  inputs: (Tensor X)
  attrs: (int nranks, int rank, int device_id, int ring_id, str endpoints, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: c_comm_init_all
  inputs: ()
  attrs: (int[] devices, int ring_id, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: c_comm_init_multitrainer
  inputs: (Tensor X)
  attrs: (int ntrainers, int trainer_id, int[] devices, int ring_id, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: c_gen_bkcl_id
  inputs: ()
  attrs: (str endpoint, str[] other_endpoints, int rank, int ring_id)
  outputs: Tensor(out)

- op: c_gen_nccl_id
  inputs: ()
  attrs: (str endpoint, str[] other_endpoints, int rank, int ring_id, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: c_gen_xccl_id
  inputs: ()
  attrs: (str endpoint, str[] other_endpoints, int rank, int ring_id, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: c_reduce_max
  inputs: (Tensor X)
  attrs: (int ring_id, int root_id, bool use_calc_stream, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: c_reduce_prod
  inputs: (Tensor X)
  attrs: (int ring_id, int root_id, bool use_calc_stream, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: c_scatter
  inputs: (Tensor X)
  attrs: (int ring_id, int root, int nranks, bool use_calc_stream, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: c_softmax_with_cross_entropy_
  inputs: (Tensor logits, Tensor label)
  attrs: (int64_t ignore_index, int ring_id, int rank, int nranks, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(softmax), Tensor(loss)

- op: c_split
  inputs: (Tensor X)
  attrs: (int rank, int nranks, int ring_id, bool use_calc_stream, bool use_model_parallel,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out)

- op: c_wait_comm
  inputs: (Tensor[] X)
  attrs: (int ring_id, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: c_wait_compute
  inputs: (Tensor[] X)
  attrs: (int ring_id, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: cast_p
  inputs: (Tensor X)
  attrs: (int dtype, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: check_memory_continue
  inputs: (Tensor[] X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor(XOut)

- op: chunk_eval
  inputs: (Tensor Inference, Tensor Label, Tensor SeqLength)
  attrs: (int num_chunk_types, str chunk_scheme, int[] excluded_chunk_types, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Precision), Tensor(Recall), Tensor(F1-Score), Tensor(NumInferChunks),
    Tensor(NumLabelChunks), Tensor(NumCorrectChunks)
  optionals: SeqLength

- op: cinn_instruction_run
  inputs: (Tensor[] kX)
  attrs: (int64_t kCachedIndex, int64_t kInstructionIndex)
  outputs: Tensor[](kOutputs)

- op: cinn_launch
  inputs: (Tensor[] kX, Tensor[] kNoNeedBufferX)
  attrs: (int64_t kCompilationKey)
  outputs: Tensor[](kOutputs)
  optionals: kNoNeedBufferX

- op: clear_float_status
  inputs: (Tensor FloatStatus)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(FloatStatusOut)

- op: collect_fpn_proposals
  inputs: (Tensor[] MultiLevelRois, Tensor[] MultiLevelScores, Tensor[] MultiLevelRoIsNum)
  attrs: (int post_nms_topN, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(FpnRois), Tensor(RoisNum)
  optionals: MultiLevelRoIsNum,RoisNum

- op: concat_p
  inputs: (Tensor[] XS)
  attrs: (int64_t axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: conditional_block
  inputs: (Tensor[] Cond, Tensor[] Input)
  attrs: (BLOCK sub_block, bool is_scalar_condition, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor(Scope)

- op: conditional_block_infer
  inputs: (Tensor[] Cond, Tensor[] Input)
  attrs: (BLOCK sub_block, bool is_scalar_condition, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor(Scope)

- op: conv2d_inception_fusion
  inputs: (Tensor Input, Tensor[] Filter, Tensor[] Bias)
  attrs: (str pooling_type, bool exclusive, str activation, int workspace_size_MB,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Output), Tensor[](TempOutput)

- op: copy_cross_scope
  inputs: (Tensor X, Tensor Id)
  attrs: (bool to_main_scope, int num_micro_batches, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: correlation
  inputs: (Tensor Input1, Tensor Input2)
  attrs: (int pad_size, int kernel_size, int max_displacement, int stride1, int stride2,
    int corr_type_multiply, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Output)

- op: cos_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: create_custom_reader
  inputs: ()
  attrs: (BLOCK sub_block, str[] source_var_names, str[] sink_var_names)
  outputs: ()

- op: crf_decoding
  inputs: (Tensor Emission, Tensor Transition, Tensor Label, Tensor Length)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(ViterbiPath)
  optionals: Label,Length

- op: cross_entropy
  inputs: (Tensor X, Tensor Label)
  attrs: (bool soft_label, int ignore_index, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: cross_entropy2
  inputs: (Tensor X, Tensor Label)
  attrs: (int ignore_index, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y), Tensor(XShape), Tensor(MatchX)

- op: ctc_align
  inputs: (Tensor Input, Tensor InputLength)
  attrs: (int blank, bool merge_repeated, int padding_value, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Output), Tensor(OutputLength)
  optionals: InputLength,OutputLength

- op: cudnn_lstm
  inputs: (Tensor Input, Tensor InitH, Tensor InitC, Tensor W, Tensor[] WeightList,
    Tensor SequenceLength)
  attrs: (float dropout_prob, bool is_bidirec, int input_size, int hidden_size, int
    num_layers, bool is_test, int seed, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Reserve), Tensor(StateOut), Tensor(Out), Tensor(LastH), Tensor(LastC)
  optionals: W,WeightList,SequenceLength

- op: cvm
  inputs: (Tensor X, Tensor CVM)
  attrs: (bool use_cvm, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: data_norm
  inputs: (Tensor scale_w, Tensor bias, Tensor X, Tensor BatchSize, Tensor BatchSum,
    Tensor BatchSquareSum)
  attrs: (float epsilon, int slot_dim, float summary_decay_rate, bool enable_scale_and_shift,
    str data_layout, bool sync_stats, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y), Tensor(Means), Tensor(Scales)
  optionals: scale_w,bias

- op: deformable_psroi_pooling
  inputs: (Tensor Input, Tensor ROIs, Tensor Trans)
  attrs: (bool no_trans, float spatial_scale, int output_dim, int[] group_size, int
    pooled_height, int pooled_width, int[] part_size, int sample_per_part, float trans_std,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(TopCount), Tensor(Output)

- op: delete_var
  inputs: (Tensor[] X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: ''

- op: density_prior_box
  inputs: (Tensor Input, Tensor Image)
  attrs: (float[] variances, bool clip, bool flatten_to_2d, float step_w, float step_h,
    float offset, float[] fixed_sizes, float[] fixed_ratios, int[] densities, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Boxes), Tensor(Variances)

- op: depend
  inputs: (Tensor X, Tensor[] Dep)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: dequantize
  inputs: (Tensor input)
  attrs: (float scale, float shift, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(output)

- op: dequantize_abs_max
  inputs: (Tensor X, Tensor Scale)
  attrs: (float max_range, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: dequantize_linear
  inputs: (Tensor X, Tensor Scale, Tensor ZeroPoint, Tensor InAccum, Tensor InState)
  attrs: (int quant_axis, int bit_length, int round_type, bool is_test, bool only_observer,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Y), Tensor(OutState), Tensor(OutAccum), Tensor(OutScale)
  optionals: InAccum,InState,OutState,OutAccum,OutScale

- op: dequantize_log
  inputs: (Tensor X, Tensor Dict)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: dequeue
  inputs: ()
  attrs: (str queue_name, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: detection_map
  inputs: (Tensor DetectRes, Tensor Label, Tensor HasState, Tensor PosCount, Tensor
    TruePos, Tensor FalsePos)
  attrs: (int class_num, int background_label, float overlap_threshold, bool evaluate_difficult,
    str ap_type, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(AccumPosCount), Tensor(AccumTruePos), Tensor(AccumFalsePos), Tensor(MAP)
  optionals: HasState,PosCount,TruePos,FalsePos

- op: dgc
  inputs: (Tensor U, Tensor V, Tensor Grad, Tensor Param, Tensor current_step, Tensor
    nranks)
  attrs: (float m, bool use_nesterov, float[] sparsity, float rampup_begin_step, float
    rampup_step, float regular_coeff, int regular_type, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(U_out), Tensor(V_out), Tensor(EncodeGrad), Tensor(Grad_out), Tensor(k),
    Tensor(GatherBuff)

- op: dgc_clip_by_norm
  inputs: (Tensor current_step, Tensor X)
  attrs: (float rampup_begin_step, float max_norm, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: dgc_momentum
  inputs: (Tensor Param, Tensor Grad, Tensor Velocity, Tensor LearningRate, Tensor
    MasterParam, Tensor current_step, Tensor nranks)
  attrs: (float mu, bool use_nesterov, str regularization_method, float regularization_coeff,
    bool multi_precision, float rescale_grad, float rampup_begin_step, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(ParamOut), Tensor(VelocityOut), Tensor(MasterParamOut), Tensor(Grad_out)
  optionals: MasterParam,MasterParamOut

- op: dist_concat
  inputs: (Tensor x)
  attrs: (int ring_id, int nranks, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: distributed_fused_lamb
  inputs: (Tensor[] Param, Tensor[] Grad, Tensor FP32FusedParam, Tensor FP32FusedGrad,
    Tensor FP16FusedParam, Tensor FP16FusedGrad, Tensor Moment1, Tensor Moment2, Tensor
    Beta1Pow, Tensor Beta2Pow, Tensor FusedParamOffsets, Tensor FP32ShardFusedParamOffsets,
    Tensor FP16ShardFusedParamOffsets, Tensor ParamInfo, Tensor ParamOrder, Tensor
    LearningRate, Tensor GlobalScale)
  attrs: (int acc_steps, float beta1, float beta2, float epsilon, float max_global_grad_norm,
    float weight_decay, bool clip_after_allreduce, bool use_master_param_norm, bool
    use_master_acc_grad, bool is_grad_scaled_by_nranks, int64_t nranks, int[] ring_ids,
    bool use_hierarchical_allreduce, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(FP32FusedParamOut), Tensor(FP16FusedParamOut), Tensor(FP32AccFusedGrad),
    Tensor(FP16AccFusedGrad), Tensor(Moment1Out), Tensor(Moment2Out), Tensor(Beta1PowOut),
    Tensor(Beta2PowOut), Tensor[](ParamOut), Tensor(FoundInf), Tensor(AccStep), Tensor(StopUpdate),
    Tensor(Step)
  optionals: FP32FusedParam,FP32FusedGrad,FP16FusedParam,FP16FusedGrad,FP32FusedParamOut,FP16FusedParamOut,FP32AccFusedGrad,FP16AccFusedGrad,AccStep,StopUpdate

- op: distributed_fused_lamb_init
  inputs: (Tensor[] Param, Tensor[] Grad)
  attrs: (float beta1, float beta2, int[] apply_weight_decay, int alignment, int rank,
    int nranks, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(FP32FusedParam), Tensor(FP32FusedGrad), Tensor(FP16FusedParam),
    Tensor(FP16FusedGrad), Tensor(Moment1), Tensor(Moment2), Tensor(Beta1Pow), Tensor(Beta2Pow),
    Tensor(FusedParamOffsets), Tensor(FP32ShardFusedParamOffsets), Tensor(FP16ShardFusedParamOffsets),
    Tensor(ParamInfo), Tensor(ParamOrder), Tensor[](ParamOut), Tensor[](MasterParamOut),
    Tensor[](GradOut), Tensor(GlobalScale), Tensor(Step)
  optionals: FP32FusedParam,FP32FusedGrad,FP16FusedParam,FP16FusedGrad

- op: distributed_push_sparse
  inputs: (Tensor[] Ids, Tensor[] Shows, Tensor[] Clicks)
  attrs: (int table_id, int size, bool is_distributed, str push_sparse_version, int64_t
    padding_idx, int dtype, bool is_test, bool use_cvm_op, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Outputs)

- op: div_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: dlnne_engine
  inputs: (Tensor[] Xs)
  attrs: (str subgraph, str engine_key, int max_batch_size, bool use_static_batch,
    str weight_share_mode, bool use_calib_mode, bool enable_int8, bool calibration_mode,
    str calibration_data_path, str subgraph_root_path, BLOCK sub_block)
  outputs: Tensor[](Ys)

- op: dropout_nd
  inputs: (Tensor X, Tensor Seed)
  attrs: (float dropout_prob, bool is_test, str dropout_implementation, int[] axis,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out), Tensor(Mask)
  optionals: Seed

- op: dummy
  inputs: (Tensor X)
  attrs: ()
  outputs: Tensor(Out)

- op: elementwise_add_
  inputs: (Tensor x, Tensor y)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: elementwise_mod_
  inputs: (Tensor x, Tensor y)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: elementwise_sub_
  inputs: (Tensor x, Tensor y)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: enqueue
  inputs: (Tensor X)
  attrs: (str queue_name, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: eq_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: erf_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: exp_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: fake_channel_wise_dequantize_max_abs
  inputs: (Tensor X, Tensor[] Scales)
  attrs: (int[] quant_bits, int quant_axis, int x_num_col_dims, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fake_channel_wise_quantize_abs_max
  inputs: (Tensor X)
  attrs: (int quant_axis, int bit_length, bool is_test, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale)

- op: fake_channel_wise_quantize_dequantize_abs_max
  inputs: (Tensor X)
  attrs: (int quant_axis, int bit_length, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale)

- op: fake_dequantize_max_abs
  inputs: (Tensor X, Tensor Scale)
  attrs: (float max_range, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fake_init
  inputs: ()
  attrs: (int64_t[] shape, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fake_quantize_abs_max
  inputs: (Tensor X)
  attrs: (int bit_length, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale)

- op: fake_quantize_dequantize_abs_max
  inputs: (Tensor X)
  attrs: (int bit_length, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale)

- op: fake_quantize_dequantize_moving_average_abs_max
  inputs: (Tensor X, Tensor InScale, Tensor InAccum, Tensor InState)
  attrs: (float moving_rate, int bit_length, bool is_test, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale), Tensor(OutState), Tensor(OutAccum)
  optionals: InAccum,InState,OutState,OutAccum

- op: fake_quantize_moving_average_abs_max
  inputs: (Tensor X, Tensor InScale, Tensor InAccum, Tensor InState)
  attrs: (float moving_rate, int bit_length, bool is_test, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale), Tensor(OutState), Tensor(OutAccum)
  optionals: InAccum,InState,OutState,OutAccum

- op: fake_quantize_range_abs_max
  inputs: (Tensor X, Tensor InScale, Tensor Iter)
  attrs: (int window_size, int bit_length, bool is_test, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale), Tensor(OutScales)
  optionals: Iter,OutScales

- op: fake_sum
  inputs: (Tensor X)
  attrs: (int op_role)
  outputs: Tensor(Out)

- op: fake_test_op
  inputs: (Tensor[] X, Tensor[] Y)
  attrs: ()
  outputs: Tensor[](Out)

- op: faster_tokenizer
  inputs: (Tensor Vocab, Tensor Text, Tensor TextPair)
  attrs: (bool do_lower_case, bool is_split_into_words, int max_seq_len, bool pad_to_max_seq_len,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(InputIds), Tensor(SegmentIds)
  optionals: TextPair

- op: fetch_barrier
  inputs: (Tensor[] X)
  attrs: (int trainer_id, str[] endpoints, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)
  optionals: X

- op: fill_any_
  inputs: (Tensor x)
  attrs: (float value, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: fill_constant_p
  inputs: ()
  attrs: (float value, int64_t[] shape, int dtype, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: fill_zeros_like
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fill_zeros_like2
  inputs: (Tensor X)
  attrs: (int dtype, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: flatten2
  inputs: (Tensor X)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(XShape)

- op: flatten2_
  inputs: (Tensor X)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(XShape)

- op: flatten_contiguous_range_
  inputs: (Tensor x)
  attrs: (int start_axis, int stop_axis, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(xshape)

- op: fsp
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_adam
  inputs: (Tensor[] Params, Tensor[] Grads, Tensor LearningRate, Tensor[] Moments1,
    Tensor[] Moments2, Tensor[] Beta1Pows, Tensor[] Beta2Pows, Tensor[] MasterParams,
    Tensor SkipUpdate)
  attrs: (float beta1, float beta2, float epsilon, int chunk_size, float weight_decay,
    bool use_adamw, bool multi_precision, bool use_global_beta_pow, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](ParamsOut), Tensor[](Moments1Out), Tensor[](Moments2Out), Tensor[](Beta1PowsOut),
    Tensor[](Beta2PowsOut), Tensor[](MasterParamsOut)
  optionals: MasterParams,SkipUpdate,MasterParamsOut

- op: fused_conv2d
  inputs: (Tensor input, Tensor filter, Tensor bias, Tensor residual_param)
  attrs: (int[] strides, int[] paddings, str padding_algorithm, int[] dilations, int
    groups, str data_format, str fuse_activation, bool fuse_residual_connection, bool
    force_fp32_output, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(output)
  optionals: bias,residual_param

- op: fused_conv3d
  inputs: (Tensor input, Tensor filter, Tensor bias, Tensor residual_param)
  attrs: (int[] strides, int[] paddings, str padding_algorithm, int[] dilations, int
    groups, str data_format, str fuse_activation, bool fuse_residual_connection, bool
    force_fp32_output, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(output)
  optionals: bias,residual_param

- op: fused_elementwise_add
  inputs: (Tensor X, Tensor Y)
  attrs: (int axis, str fuse_activation, float fuse_alpha, float fuse_beta, float
    fused_output_scale, int[] fused_unsqueeze2_axes, float scale_x, float scale_y,
    float scale_out, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_elementwise_div
  inputs: (Tensor X, Tensor Y)
  attrs: (int axis, str fuse_activation, float fuse_alpha, float fuse_beta, float
    fused_output_scale, int[] fused_unsqueeze2_axes, float scale_x, float scale_y,
    float scale_out, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_elementwise_mul
  inputs: (Tensor X, Tensor Y)
  attrs: (int axis, str fuse_activation, float fuse_alpha, float fuse_beta, float
    fused_output_scale, int[] fused_unsqueeze2_axes, float scale_x, float scale_y,
    float scale_out, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_elementwise_sub
  inputs: (Tensor X, Tensor Y)
  attrs: (int axis, str fuse_activation, float fuse_alpha, float fuse_beta, float
    fused_output_scale, int[] fused_unsqueeze2_axes, float scale_x, float scale_y,
    float scale_out, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_elemwise_activation
  inputs: (Tensor X, Tensor Y)
  attrs: (int axis, float scale, bool save_intermediate_out, str[] functor_list, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out), Tensor(IntermediateOut)

- op: fused_embedding_fc_lstm
  inputs: (Tensor Ids, Tensor Embeddings, Tensor WeightH, Tensor Bias, Tensor H0,
    Tensor C0)
  attrs: (bool use_peepholes, bool is_reverse, bool use_seq, str gate_activation,
    str cell_activation, str candidate_activation, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Hidden), Tensor(Cell), Tensor(XX), Tensor(BatchedInput), Tensor(BatchedHidden),
    Tensor(BatchedCell), Tensor(ReorderedH0), Tensor(ReorderedC0)
  optionals: H0,C0

- op: fused_embedding_seq_pool
  inputs: (Tensor W, Tensor Ids)
  attrs: (str combiner, int64_t padding_idx, bool grad_inplace, bool is_sparse, bool
    ALL_KERNELS_MUST_COMPUTE_RUNTIME_SHAPE, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_gate_attention
  inputs: (Tensor Query, Tensor Key, Tensor QueryWeight, Tensor KeyWeight, Tensor
    ValueWeight, Tensor QKVWeight, Tensor NonbatchedBias, Tensor SrcMask, Tensor GateWeight,
    Tensor GateBias, Tensor OutLinearWeight, Tensor OutLinearBias)
  attrs: (bool has_gating, bool merge_qkv, bool use_flash_attn, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(QueryTransposeOut), Tensor(KeyTransposeOut), Tensor(ValueTransposeOut),
    Tensor(QKVTransposeOut), Tensor(SoftmaxOut), Tensor(SoftmaxLse), Tensor(FMHAOut),
    Tensor(GateOut), Tensor(Out)
  optionals: Key,QueryWeight,KeyWeight,ValueWeight,QKVWeight,NonbatchedBias,GateWeight,GateBias,QueryTransposeOut,KeyTransposeOut,ValueTransposeOut,QKVTransposeOut,SoftmaxLse,GateOut

- op: fused_matmul
  inputs: (Tensor X, Tensor Y, Tensor ResidualData)
  attrs: (bool trans_x, bool trans_y, float matmul_alpha, str fuse_activation, float
    fuse_alpha, float fuse_beta, float fused_output_scale, int[] fused_reshape_X,
    int[] fused_transpose_X, int[] fused_reshape_Y, int[] fused_transpose_Y, int[]
    fused_reshape_Out, int[] fused_transpose_Out, str mkldnn_data_type, float Scale_x,
    float Scale_y, float Scale_in_eltwise, float Scale_out, bool force_fp32_output,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out)
  optionals: ResidualData

- op: fused_multi_transformer
  inputs: (Tensor X, Tensor[] LnScale, Tensor[] LnBias, Tensor[] QKVW, Tensor[] QKVBias,
    Tensor[] CacheKV, Tensor[] PreCaches, Tensor RotaryPosEmb, Tensor TimeStep, Tensor
    SeqLengths, Tensor SrcMask, Tensor[] OutLinearW, Tensor[] OutLinearBias, Tensor[]
    FFNLnScale, Tensor[] FFNLnBias, Tensor[] FFN1Weight, Tensor[] FFN1Bias, Tensor[]
    FFN2Weight, Tensor[] FFN2Bias)
  attrs: (bool pre_layer_norm, int rotary_emb_dims, float epsilon, float dropout_rate,
    bool is_test, str dropout_implementation, str act_method, bool trans_qkvw, int
    ring_id, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor[](CacheKVOut), Tensor(Out)
  optionals: QKVBias,CacheKV,PreCaches,RotaryPosEmb,TimeStep,SeqLengths,SrcMask,OutLinearBias,FFN1Bias,FFN2Bias,CacheKVOut

- op: fused_multi_transformer_int8
  inputs: (Tensor X, Tensor[] LnScale, Tensor[] LnBias, Tensor[] QKVW, Tensor[] QKVBias,
    Tensor[] CacheKV, Tensor TimeStep, Tensor SrcMask, Tensor[] OutLinearW, Tensor[]
    OutLinearBias, Tensor[] FFNLnScale, Tensor[] FFNLnBias, Tensor[] FFN1Weight, Tensor[]
    FFN1Bias, Tensor[] FFN2Weight, Tensor[] FFN2Bias, Tensor[] QKVOutScale, Tensor[]
    OutLinearOutScale, Tensor[] FFN1OutScale, Tensor[] FFN2OutScale)
  attrs: (bool pre_layer_norm, float epsilon, float dropout_rate, bool is_test, str
    dropout_implementation, str act_method, bool trans_qkvw, int ring_id, int num_head,
    int dim_head, int dim_ffn, float[] qkv_in_scale, float[] out_linear_in_scale,
    float[] ffn1_in_scale, float[] ffn2_in_scale, int quant_round_type, float quant_max_bound,
    float quant_min_bound, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](CacheKVOut), Tensor(Out)
  optionals: QKVBias,CacheKV,TimeStep,SrcMask,OutLinearBias,FFN1Bias,FFN2Bias,QKVOutScale,OutLinearOutScale,FFN1OutScale,FFN2OutScale,CacheKVOut

- op: fused_seqpool_cvm
  inputs: (Tensor[] X, Tensor CVM)
  attrs: (str pooltype, float pad_value, bool use_cvm, int cvm_offset, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: fused_softplus
  inputs: (Tensor X)
  attrs: (float beta, float threshold, str fuse_activation, float fuse_alpha, float
    fuse_beta, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fused_token_prune
  inputs: (Tensor Attn, Tensor X, Tensor Mask, Tensor NewMask)
  attrs: (bool keep_first_token, bool keep_order, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(SlimmedX), Tensor(CLSInds)

- op: fused_transpose
  inputs: (Tensor X)
  attrs: (int[] axis, int[] fused_squeeze2_axes, int[] fused_unsqueeze2_axes, int[]
    fused_reshape2_shape, float scale, float shift, str output_data_type, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(XShape)

- op: fusion_group
  inputs: (Tensor[] Inputs)
  attrs: (int[] outs_dtype, int[] inputs_dtype, int type, str func_name, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Outs)

- op: fusion_lstm
  inputs: (Tensor X, Tensor WeightX, Tensor WeightH, Tensor Bias, Tensor H0, Tensor
    C0)
  attrs: (bool use_peepholes, bool is_reverse, bool use_seq, str gate_activation,
    str cell_activation, str candidate_activation, float Scale_data, float Shift_data,
    float[] Scale_weights, bool force_fp32_output, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Hidden), Tensor(Cell), Tensor(XX), Tensor(BatchedInput), Tensor(BatchedHidden),
    Tensor(BatchedCell), Tensor(ReorderedH0), Tensor(ReorderedC0), Tensor(CheckedCell)
  optionals: H0,C0

- op: fusion_seqpool_concat
  inputs: (Tensor[] X)
  attrs: (str pooltype, int axis, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: fusion_seqpool_cvm_concat
  inputs: (Tensor[] X, Tensor CVM)
  attrs: (str pooltype, bool use_cvm, int axis, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: gather_p
  inputs: (Tensor X, Tensor IndexTensor)
  attrs: (int64_t axis, int64_t[] index, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)
  optionals: IndexTensor

- op: ge_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: gen_bkcl_id
  inputs: ()
  attrs: (str[] trainers, int trainer_id, int bkcl_comm_num, bool use_hierarchical_allreduce,
    int hierarchical_allreduce_inter_nranks)
  outputs: Tensor(Out)

- op: gen_nccl_id
  inputs: ()
  attrs: (str[] trainers, int trainer_id, int nccl_comm_num, bool use_hierarchical_allreduce,
    int hierarchical_allreduce_inter_nranks, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(NCCLID)

- op: generate_mask_labels
  inputs: (Tensor ImInfo, Tensor GtClasses, Tensor IsCrowd, Tensor GtSegms, Tensor
    Rois, Tensor LabelsInt32)
  attrs: (int num_classes, int resolution, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(MaskRois), Tensor(RoiHasMaskInt32), Tensor(MaskInt32)

- op: generate_proposal_labels
  inputs: (Tensor RpnRois, Tensor GtClasses, Tensor IsCrowd, Tensor GtBoxes, Tensor
    ImInfo, Tensor MaxOverlap)
  attrs: (int batch_size_per_im, float fg_fraction, float fg_thresh, float bg_thresh_hi,
    float bg_thresh_lo, float[] bbox_reg_weights, int class_nums, bool use_random,
    bool is_cascade_rcnn, bool is_cls_agnostic, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Rois), Tensor(LabelsInt32), Tensor(BboxTargets), Tensor(BboxInsideWeights),
    Tensor(BboxOutsideWeights), Tensor(MaxOverlapWithGT)
  optionals: MaxOverlap

- op: get_float_status
  inputs: (Tensor FloatStatus)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(FloatStatusOut)

- op: get_places
  inputs: ()
  attrs: (int device_count, str device_type, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: global_gather
  inputs: (Tensor X, Tensor local_count, Tensor global_count)
  attrs: (int ring_id, bool use_calc_stream, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: global_scatter
  inputs: (Tensor X, Tensor local_count, Tensor global_count)
  attrs: (int ring_id, bool use_calc_stream, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: grad_add
  inputs: (Tensor x, Tensor y)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: gru
  inputs: (Tensor Input, Tensor H0, Tensor Weight, Tensor Bias)
  attrs: (str activation, str gate_activation, bool is_reverse, bool origin_mode,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(BatchGate), Tensor(BatchResetHiddenPrev), Tensor(BatchHidden), Tensor(Hidden)
  optionals: H0,Bias

- op: gru_unit
  inputs: (Tensor Input, Tensor HiddenPrev, Tensor Weight, Tensor Bias)
  attrs: (int activation, int gate_activation, bool origin_mode, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Gate), Tensor(ResetHiddenPrev), Tensor(Hidden)
  optionals: Bias

- op: gt_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: hash
  inputs: (Tensor X)
  attrs: (int num_hash, int64_t mod_by, bool ALL_KERNELS_MUST_COMPUTE_RUNTIME_SHAPE,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out)

- op: heter_listen_and_serv
  inputs: (Tensor[] X)
  attrs: (str endpoint, int pserver_id, str[] message_to_block_id, int distributed_mode,
    BLOCKS optimize_blocks, int fanin, int rpc_exec_thread_num, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: hinge_loss
  inputs: (Tensor Logits, Tensor Labels)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Loss)

- op: im2sequence
  inputs: (Tensor X, Tensor Y)
  attrs: (int[] kernels, int[] strides, int[] paddings, int[] out_stride, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)
  optionals: Y

- op: iou_similarity
  inputs: (Tensor X, Tensor Y)
  attrs: (bool box_normalized, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: ipu_runtime
  inputs: (Tensor FeedList)
  attrs: ()
  outputs: Tensor(FetchList)

- op: l1_norm
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: limit_by_capacity
  inputs: (Tensor expert_count, Tensor capacity)
  attrs: (int n_worker, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: linear_chain_crf
  inputs: (Tensor Emission, Tensor Transition, Tensor Label, Tensor Length)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Alpha), Tensor(EmissionExps), Tensor(TransitionExps), Tensor(LogLikelihood)
  optionals: Length

- op: listen_and_serv
  inputs: (Tensor[] X)
  attrs: (str endpoint, int pserver_id, str[] grad_to_block_id, int distributed_mode,
    bool dc_asgd, BLOCKS optimize_blocks, str[] prefetch_var_name_to_block_id, str[]
    sparse_grad_to_param, int Fanin, int checkpint_block_id, int lr_decay_block_id,
    int rpc_get_thread_num, int rpc_send_thread_num, int rpc_prefetch_thread_num,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: ''

- op: lite_engine
  inputs: (Tensor[] Xs)
  attrs: (str engine_key)
  outputs: Tensor[](Ys)

- op: load
  inputs: ()
  attrs: (bool load_as_fp16, str file_path, int64_t seek, int64_t[] shape, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: locality_aware_nms
  inputs: (Tensor BBoxes, Tensor Scores)
  attrs: (int background_label, float score_threshold, int nms_top_k, float nms_threshold,
    float nms_eta, int keep_top_k, bool normalized, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: lod_rank_table
  inputs: (Tensor X)
  attrs: (int level, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: lod_reset
  inputs: (Tensor X, Tensor Y)
  attrs: (int[] target_lod, bool append, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)
  optionals: Y

- op: lod_reset_
  inputs: (Tensor X, Tensor Y)
  attrs: (int[] target_lod, bool append, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)
  optionals: Y

- op: lod_tensor_to_array
  inputs: (Tensor X, Tensor RankTable)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor|TensorArray?(Out)

- op: log_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: lookup_table
  inputs: (Tensor W, Tensor Ids)
  attrs: (bool is_sparse, bool is_distributed, int64_t padding_idx, bool remote_prefetch,
    str entry_config, bool is_test, str entry, str table_class, str[] table_names,
    int trainer_id, int slot, bool grad_inplace, str[] epmap, int64_t[] height_sections,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out)

- op: lookup_table_dequant
  inputs: (Tensor W, Tensor Ids)
  attrs: (int64_t padding_idx, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: lstm
  inputs: (Tensor Input, Tensor H0, Tensor C0, Tensor Weight, Tensor Bias)
  attrs: (bool use_peepholes, bool is_reverse, bool is_test, str gate_activation,
    str cell_activation, str candidate_activation, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Hidden), Tensor(Cell), Tensor(BatchGate), Tensor(BatchCellPreAct)
  optionals: H0,C0

- op: masked_multihead_attention
  inputs: (Tensor x, Tensor cache_kv, Tensor bias, Tensor src_mask, Tensor cum_offsets,
    Tensor sequence_lengths, Tensor rotary_tensor, Tensor beam_cache_offset, Tensor
    qkv_out_scale, Tensor out_shift, Tensor out_smooth)
  attrs: (int seq_len, int rotary_emb_dims, bool use_neox_rotary_style, str compute_dtype,
    float out_scale, int quant_round_type, float quant_max_bound, float quant_min_bound,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(out), Tensor(cache_kv_out), Tensor(beam_cache_offset_out)
  optionals: bias,src_mask,cum_offsets,sequence_lengths,rotary_tensor,beam_cache_offset,qkv_out_scale,out_shift,out_smooth

- op: matmul_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: max_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: max_sequence_len
  inputs: (Tensor RankTable)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: merge_lod_tensor
  inputs: (Tensor X, Tensor Mask, Tensor InTrue, Tensor InFalse)
  attrs: (int level, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: merge_lod_tensor_infer
  inputs: (Tensor X, Tensor Mask, Tensor InTrue, Tensor InFalse)
  attrs: (int level, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: merged_adam
  inputs: (Tensor[] Param, Tensor[] Grad, Tensor[] LearningRate, Tensor[] Moment1,
    Tensor[] Moment2, Tensor[] Beta1Pow, Tensor[] Beta2Pow, Tensor[] MasterParam)
  attrs: (float beta1, float beta2, float epsilon, bool multi_precision, bool use_global_beta_pow,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor[](ParamOut), Tensor[](Moment1Out), Tensor[](Moment2Out), Tensor[](Beta1PowOut),
    Tensor[](Beta2PowOut), Tensor[](MasterParamOut)
  optionals: MasterParam,MasterParamOut

- op: mine_hard_examples
  inputs: (Tensor ClsLoss, Tensor LocLoss, Tensor MatchIndices, Tensor MatchDist)
  attrs: (float neg_pos_ratio, float neg_dist_threshold, int sample_size, str mining_type,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(NegIndices), Tensor(UpdatedMatchIndices)
  optionals: LocLoss

- op: minus
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: modified_huber_loss
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(IntermediateVal), Tensor(Out)

- op: moe
  inputs: (Tensor X, Tensor Gate, Tensor Bmm0, Tensor Bias0, Tensor Bmm1, Tensor Bias1)
  attrs: (str act_type, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: moving_average_abs_max_scale
  inputs: (Tensor X, Tensor InAccum, Tensor InState)
  attrs: (float moving_rate, bool is_test, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(OutScale), Tensor(OutState), Tensor(OutAccum)
  optionals: InAccum,InState,Out,OutState,OutAccum

- op: mp_allreduce_sum
  inputs: (Tensor X)
  attrs: (int ring_id, bool use_calc_stream, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: mp_allreduce_sum_
  inputs: (Tensor X)
  attrs: (int ring_id, bool use_calc_stream, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: mul_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: multi_gru
  inputs: (Tensor x, Tensor[] weight_x, Tensor[] weight_h, Tensor[] bias, Tensor[]
    scale_weights)
  attrs: (str activation, str gate_activation, int layers, bool origin_mode, str mkldnn_data_type,
    float scale_data, float shift_data, bool force_fp32_output, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(hidden)
  optionals: bias,scale_weights

- op: multiclass_nms
  inputs: (Tensor BBoxes, Tensor Scores)
  attrs: (int background_label, float score_threshold, int nms_top_k, float nms_threshold,
    float nms_eta, int keep_top_k, bool normalized, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: multiclass_nms2
  inputs: (Tensor BBoxes, Tensor Scores)
  attrs: (int background_label, float score_threshold, int nms_top_k, float nms_threshold,
    float nms_eta, int keep_top_k, bool normalized, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(Index)

- op: ncclAllReduce
  inputs: (Tensor X,Tensor)
  attrs: (str reduction)
  outputs: Tensor(Out)

- op: ncclBcast
  inputs: (Tensor X, Tensor Communicator)
  attrs: (int root)
  outputs: Tensor(Out)

- op: ncclInit
  inputs: (Tensor X, Tensor Communicator)
  attrs: (int root)
  outputs: Tensor(Out)

- op: ncclReduce
  inputs: (Tensor X, Tensor Communicator)
  attrs: (str reduction, int root)
  outputs: Tensor(Out)

- op: ne_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: nop
  inputs: (Tensor[] X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: p_recv
  inputs: ()
  attrs: (int ring_id, int peer, int dtype, bool dynamic_shape, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: p_recv_array
  inputs: ()
  attrs: (int ring_id, int peer, int dtype, int[] out_shape, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: p_send
  inputs: (Tensor x)
  attrs: (int ring_id, int peer, bool dynamic_shape, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: p_send_array
  inputs: (Tensor[] x)
  attrs: (int ring_id, int peer, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: pad2d
  inputs: (Tensor X, Tensor Paddings)
  attrs: (int[] paddings, float pad_value, str mode, str data_format, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)
  optionals: Paddings

- op: partial_allgather
  inputs: (Tensor X)
  attrs: (int ring_id, bool use_calc_stream, int nranks, int rank, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: partial_allgather_
  inputs: (Tensor X)
  attrs: (int ring_id, bool use_calc_stream, int nranks, int rank, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: partial_concat
  inputs: (Tensor[] X)
  attrs: (int start_index, int length, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: partial_recv
  inputs: ()
  attrs: (int ring_id, int peer, int dtype, int[] out_shape, bool use_calc_stream,
    int num, int id, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: partial_sum
  inputs: (Tensor[] X)
  attrs: (int start_index, int length, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: polygon_box_transform
  inputs: (Tensor Input)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Output)

- op: positive_negative_pair
  inputs: (Tensor Score, Tensor Label, Tensor QueryID, Tensor AccumulatePositivePair,
    Tensor AccumulateNegativePair, Tensor AccumulateNeutralPair, Tensor Weight)
  attrs: (int column, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(PositivePair), Tensor(NegativePair), Tensor(NeutralPair)
  optionals: AccumulatePositivePair,AccumulateNegativePair,AccumulateNeutralPair,Weight,NeutralPair

- op: pow2_decay_with_linear_warmup
  inputs: (Tensor LearningRate, Tensor Step)
  attrs: (int64_t warmup_steps, int64_t total_steps, float base_lr, float end_lr,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(LearningRateOut), Tensor(StepOut)

- op: pow_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: precision_recall
  inputs: (Tensor MaxProbs, Tensor Indices, Tensor Labels, Tensor Weights, Tensor
    StatesInfo)
  attrs: (int class_number, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(BatchMetrics), Tensor(AccumMetrics), Tensor(AccumStatesInfo)
  optionals: Weights,StatesInfo

- op: proximal_gd
  inputs: (Tensor Param, Tensor Grad, Tensor LearningRate)
  attrs: (float l1, float l2, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(ParamOut)

- op: prune_gate_by_capacity
  inputs: (Tensor GateIdx, Tensor ExpertCount)
  attrs: (int64_t n_expert, int64_t n_worker, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(NewGateIdx)

- op: pull_box_extended_sparse
  inputs: (Tensor[] Ids)
  attrs: (int emb_size, int emb_extended_size, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor[](OutExtend)

- op: pull_box_sparse
  inputs: (Tensor W, Tensor[] Ids)
  attrs: (bool is_sparse, bool is_distributed, int size, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)
  optionals: W

- op: pull_gpups_sparse
  inputs: (Tensor W, Tensor[] Ids)
  attrs: (int[] size, bool is_sparse, bool is_distributed, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)
  optionals: W

- op: pull_sparse
  inputs: (Tensor[] Ids, Tensor[] W)
  attrs: (int EmbeddingDim, int TableId, str AccessorClass, str CtrLabelName, int
    PaddingId, bool ScaleSparseGrad, str[] InputNames, bool is_distributed, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: pull_sparse_v2
  inputs: (Tensor[] Ids, Tensor[] W)
  attrs: (int EmbeddingDim, int TableId, str AccessorClass, str CtrLabelName, int
    PaddingId, bool ScaleSparseGrad, str[] InputNames, bool is_distributed, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: push_box_extended_sparse
  inputs: (Tensor[] Ids)
  attrs: (int emb_size, int emb_extended_size)
  outputs: Tensor[](Out), Tensor[](OutExtend)

- op: push_box_sparse
  inputs: (Tensor W, Tensor[] Ids)
  attrs: (bool is_sparse, bool is_distributed, int size)
  outputs: Tenor[](Out)
  optionals: W

- op: push_dense
  inputs: (Tensor[] Ids)
  attrs: (int TableId, float ScaleDataNorm, str[] InputNames, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: py_func
  inputs: (Tensor[] X)
  attrs: (int forward_callable_id, int backward_callable_id, str[] backward_skip_vars,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor[](Out)

- op: pylayer
  inputs: (Tensor[] Input)
  attrs: (BLOCKS blocks, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor(Scope)

- op: pyramid_hash
  inputs: (Tensor X, Tensor W, Tensor WhiteList, Tensor BlackList)
  attrs: (int num_emb, int space_len, int pyramid_layer, int rand_len, float drop_out_percent,
    int is_training, bool use_filter, int white_list_len, int black_list_len, int
    seed, float lr, str distribute_update_vars, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(DropPos), Tensor(X_Temp_Out)

- op: quant_linear
  inputs: (Tensor x, Tensor w, Tensor bias)
  attrs: (int in_num_col_dims, str activation_type, bool padding_weights, float scale_in,
    float[] scale_weights, int quant_round_type, float quant_max_bound, float quant_min_bound,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(out)
  optionals: bias

- op: quantize
  inputs: (Tensor input)
  attrs: (bool is_negative_input, float scale, float shift, str output_format, bool
    bfloat16, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(output)

- op: quantize_linear
  inputs: (Tensor X, Tensor Scale, Tensor ZeroPoint, Tensor InAccum, Tensor InState)
  attrs: (int quant_axis, int bit_length, int round_type, bool is_test, bool only_observer,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Y), Tensor(OutState), Tensor(OutAccum), Tensor(OutScale)
  optionals: InAccum,InState,OutState,OutAccum,OutScale

- op: queue_generator
  inputs: ()
  attrs: (str[] names, int capacity, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: ''

- op: random_routing
  inputs: (Tensor Prob, Tensor TopK_Value, Tensor TopK_Idx)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: random_routing_
  inputs: (Tensor Prob, Tensor TopK_Value, Tensor TopK_Idx)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: rank_attention
  inputs: (Tensor X, Tensor RankOffset, Tensor RankParam)
  attrs: (int MaxRank, int MaxSize, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(InputHelp), Tensor(Out), Tensor(InsRank)
  optionals: InputHelp,InsRank

- op: rank_loss
  inputs: (Tensor Label, Tensor Left, Tensor Right)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: read
  inputs: (Tensor Reader)
  attrs: (bool throw_eof_exp, bool infer_out, bool drop_last, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: read_from_array
  inputs: (Tensor|TensorArray? array, Tensor i, Tensor X_W)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)
  optionals: X_W

- op: recurrent
  inputs: (Tensor[] inputs, Tensor[] initial_states, Tensor[] parameters)
  attrs: (bool has_states, str[] ex_states, str[] states, BLOCK sub_block, bool reverse,
    bool is_train, str[] skip_eager_deletion_vars, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](outputs), Tensor(step_scopes)

- op: reduce
  inputs: (Tensor x)
  attrs: (int ring_id, int root_id, int reduce_type, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: reduce_scatter
  inputs: (Tensor x)
  attrs: (int ring_id, int nranks, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: reduce_sum_p
  inputs: (Tensor X)
  attrs: (int64_t[] axis, bool keepdim, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: reorder_lod_tensor_by_rank
  inputs: (Tensor X, Tensor RankTable)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: requantize
  inputs: (Tensor input)
  attrs: (float scale_in, float scale_out, float shift_in, float shift_out, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(output)

- op: reshape2_
  inputs: (Tensor x, Tensor Shape, Tensor[] ShapeTensor)
  attrs: (int[] shape, bool use_quantizer, str mkldnn_data_type, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(xshape)
  optionals: Shape,ShapeTensor

- op: reshape_p
  inputs: (Tensor X)
  attrs: (int64_t[] shape, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: resnet_basic_block
  inputs: (Tensor X, Tensor Filter1, Tensor Scale1, Tensor Bias1, Tensor Mean1, Tensor
    Var1, Tensor Filter2, Tensor Scale2, Tensor Bias2, Tensor Mean2, Tensor Var2,
    Tensor Filter3, Tensor Scale3, Tensor Bias3, Tensor Mean3, Tensor Var3)
  attrs: (int stride1, int stride2, int stride3, int padding1, int padding2, int padding3,
    int dilation1, int dilation2, int dilation3, int group, float momentum, float
    epsilon, str data_format, bool has_shortcut, bool use_global_stats,BOOLEAN, bool
    trainable_statistics, str act_type, bool find_conv_input_max)
  outputs: Tensor(Y), Tensor(Conv1), Tensor(SavedMean1), Tensor(SavedInvstd1), Tensor(Mean1Out),
    Tensor(Var1Out), Tensor(Conv2), Tensor(Conv2Input), Tensor(SavedMean2), Tensor(SavedInvstd2),
    Tensor(Mean2Out), Tensor(Var2Out), Tensor(Conv3), Tensor(SavedMean3), Tensor(SavedInvstd3),
    Tensor(Mean3Out), Tensor(Var3Out), Tensor(MaxInput1), Tensor(MaxFilter1), Tensor(MaxInput2),
    Tensor(MaxFilter2), Tensor(MaxInput3), Tensor(MaxFilter3)
  optionals: Filter3,Scale3,Bias3,Mean3,Var3,Conv3,SavedMean3,SavedInvstd3,Mean3Out,Var3Out

- op: resnet_unit
  inputs: (Tensor X, Tensor FilterX, Tensor ScaleX, Tensor BiasX, Tensor MeanX, Tensor
    VarX, Tensor Z, Tensor FilterZ, Tensor ScaleZ, Tensor BiasZ, Tensor MeanZ, Tensor
    VarZ)
  attrs: (int stride, int stride_z, int padding, int dilation, int group, float momentum,
    float epsilon, str data_format, bool fuse_add, bool has_shortcut, bool use_global_stats,
    bool is_test, bool use_addto, str act_type, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y), Tensor(BitMask), Tensor(ConvX), Tensor(SavedMeanX), Tensor(SavedInvstdX),
    Tensor(RunningMeanX), Tensor(RunningVarX), Tensor(ConvZ), Tensor(SavedMeanZ),
    Tensor(SavedInvstdZ), Tensor(RunningMeanZ), Tensor(RunningVarZ)
  optionals: Z,FilterZ,ScaleZ,BiasZ,MeanZ,VarZ,ConvZ,SavedMeanZ,SavedInvstdZ,RunningMeanZ,RunningVarZ

- op: retinanet_detection_output
  inputs: (Tensor[] BBoxes, Tensor[] Scores, Tensor[] Anchors, Tensor ImInfo)
  attrs: (float score_threshold, int nms_top_k, float nms_threshold, float nms_eta,
    int keep_top_k, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: retinanet_target_assign
  inputs: (Tensor Anchor, Tensor GtBoxes, Tensor GtLabels, Tensor IsCrowd, Tensor
    ImInfo)
  attrs: (float positive_overlap, float negative_overlap, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(LocationIndex), Tensor(ScoreIndex), Tensor(TargetBBox), Tensor(TargetLabel),
    Tensor(BBoxInsideWeight), Tensor(ForegroundNumber)

- op: rpn_target_assign
  inputs: (Tensor Anchor, Tensor GtBoxes, Tensor IsCrowd, Tensor ImInfo)
  attrs: (int rpn_batch_size_per_im, float rpn_straddle_thresh, float rpn_positive_overlap,
    float rpn_negative_overlap, float rpn_fg_fraction, bool use_random, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(LocationIndex), Tensor(ScoreIndex), Tensor(TargetBBox), Tensor(TargetLabel),
    Tensor(BBoxInsideWeight)

- op: rprop
  inputs: (Tensor param, Tensor grad, Tensor prev, Tensor learning_rate, Tensor master_param,
    Tensor learning_rate_range, Tensor etas)
  attrs: (bool multi_precision, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(param_out), Tensor(prev_out), Tensor(learning_rate_out), Tensor(master_param_out)
  optionals: master_param,master_param_out

- op: rsqrt_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: run_program
  inputs: (Tensor[] X, Tensor[] Params)
  attrs: (BLOCK global_block, int64_t start_op_index, int64_t end_op_index, bool is_test,
    bool in_pir_pt_mode, int64_t program_id, str cuda_graph_capture_mode, int64_t
    cuda_graph_pool_id, bool use_interpretorcore, BLOCK forward_global_block, BLOCK
    backward_global_block, str[] param_grad_names, str[] out_grad_names, str[] x_names,
    str[] x_grad_names, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor(OutScope), Tensor[](DOut), Tensor(CUDAGraph)
  optionals: Params,DOut,CUDAGraph

- op: sampling_id
  inputs: (Tensor X)
  attrs: (float min, float max, int seed, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: save
  inputs: (Tensor X)
  attrs: (bool overwrite, bool save_as_fp16, str file_path, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(kLookupTablePath)
  optionals: kLookupTablePath

- op: scatter_add_p
  inputs: (Tensor X, Tensor Y, Tensor IndexTensor)
  attrs: (int64_t axis, int64_t[] index, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Z)
  optionals: IndexTensor

- op: select_input
  inputs: (Tensor[] X, Tensor Mask)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: select_output
  inputs: (Tensor|TensorArray? X, Tensor Mask)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: select_p
  inputs: (Tensor Condition, Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: send
  inputs: (Tensor[] X)
  attrs: (int table_id, int is_sparse, str[] send_varnames, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: send_and_recv
  inputs: (Tensor[] X)
  attrs: (str message_name, str mode, str[] send_var_name, str[] recv_var_name, int
    trainer_id, str[] endpoints, str[] next_endpoints, str[] previous_endpoints, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor[](Out)

- op: send_barrier
  inputs: (Tensor[] X)
  attrs: (int trainer_id, str[] endpoints, bool half_async, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out)

- op: sequence_concat
  inputs: (Tensor[] X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_conv
  inputs: (Tensor X, Tensor PaddingData, Tensor Filter)
  attrs: (bool paddingTrainable, int contextLength, int contextStart, int contextStride,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out)
  optionals: PaddingData

- op: sequence_enumerate
  inputs: (Tensor X)
  attrs: (int win_size, int pad_value, bool ALL_KERNELS_MUST_COMPUTE_RUNTIME_SHAPE,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_erase
  inputs: (Tensor X)
  attrs: (int[] tokens, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_expand
  inputs: (Tensor X, Tensor Y)
  attrs: (int ref_level, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_expand_as
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_pad
  inputs: (Tensor X, Tensor PadValue)
  attrs: (int padded_length, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(Length)

- op: sequence_pool
  inputs: (Tensor X)
  attrs: (bool is_test, str pooltype, float pad_value, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(MaxIndex)

- op: sequence_reshape
  inputs: (Tensor X)
  attrs: (int new_dim, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_reverse
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: sequence_scatter
  inputs: (Tensor X, Tensor Ids, Tensor Updates)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_slice
  inputs: (Tensor X, Tensor Offset, Tensor Length)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_softmax
  inputs: (Tensor X)
  attrs: (bool use_cudnn, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sequence_unpad
  inputs: (Tensor X, Tensor Length)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: shadow_output
  inputs: (Tensor x)
  attrs: (str name, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: share_buffer
  inputs: (Tensor[] x)
  attrs: (BOOLEANS share_dims_and_dtype, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](out), Tensor[](xout)

- op: shrink_rnn_memory
  inputs: (Tensor X, Tensor RankTable, Tensor I)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: shuffle_channel
  inputs: (Tensor X)
  attrs: (int group, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: similarity_focus
  inputs: (Tensor X)
  attrs: (int axis, int[] indexes, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sin_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: slice_assign_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int64_t[] axis, int64_t[] starts, int64_t[] ends, int64_t[] strides, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Z)

- op: slice_select_p
  inputs: (Tensor X)
  attrs: (int64_t[] axis, int64_t[] starts, int64_t[] ends, int64_t[] strides, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(Y)

- op: soft_relu_
  inputs: (Tensor x)
  attrs: (float threshold, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: softmax_with_cross_entropy_
  inputs: (Tensor input, Tensor label)
  attrs: (bool soft_label, bool use_softmax, bool numeric_stable_mode, int ignore_index,
    int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(softmax), Tensor(loss)

- op: sparse_abs
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_acos
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_acosh
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_add
  inputs: (Tensor x, Tensor y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_addmm
  inputs: (Tensor input, Tensor x, Tensor y)
  attrs: (float beta, float alpha, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_asin
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_asinh
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_atan
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_atanh
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_attention
  inputs: (Tensor Q, Tensor K, Tensor V, Tensor Offset, Tensor Columns, Tensor KeyPaddingMask,
    Tensor AttnMask)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(SparseDotSdd), Tensor(Softmax)
  optionals: KeyPaddingMask,AttnMask

- op: sparse_batch_norm
  inputs: (Tensor x, Tensor mean, Tensor variance, Tensor scale, Tensor bias)
  attrs: (bool is_test, float momentum, float epsilon, str data_layout, bool use_global_stats,
    bool trainable_statistics, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean),
    Tensor(saved_variance), Tensor(reserve_space)

- op: sparse_cast
  inputs: (Tensor x)
  attrs: (int index_dtype, int value_dtype, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_coalesce
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_conv3d
  inputs: (Tensor x, Tensor kernel)
  attrs: (int[] paddings, int[] dilations, int[] strides, int groups, bool subm, str
    key, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(rulebook), Tensor(counter)

- op: sparse_divide
  inputs: (Tensor x, Tensor y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_divide_scalar
  inputs: (Tensor x)
  attrs: (float scalar, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_expm1
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_full_like
  inputs: (Tensor x, Tensor ValueTensor)
  attrs: (float value, int dtype, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)
  optionals: ValueTensor

- op: sparse_fused_attention
  inputs: (Tensor query, Tensor key, Tensor value, Tensor sparse_mask, Tensor key_padding_mask,
    Tensor attn_mask)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(softmax)
  optionals: key_padding_mask,attn_mask

- op: sparse_indices
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_isnan
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_leaky_relu
  inputs: (Tensor x)
  attrs: (float alpha, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_log1p
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_masked_matmul
  inputs: (Tensor x, Tensor y, Tensor mask)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_matmul
  inputs: (Tensor x, Tensor y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_maxpool
  inputs: (Tensor x)
  attrs: (int[] kernel_sizes, int[] paddings, int[] dilations, int[] strides, int
    op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(out), Tensor(rulebook), Tensor(counter)

- op: sparse_multiply
  inputs: (Tensor x, Tensor y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_mv
  inputs: (Tensor x, Tensor vec)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_pow
  inputs: (Tensor x)
  attrs: (float factor, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_relu
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_relu6
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_reshape
  inputs: (Tensor x, Tensor ShapeTensor, Tensor[] ShapeTensorList)
  attrs: (int64_t[] shape, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)
  optionals: ShapeTensor,ShapeTensorList

- op: sparse_scale
  inputs: (Tensor x)
  attrs: (float scale, float bias, bool bias_after_scale, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_sin
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_sinh
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_slice
  inputs: (Tensor x, Tensor AxesTensor, Tensor[] AxesTensorList, Tensor StartsTensor,
    Tensor[] StartsTensorList, Tensor EndsTensor, Tensor[] EndsTensorList)
  attrs: (int64_t[] axes, int64_t[] starts, int64_t[] ends, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)
  optionals: AxesTensor,AxesTensorList,StartsTensor,StartsTensorList,EndsTensor,EndsTensorList

- op: sparse_softmax
  inputs: (Tensor x)
  attrs: (int axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_sparse_coo_tensor
  inputs: (Tensor values, Tensor indices)
  attrs: (int64_t[] shape, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_sqrt
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_square
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_subtract
  inputs: (Tensor x, Tensor y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_sum
  inputs: (Tensor x, Tensor AxisTensor, Tensor[] AxisTensorList)
  attrs: (int64_t[] axis, int dtype, bool keepdim, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)
  optionals: AxisTensor,AxisTensorList

- op: sparse_sync_batch_norm
  inputs: (Tensor x, Tensor mean, Tensor variance, Tensor scale, Tensor bias)
  attrs: (bool is_test, float momentum, float epsilon, str data_layout, bool use_global_stats,
    bool trainable_statistics, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean),
    Tensor(saved_variance), Tensor(reserve_space)

- op: sparse_tan
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_tanh
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_to_dense
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_to_sparse_coo
  inputs: (Tensor x)
  attrs: (int64_t sparse_dim, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_to_sparse_csr
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_transpose
  inputs: (Tensor x)
  attrs: (int[] perm, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sparse_values
  inputs: (Tensor x)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: split_lod_tensor
  inputs: (Tensor X, Tensor Mask)
  attrs: (int level, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(OutTrue), Tensor(OutFalse)

- op: split_p
  inputs: (Tensor X)
  attrs: (int64_t axis, int64_t[] num_or_sections, int op_role, str[] op_role_var,
    str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](YS)

- op: spp
  inputs: (Tensor X)
  attrs: (int pyramid_height, str pooling_type, int op_role, str[] op_role_var, str
    op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sqrt_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: squeeze2_
  inputs: (Tensor x)
  attrs: (int[] axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(xshape)

- op: stft
  inputs: (Tensor X, Tensor Window)
  attrs: (int n_fft, int hop_length, bool normalized, bool onesided, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: sub_p
  inputs: (Tensor X, Tensor Y)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Z)

- op: sum_
  inputs: (Tensor[] inputs)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: sync_batch_norm
  inputs: (Tensor x, Tensor scale, Tensor bias, Tensor mean, Tensor variance, Tensor
    MomentumTensor)
  attrs: (bool is_test, float momentum, float epsilon, str data_format, bool use_global_stats,
    bool trainable_statistics, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean),
    Tensor(saved_variance), Tensor(reserve_space)
  optionals: scale,bias,MomentumTensor,reserve_space

- op: tanh_p
  inputs: (Tensor X)
  attrs: (int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str
    op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: tdm_child
  inputs: (Tensor X, Tensor TreeInfo)
  attrs: (int child_nums, int dtype, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Child), Tensor(LeafMask)

- op: teacher_student_sigmoid_loss
  inputs: (Tensor X, Tensor Label)
  attrs: (float soft_max_up_bound, float soft_max_lower_bound, int op_role, str[]
    op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: tensorrt_engine
  inputs: (Tensor[] Xs)
  attrs: (str subgraph, str calibration_data, str engine_serialized_data, str engine_key,
    int max_batch_size, int64_t workspace_size, BLOCK sub_block, bool enable_int8)
  outputs: Tensor[](Ys)

- op: top_k
  inputs: (Tensor X, Tensor K)
  attrs: (int k, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(Indices)
  optionals: K

- op: transfer_dtype
  inputs: (Tensor X)
  attrs: (int out_dtype, int in_dtype, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: transfer_layout
  inputs: (Tensor X)
  attrs: (int src_layout, int dst_layout, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: transpose_p
  inputs: (Tensor X)
  attrs: (int64_t[] axis, int op_role, str[] op_role_var, str op_namescope, str[]
    op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: tril_triu
  inputs: (Tensor x)
  attrs: (int diagonal, bool lower, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(out)

- op: uniform_random_inplace_
  inputs: (Tensor x)
  attrs: (float min, float max, int seed, int diag_num, int diag_step, float diag_val,
    int op_role, str[] op_role_var, str op_namescope, str[] op_callstack, str op_device,
    bool with_quant_attr)
  outputs: Tensor(out)

- op: uniform_random_p
  inputs: ()
  attrs: (int64_t[] shape, float min, float max, int seed, int dtype, int op_role,
    str[] op_role_var, str op_namescope, str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: unique_with_counts
  inputs: (Tensor X)
  attrs: (int dtype, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(Index), Tensor(Count)

- op: unsqueeze2_
  inputs: (Tensor x, Tensor AxesTensor, Tensor[] AxesTensorList)
  attrs: (int[] axis, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(out), Tensor(xshape)
  optionals: AxesTensor,AxesTensorList

- op: unzip
  inputs: (Tensor X, Tensor lod)
  attrs: (int len, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Y)

- op: var_conv_2d
  inputs: (Tensor X, Tensor ROW, Tensor COLUMN, Tensor W)
  attrs: (int InputChannel, int OutputChannel, int StrideH, int StrideW, int KernelH,
    int KernelW, int op_role, str[] op_role_var, str op_namescope, str[] op_callstack,
    str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(Col)

- op: while
  inputs: (Tensor[] X, Tensor[] Condition)
  attrs: (BLOCK sub_block, bool is_test, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor[](Out), Tensor(StepScopes)

- op: yolo_box_head
  inputs: (Tensor X)
  attrs: (int[] anchors, int class_num, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out)

- op: yolo_box_post
  inputs: (Tensor Boxes0, Tensor Boxes1, Tensor Boxes2, Tensor ImageShape, Tensor
    ImageScale)
  attrs: (int[] anchors0, int[] anchors1, int[] anchors2, int class_num, float conf_thresh,
    int downsample_ratio0, int downsample_ratio1, int downsample_ratio2, bool clip_bbox,
    float scale_x_y, float nms_threshold, int op_role, str[] op_role_var, str op_namescope,
    str[] op_callstack, str op_device, bool with_quant_attr)
  outputs: Tensor(Out), Tensor(NmsRoisNum)

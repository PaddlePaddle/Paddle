# Copyright (c) 2023 PaddlePaddle Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import argparse
import inspect
import re
from dataclasses import dataclass
from functools import cached_property
from typing import Any, Callable, Literal

from typing_extensions import TypeAlias

import paddle

INDENT_SIZE = 4
INDENT = " " * INDENT_SIZE

MemberType: TypeAlias = Literal[
    "attribute",
    "method",
]


@dataclass
class Member:
    id: int
    name: str
    type: MemberType
    aliases: list[str]
    decorators: list[str]
    signature: str
    doc: str | None

    def add_alias(self, alias: str):
        self.aliases.append(alias)


class TensorGen:
    _future_features: list[str]
    _import_stmts: list[str]
    _attributes: dict[str, str]
    _methods: list[Member]
    _aliases: dict[str, str]

    def __init__(self):
        self._future_features: list[str] = []
        self._import_stmts: list[str] = []
        self._attributes: dict[str, str] = {}
        self._methods: list[Member] = []
        self._aliases: dict[str, str] = {}
        self.add_future("annotations")

    def add_future(self, feature: str):
        self._future_features.append(feature)

    def add_import(self, import_stmt: str):
        self._import_stmts.append(import_stmt)

    def add_attribute(self, name: str, type: str):
        self._attributes[name] = type

    def add_method(self, func: Member):
        self._methods.append(func)

    def add_alias(self, alias: str, target: str):
        self._aliases[alias] = target

    @property
    def future_imports(self):
        futures = ", ".join(self._future_features)
        return f"from __future__ import {futures}"

    @property
    def imports(self):
        # TODO: sort import like the isort
        imports = "\n".join(self._import_stmts)
        return imports

    @property
    def tensor_spec(self) -> str:
        return """class Tensor:"""

    @property
    def tensor_attributes(self) -> str:
        attributes_code = ""
        for name, type_ in self._attributes.items():
            attributes_code += f"{INDENT}{name}: {type_}\n"
        return attributes_code

    @property
    def tensor_methods(self) -> str:
        method_code = ""
        for method in self._methods:
            for decorator in method.decorators:
                method_code += f"@{decorator}\n"
            method_code += f"def {method.signature}:\n"
            if method.doc:
                method_code += f'{INDENT}r"""\n'
                method_code += with_indent(method.doc, 1)
                method_code += "\n"
                method_code += f'{INDENT}"""\n'
            method_code += f"{INDENT}...\n"
            method_code += "\n"
        return with_indent(method_code, 1)

    @property
    def tensor_aliases(self) -> str:
        aliases_code = ""
        for alias, target in self._aliases.items():
            aliases_code += f"{INDENT}{alias} = {target}\n"
        return aliases_code

    def codegen(self) -> str:
        code = f"""\
# This file is auto-generated by tools/gen_tensor_stub.py
{self.future_imports}
{self.imports}
{self.tensor_spec}
{self.tensor_attributes}
{self.tensor_methods}
{self.tensor_aliases}
"""
        return code


def is_inherited_member(name: str, cls: type) -> bool:
    """Check if the member is inherited from parent class"""

    if name in cls.__dict__:
        return False

    for base in cls.__bases__:
        if name in base.__dict__:
            return True

    return any(is_inherited_member(name, base) for base in cls.__bases__)


def is_property(member: Any) -> bool:
    """Check if the member is a property"""

    return isinstance(member, (property, cached_property))


def is_staticmethod(member: Any) -> bool:
    """Check if the member is a staticmethod"""

    return isinstance(member, staticmethod)


def is_classmethod(member: Any) -> bool:
    """Check if the member is a classmethod"""

    return isinstance(member, classmethod)


# def get_signature(obj: Any):

#     try:
#         return inspect.signature(obj)
#     except ValueError:
#         return


def process_lines(code: str, callback: Callable[[str], str]) -> str:
    lines = code.splitlines()
    end_with_newline = code.endswith("\n")
    processed_lines: list[str] = []
    for line in lines:
        processed_lines.append(callback(line))
    processed_code = "\n".join(processed_lines)
    if end_with_newline:
        processed_code += "\n"
    return processed_code


def with_indent(code: str, level: int) -> str:
    def add_indent_line(line: str) -> str:
        if not line:
            return line
        return INDENT + line

    def remove_indent_line(line: str) -> str:
        if not line:
            return line
        elif line.startswith(INDENT):
            return line.removeprefix(INDENT)
        else:
            return line

    if level == 0:
        return code
    elif level > 0:
        if level == 1:
            return process_lines(code, add_indent_line)
        return with_indent(code, level - 1)
    else:
        if level == -1:
            return process_lines(code, remove_indent_line)
        return with_indent(code, level - 1)


def func_sig_to_method_sig(func_sig: str) -> str:
    regex_func_sig = re.compile(
        r"^(?P<method_name>[_a-zA-Z0-9]+)\((?P<arg0>[^,)]+(:.+)?)(?P<rest_args>.*)\)",
        re.DOTALL,
    )
    matched = regex_func_sig.search(func_sig)
    if matched is None:
        # TODO: resolve this case
        print(f"[Warning] Cannot parse function signature: {func_sig}")
        return "_(self)"
    method_sig = regex_func_sig.sub(
        r"\g<method_name>(self\g<rest_args>)", func_sig
    )
    return method_sig


def func_doc_to_method_doc(func_doc: str) -> str:
    # Iterate every line, insert the indent and remove document of the first argument
    method_doc = ""
    is_first_arg = False
    first_arg_offset = 0

    for line in func_doc.splitlines():
        current_line_offset = len(line) - len(line.lstrip())
        # Remove the first argument (self in Tensor method) from docstring
        if is_first_arg:
            if current_line_offset <= first_arg_offset:
                is_first_arg = False
            if not first_arg_offset:
                first_arg_offset = current_line_offset
            if is_first_arg:
                continue
        method_doc += f"{line}\n" if line else "\n"
        if line.lstrip().startswith("Args:"):
            is_first_arg = True

    return method_doc


def get_tensor_members():
    tensor_class = paddle.Tensor

    members: dict[int, Member] = {}
    for name, member in inspect.getmembers(tensor_class):
        member_id = id(member)
        member_doc = inspect.getdoc(member)
        member_doc_cleaned = (
            func_doc_to_method_doc(inspect.cleandoc(member_doc))
            if member_doc is not None
            else None
        )
        try:
            sig = inspect.signature(member)
            # TODO: classmethod
            member_signature = f"{name}{sig}"

        except (TypeError, ValueError):
            member_signature = f"{name}()"

        if is_inherited_member(name, tensor_class):
            continue

        # Filter out private members except magic methods
        if name.startswith("_") and not (
            name.startswith("__") and name.endswith("__")
        ):
            continue

        if member_id in members:
            members[member_id].add_alias(name)
            continue

        if is_property(member):
            members[member_id] = Member(
                member_id,
                name,
                "method",
                [],
                ["property"],
                f"{name}(self)",
                member_doc_cleaned,
            )
        elif is_classmethod(member):
            members[member_id] = Member(
                member_id,
                name,
                "method",
                [],
                ["classmethod"],
                member_signature,
                member_doc_cleaned,
            )
        elif is_staticmethod(member):
            members[member_id] = Member(
                member_id,
                name,
                "method",
                [],
                ["staticmethod"],
                member_signature,
                member_doc_cleaned,
            )
        elif (
            inspect.isfunction(member)
            or inspect.ismethod(member)
            or inspect.ismethoddescriptor(member)
        ):
            members[member_id] = Member(
                member_id,
                name,
                "method",
                [],
                [],
                func_sig_to_method_sig(member_signature),
                member_doc_cleaned,
            )
        elif inspect.isdatadescriptor(member):
            members[member_id] = Member(
                member_id,
                name,
                "attribute",
                [],
                [],
                member_signature,
                None,
            )
        else:
            print(name, member)
    return members


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-o",
        "--output-file",
        type=str,
        default="python/paddle/tensor/tensor.pyi",
    )

    args = parser.parse_args()

    # Get members of Tensor
    tensor_members = get_tensor_members()

    # Generate the Tensor stub
    tensor_gen = TensorGen()
    tensor_gen.add_import("import numpy as np")
    tensor_gen.add_import("from typing import Any")

    for member in tensor_members.values():
        if member.type == "method":
            tensor_gen.add_method(member)
            for alias in member.aliases:
                tensor_gen.add_alias(alias, member.name)
        elif member.type == "attribute":
            tensor_gen.add_attribute(member.name, "Any")

    # Write to target file
    with open(args.output_file, "w") as f:
        f.write(tensor_gen.codegen())


if __name__ == "__main__":
    main()

- api : add
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : add

- api : cast
  args : (Tensor x, DataType out_dtype)
  output : Tensor
  infer_meta :
    func : CastInferMeta
  kernel :
    func : cast
    param : [x, out_dtype]
    data_type : x


- api : concat
  args : (Tensor[] x, Scalar axis)
  output : Tensor
  infer_meta :
    func : ConcatInferMeta
    param : [x, axis]
  kernel :
    func : concat

- api : conj
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : conj

- api : copy_to
  args : (Tensor x, Backend backend, bool blocking)
  output : Tensor
  invoke : copy_to_impl(x, backend, blocking)

- api : divide
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : divide

- api : dot
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : DotInferMeta
  kernel :
    func : dot

- api : empty
  args : (ScalarArray shape, DataType dtype=DataType::FLOAT32, Backend place=Backend::CPU)
  output: Tensor
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : empty
    param : [shape, dtype]
    data_type : dtype
    backend : place

- api : empty_like
  args : (Tensor x, DataType dtype = DataType::UNDEFINED, Backend place = Backend::UNDEFINED)
  output: Tensor
  infer_meta :
    func : CreateLikeInferMeta
    param : [x, dtype]
  kernel :
    func : empty_like
    param : [x, dtype]
    data_type : dtype > x
    backend : place > x

- api : flatten
  args : (Tensor x, int start_axis, int stop_axis)
  output : Tensor
  infer_meta :
    func : FlattenInferMeta
  kernel :
    func : flatten

- api : full
  args : (ScalarArray shape, Scalar value, DataType dtype=DataType::FLOAT32, Backend place=Backend::CPU)
  output: Tensor
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : full
    param : [shape, value, dtype]
    data_type : dtype
    backend : place

- api : full_like
  args : (Tensor x, Scalar value, DataType dtype = DataType::UNDEFINED, Backend place = Backend::UNDEFINED)
  output: Tensor
  infer_meta :
    func : CreateLikeInferMeta
    param : [x, dtype]
  kernel :
    func : full_like
    param : [x, value, dtype]
    data_type : dtype > x
    backend : place > x

- api : matmul
  args : (Tensor x, Tensor y, bool transpose_x = false, bool transpose_y = false)
  output : Tensor
  infer_meta :
    func : MatmulInferMeta
  kernel :
    func : matmul
  backward : matmul_grad

- api : mean
  args : (Tensor x, int64[] axis={}, bool keep_dim=false)
  output : Tensor
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : mean

- api : multiply
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : multiply

- api : ones_like
  args : (Tensor x, DataType dtype=DataType::UNDEFINED, Backend place=Backend::UNDEFINED)
  output : Tensor
  invoke : full_like(x, 1, dtype, place)

- api : reshape
  args : (Tensor x, ScalarArray shape)
  output : Tensor(out)
  infer_meta :
    func : ReshapeInferMeta
  kernel :
    func : reshape
  inplace : (x -> out)

- api : relu
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : relu
  inplace : (x -> out)

- api : scale
  args : (Tensor x, Scalar scale, float bias, bool bias_after_scale)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : scale, scale_sr
  inplace : (x -> out)

- api : sign
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sign

- api : softmax
  args : (Tensor x, int axis)
  output : Tensor
  infer_meta :
    func : SoftmaxInferMeta
  kernel :
    func : sotfmax

- api : split
  args : (Tensor x, ScalarArray num_or_sections, Scalar axis)
  output : Tensor[]
  invoke : split_impl(x, num_or_sections, axis)

- api : subtract
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : subtract

- api : sum
  args : (Tensor x, int64[] axis={}, DataType dtype=DataType::UNDEFINED, bool keep_dim=false)
  output : Tensor
  infer_meta :
    func : SumInferMeta
  kernel :
    func : sum
    data_type : x

- api : zeros_like
  args : (Tensor x, DataType dtype=DataType::UNDEFINED, Backend place=Backend::UNDEFINED)
  output : Tensor
  invoke : full_like(x, 0, dtype, place)


- api : one_hot
  args : (Tensor x, Scalar num_classes)
  output : Tensor
  infer_meta :
    func : OneHotInferMeta
  kernel :
    func : one_hot
    
- api : digamma
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : digamma
  backward : digamma_grad

- api : abs
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : abs
  backward : abs_grad

- api : trunc
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : trunc
  backward : trunc_grad

# - api : norm
#   args : (Tensor x, int axis, float epsilon, bool is_test)
#   output : Tensor(out), Tensor(norm)
#   infer_meta :
#     func : NormInferMeta
#   kernel :
#     func : norm
#   intermediate : norm
#   backward : norm_grad

- api : diagonal
  args : (Tensor x, int offset, int axis1, int axis2)
  output : Tensor
  infer_meta :
    func : DiagonalInferMeta
  kernel :
    func : diagonal
  backward : diagonal_grad



# softmax
- api : softmax
  args : (Tensor x, int axis)
  output : Tensor
  infer_meta :
    func : SoftmaxInferMeta
  kernel :
    func : softmax
  backward : softmax_grad

# # maxout
# - api : maxout
#   args : (Tensor x, int groups, int axis)
#   output : Tensor
#   infer_meta :
#     func : MaxoutInferMeta
#   kernel :
#     func : maxout
#   backward : maxout_grad

# put_along_axis
- api : put_along_axis
  args : (Tensor x, Tensor index, Tensor value, int axis, str reduce)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [index]
  kernel :
    func : put_along_axis
  backward : put_along_axis_grad


# take_along_axis
- api : take_along_axis
  args : (Tensor x, Tensor index, int axis)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [index]
  kernel :
    func : take_along_axis
  backward : take_along_axis_grad

# matrix_power
- api : matrix_power
  args : (Tensor x, int n)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : matrix_power
  backward : matrix_power_grad

# eigh
- api : eigh
  args : (Tensor x, str uplo)
  output : Tensor(out_w), Tensor(out_v)
  infer_meta :
    func : EighInferMeta
  kernel :
    func : eigh
  backward : eigh_grad

# segment_pool
- api : segment_pool
  args : (Tensor x, Tensor segment_ids, str pooltype)
  output : Tensor(out), Tensor(summed_ids)
  infer_meta :
    func : SegmentPoolInferMeta
  kernel :
    func : segment_pool
  backward : segment_pool_grad

# accuracy
- api : accuracy
  args : (Tensor x, Tensor indices, Tensor label)
  output : Tensor(accuracy), Tensor(correct), Tensor(total)
  infer_meta :
    func : AccuracyInferMeta
  kernel :
    func : accuracy

# sin
- api : sin
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sin
  backward : sin_grad

# cos
- api : cos
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : cos
  backward : cos_grad


# tanh
- api : tanh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tanh
  backward : tanh_grad

# acos
- api : acos
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : acos
  backward : acos_grad


# asin
- api : asin
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : asin
  backward : asin_grad


# atan
- api : atan
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : atan
  backward : atan_grad

# sinh
- api : sinh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sinh
  backward : sinh_grad

# cosh
- api : cosh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : cosh
  backward : cosh_grad

# asinh
- api : asinh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : asinh
  backward : asinh_grad

# acosh
- api : acosh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : acosh
  backward : acosh_grad

# atanh
- api : atanh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : atanh
  backward : atanh_grad

# relu
- api : relu
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : relu
  backward : relu_grad


# arg_min  # int64 ???? dtype
- api : arg_min
  args : (Tensor x, int64 axis, bool keepdims, bool flatten, int dtype)
  output : Tensor
  infer_meta :
    func : ArgMinMaxInferMeta
  kernel :
    func : arg_min

# arg_max  # int64 ???? dtype
- api : arg_max
  args : (Tensor x, int64 axis, bool keepdims, bool flatten, int dtype)
  output : Tensor
  infer_meta :
    func : ArgMinMaxInferMeta
  kernel :
    func : arg_max

# argsort
- api : argsort
  args : (Tensor x, int axis, bool descending)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : ArgsortInferMeta 
  kernel :
    func : argsort
  backward : argsort_grad

# auc
- api : auc
  args : (Tensor x, Tensor label, Tensor stat_pos, Tensor stat_neg, str curve, int num_thresholds, int slide_steps)
  output : Tensor(auc), Tensor(stat_pos_out), Tensor(stat_neg_out)
  infer_meta :
    func : AucInferMeta
  kernel :
    func : auc

# # batch_norm
# - api : batch_norm
#   args : (Tensor x, Tensor scale, Tensor bias, Tensor mean, Tensor variance, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics, bool fuse_with_relu)
#   output : Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean), Tensor(saved_variance), Tensor(reserve_space)
#   infer_meta :
#     func : XXXXInferMeta
#   kernel :
#     func : batch_norm
#   backward: batch_norm_grad

# bernoulli
- api : bernoulli
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : bernoulli

# # bilinear_tensor_product ?? optional
# - api : bilinear_tensor_product
#   args : (Tensor x, Tensor y, Tensor weight, Tensor bias)
#   output : Tensor
#   infer_meta :
#     func : BilinearTensorProductInferMeta
#   kernel :
#     func : bilinear_tensor_product
#   backward : bilinear_tensor_product_grad
#   optional : bias

# bincount
- api : bincount
  args : (Tensor x, Tensor weight, int minlength)
  output : Tensor
  infer_meta :
    func : BincountInferMeta
  kernel :
    func : bincount
  optional : weight



# bitwise_and
# - api : bitwise_and
#   args : (Tensor x, Tensor y)
#   output : Tensor
#   infer_meta :
#     func : BitwiseInferMeta
#   kernel :
#     func : bitwise_and

# # bitwise_or
# - api : bitwise_or
#   args : (Tensor x, Tensor y)
#   output : Tensor
#   infer_meta :
#     func : BitwiseInferMeta
#   kernel :
#     func : bitwise_or


# # bitwise_xor
# - api : bitwise_xor
#   args : (Tensor x, Tensor y)
#   output : Tensor
#   infer_meta :
#     func : BitwiseInferMeta
#   kernel :
#     func : bitwise_xor

# bitwise_not
- api : bitwise_not
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : bitwise_not

# broadcast_tensors
# - api : broadcast_tensors
#   args : (Tensor[] x)
#   output : Tensor[]
#   infer_meta :
#     func : BroadcastTensorsInferMeta
#   kernel :
#     func : broadcast_tensors
#   backward : broadcast_tensors_grad

# cholesky
- api : cholesky
  args : (Tensor x, bool upper)
  output : Tensor
  infer_meta :
    func : CholeskyInferMeta
  kernel :
    func : cholesky
  backward : cholesky_grad
  
# cholesky_solve
- api : cholesky_solve
  args : (Tensor x, Tensor y, bool upper)
  output : Tensor
  infer_meta :
    func : CholeskySolveInferMeta
  kernel :
    func : cholesky_solve
  backward : cholesky_solve_grad

# # conv2d
# # copy


# cumsum
- api : cumsum
  args : (Tensor x, int axis, bool flatten, bool exclusive, bool reverse)
  output : Tensor
  infer_meta :
    func : CumsumInferMeta
  kernel :
    func : cumsum

# # depthwise_conv2d
# # dropout ?? optional, intermediate
# - api : dropout
#   args : (Tensor x, Tensor seed_tensor, float p, bool is_test, str mode, int seed, bool fix_seed)
#   output : Tensor(out), Tensor(mask)
#   infer_meta :
#     func : DropoutInferMeta
#   kernel :
#     func : dropout

# # embedding

# erf
- api : erf
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : erf
  backward : erf_grad

# erfinv
- api : erfinv
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : erfinv
  backward : erfinv_grad

# expand_as
# - api : expand_as
#   args : (Tensor x, Tensor y, int[] shape)
#   output : Tensor
#   infer_meta :
#     func : ExpandAsInferMeta
#   kernel :
#     func : expand_as
#   backward : expand_as_grad
#   optional : y


# # expand
# - api : expand
#   args : (Tensor x, ScalarArray shape)
#   output : Tensor
#   infer_meta :
#     func : ExpandInferMeta
#   kernel :
#     func : expand
#   backward : expand_grad

# eye
# - api : eye
#   args : (int64 num_rows, int64 num_colums, DataType dtype = DataType::FLOAT32)
#   output : Tensor
#   infer_meta :
#     func : EyeInferMeta
#   kernel :
#     func : eye

# # flip
# - api : flip
#   args : (Tensor x, int[] axis)
#   output : Tensor
#   infer_meta :
#     func : FlipInferMeta
#   kernel :
#     func : flip

# gaussian_random
# - api : gaussian_random
#   args : (ScalarArray shape, float mean, float std, int seed, DataType dtype=DataType::FLOAT32)
#   output : Tensor
#   infer_meta :
#     func : CreateInferMeta
#     param : [shape, dtype]
#   kernel :
#     func : gaussian_random
#     data_type : dtype

# # graph_send_recv
# - api : graph_send_recv
#   args : (Tensor x, Tensor src_index, Tensor dst_index, str pool_type)
#   output : Tensor(out), Tensor(dst_count)
#   infer_meta :
#     func : GraphSendRecvInferMeta
#   kernel :
#     func : graph_send_recv
#   backward : graph_send_recv_grad

# # histogram int64 ???
# - api : histogram
#   args : (Tensor x, int64 bins, int min, int max)
#   output : Tensor
#   infer_meta :
#     func : HistogramInferMeta
#   kernel :
#     func : histogram

# increment
- api : increment
  args : (Tensor x, float value)
  output : Tensor
  infer_meta :
    func : IncrementInferMeta
  kernel :
    func : increment

# is_empty
- api : is_empty
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : IsEmptyInferMeta
  kernel :
    func : is_empty

# # isinf selected rows??? involk
# - api : isinf
#   args : (Tensor x)
#   output : Tensor
#   infer_meta :
#     func : IsfiniteInferMeta
#   kernel :
#     func : isinf

# # isnan selected rows??? involk
# - api : isnan
#   args : (Tensor x)
#   output : Tensor
#   infer_meta :
#     func : IsfiniteInferMeta
#   kernel :
#     func : isnan

# # isfinite selected rows??? involk
# - api : isfinite
#   args : (Tensor x)
#   output : Tensor
#   infer_meta :
#     func : IsfiniteInferMeta
#   kernel :
#     func : isfinite

# label_smooth  ?? optional
# - api : label_smooth
#   args : (Tensor label, Tensor prior_dist, float epsilon)
#   output : Tensor
#   infer_meta :
#     func : UnchangedInferMeta
#     param : [label]
#   kernel :
#     func : label_smooth
#   backward : label_smooth_grad
#   optional : prior_dist

# linspace ???? start stop number，应该是sclar？
# - api : linspace
#   args : (Tensor start, Tensor stop, Tensor number, DataType dtype=DataType::FLOAT32)
#   output : Tensor
#   infer_meta :
#     func : LinspaceInferMeta
#   kernel :
#     func : linspace


# log_loss
- api : log_loss
  args : (Tensor input, Tensor label, float epsilon)
  output : Tensor
  infer_meta :
    func : LogLossInferMeta
  kernel :
    func : log_loss
  backward : log_loss_grad

# # logical_and
# - api : logical_and
#   args : (Tensor x, Tensor y)
#   output : Tensor
#   infer_meta :
#     func : LogicalInferMeta
#   kernel :
#     func : logical_and

# # logical_or
# - api : logical_or
#   args : (Tensor x, Tensor y)
#   output : Tensor
#   infer_meta :
#     func : LogicalInferMeta
#   kernel :
#     func : logical_or


# # logical_xor
# - api : logical_xor
#   args : (Tensor x, Tensor y)
#   output : Tensor
#   infer_meta :
#     func : LogicalInferMeta
#   kernel :
#     func : logical_xor

# logical_not
- api : logical_not
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : logical_not

# # masked_select
# - api : masked_select
#   args : (Tensor x, Tensor mask)
#   output : Tensor
#   infer_meta :
#     func : MaksedSelectInferMeta
#   kernel :
#     func : masked_select
#   backward : masked_select_grad

# # multi_dot
# - api : multi_dot
#   args : (Tensor[] x)
#   output : Tensor
#   infer_meta :
#     func : MultiDotInferMeta
#   kernel :
#     func : multi_dot
#   backward : multi_dot_grad

# multinomial
- api : multinomial
  args : (Tensor x, int num_samples, bool replacement)
  output : Tensor
  infer_meta :
    func : MultinomialInferMeta
  kernel :
    func : multinomial

# nll_loss  ?? optional
# - api : nll_loss
#   args : (Tensor x, Tensor label, Tensor weight, int64 ignore_index, str reduction)
#   output : Tensor(out), Tensor(total_weight)
#   infer_meta :
#     func : NllLossRawInferMeta
#   kernel :
#     func : nll_loss
#   backward : nll_loss_grad
#   optional : weight

# # pad
# - api : pad
#   args : (Tensor x, int[] paddings, float pad_value)
#   output : Tensor
#   infer_meta :
#     func : PadInferMeta
#   kernel :
#     func : pad
#   backward : pad_grad

# # pixel_shuffle
# - api : pixel_shuffle
#   args : (Tensor x, int upscale_factor, str data_format)
#   output : Tensor
#   infer_meta :
#     func : PixelShuffleInferMeta
#   kernel :
#     func : pixel_shuffle
#   backward : pixel_shuffle_grad

# # poisson
# - api : poisson
#   args : (Tensor x)
#   output : Tensor
#   infer_meta :
#     func : PoissonInferMeta
#   kernel :
#     func : poisson
#   backward : poisson_grad

# psroi_pool  ?? optional
# - api : psroi_pool
#   args : (Tensor x, Tensor rois, Tensor rois_num, int pooled_weight, int pooled_width, int output_channels, float spatial_scale )
#   output : Tensor
#   infer_meta :
#     func : PsroiPoolInferMeta
#   kernel :
#     func : psroi_pool
#   backward : psroi_pool_grad
#   optional : rois_num

# # randint_raw
# - api : randint
#   args : (int low, int high, ScalarArray shape, DataType dtype)
#   output : Tensor
#   infer_meta :
#     func : RandintInferMeta
#   kernel :
#     func : randint

# # randperm_raw
# - api : randperm
#   args : (int n, DataType dtype)
#   output : Tensor
#   infer_meta :
#     func : RandpermInferMeta
#   kernel :
#     func : randperm

# # max
# - api : max
#   args : (Tensor x, int64_t[] dims, bool keep_dim)
#   output : Tensor
#   infer_meta :
#     func : MaxInferMeta
#   kernel :
#     func : max

# # reduce_prod
# - api : reduce_prod
#   args : (Tensor x, int64_t[] dims, bool keep_dim, bool reduce_all)
#   output : Tensor
#   infer_meta :
#     func : ReduceProdInferMeta
#   kernel :
#     func : reduce_prod

# selu
- api : selu
  args : (Tensor x, float scale, float alpha)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : selu
  backward : selu_grad

# # set_value None api

# # sgd # need invoke
# # shape ??? selcted rows

# shard_index
- api : shard_index
  args : (Tensor in, int index_num, int nshards, int shard_id, int ignore_value)
  output : Tensor
  infer_meta :
    func : ShardIndexInferMeta
  kernel :
    func : shard_index

# sigmoid_cross_entropy_with_logits
- api : sigmoid_cross_entropy_with_logits
  args : (Tensor x, Tensor label, bool normalize, int ignore_index)
  output : Tensor
  infer_meta :
    func : SigmoidCrossEntropyWithLogitsInferMeta
  kernel :
    func : sigmoid_cross_entropy_with_logits
  backward : sigmoid_cross_entropy_with_logits_grad

# size
- api : size
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : SizeInferMeta
  kernel :
    func : size

# tile
- api : tile
  args : (Tensor x, ScalarArray repeat_times)
  output : Tensor
  infer_meta :
    func : TileInferMeta
  kernel :
    func : tile
  backward : tile_grad

# # top_k
# - api : top_k
#   args : (Tensor x, Scalar k, int axis, bool largest, bool sorted)
#   output : Tensor(out), Tensor(indices)
#   infer_meta :
#     func : TopkInferMeta
#   kernel :
#     func : top_k
#   backward : top_k_grad

# trace
- api : trace
  args : (Tensor x, int offset, int axis1, int axis2)
  output : Tensor
  infer_meta :
    func : TraceInferMeta
  kernel :
    func : trace
  backward : trace_grad

# # phi_transfer_layout | not have python api

# # truncated_gaussian_random
# - api : truncated_gaussian_random
#   args : (int[] shape, float mean, float std, int seed, DataType dtype)
#   output : Tensor
#   infer_meta :
#     func : TruncatedGaussianRandomInferMeta
#   kernel :
#     func : truncated_gaussian_random

# # unbind
# - api : unbind
#   args : (Tensor x, int axis)
#   output : Tensor[]
#   infer_meta :
#     func : UnbindInferMeta
#   kernel :
#     func : unbind

# unfold
- api : unfold
  args : (Tensor x, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations)
  output : Tensor
  infer_meta :
    func : UnfoldInferMeta
  kernel :
    func : unfold
  backward : unfold_grad

# # uniform_random_raw selected rows ??

# viterbi_decode
# - api : viterbi_decode
#   args : (Tensor input, Tensor transition, Tensor length, bool include_bos_eos_tag)
#   output : Tensor(scores), Tensor(path)
#   infer_meta :
#     func : ViterbiDecodeInferMeta
#   kernel :
#     func : viterbi_decode

# where_index
- api : where_index
  args : (Tensor condition)
  output : Tensor
  infer_meta :
    func : WhereIndexInferMeta
  kernel :
    func : where_index


# # yolo_box
# - api : yolo_box
#   args : (Tensor x, Tensor img_size, int[] anchors, int class_num, float conf_thresh, int downsample_ratio, bool clip_bbox, float scale_x_y, bool iou_aware, float iou_aware_factor)
#   output : Tensor(boxes), Tensor(scores)
#   infer_meta :
#     func : YoloBoxInferMeta
#   kernel :
#     func : yolo_box

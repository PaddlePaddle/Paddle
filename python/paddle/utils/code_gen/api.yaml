- api : abs
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : abs
  backward : abs_grad

# accuracy
- api : accuracy
  args : (Tensor x, Tensor indices, Tensor label)
  output : Tensor(accuracy), Tensor(correct), Tensor(total)
  infer_meta :
    func : AccuracyInferMeta
  kernel :
    func : accuracy
    dtype : x

# acos
- api : acos
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : acos
  backward : acos_grad

# acosh
- api : acosh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : acosh
  backward : acosh_grad

- api : adadelta
  args : (Tensor param, Tensor grad, Tensor avg_squared_grad, Tensor avg_squared_update, float rho, float epsilon)
  output : Tensor(param_out), Tensor(moment_out), Tensor(inf_norm_out)
  infer_meta :
    func : AdadeltaInferMeta
  kernel :
    func : adadelta

- api : adam
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment1, Tensor moment2, Tensor beta1_pow, Tensor beta2_pow, Tensor master_param, Tensor skip_update, Scalar beta1, Scalar beta2, Scalar epsilon, bool lazy_mode, int64_t min_row_size_to_use_multithread, bool multi_precision, bool use_global_beta_pow)
  output : Tensor(param_out), Tensor(moment1_out), Tensor(moment2_out), Tensor(beta1_pow_out), Tensor(beta2_pow_out), Tensor(master_param_outs)
  optional : master_param, skip_update
  invoke : adam_impl(param, grad, learning_rate, moment1, moment2, beta1_pow, beta2_pow, master_param, skip_update, beta1, beta2, epsilon, lazy_mode, min_row_size_to_use_multithread, multi_precision, use_global_beta_pow)

- api : adamax
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment, Tensor inf_norm, Tensor beta1_pow, float beta1, float beta2, float epsilon)
  output : Tensor(param_out), Tensor(avg_squared_grad_out), Tensor(avg_squared_update_out)
  infer_meta :
    func : AdamaxInferMeta
  kernel :
    func : adamax

- api : adamw
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment1, Tensor moment2, Tensor beta1_pow, Tensor beta2_pow, Tensor master_param, Tensor skip_update, Scalar beta1, Scalar beta2, Scalar epsilon, float lr_ratio, float coeff, bool with_decay, bool lazy_mode, int64_t min_row_size_to_use_multithread, bool multi_precision, bool use_global_beta_pow)
  output : Tensor(param_out), Tensor(moment1_out), Tensor(moment2_out), Tensor(beta1_pow_out), Tensor(beta2_pow_out), Tensor(master_param_outs)
  optional : master_param, skip_update
  invoke : adamw_impl(param, grad, learning_rate, moment1, moment2, beta1_pow, beta2_pow, master_param, skip_update, beta1, beta2, epsilon, lr_ratio, coeff, with_decay, lazy_mode, min_row_size_to_use_multithread, multi_precision, use_global_beta_pow)

- api : add
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : add
  backward : add_grad

- api : add_n
  args : (Tensor[] x)
  output : Tensor
  infer_meta :
    func : AddNInferMeta
  kernel :
    func : add_n
  backward : add_n_grad

- api : addmm
  args : (Tensor input, Tensor x, Tensor y, float alpha, float beta)
  output : Tensor
  infer_meta :
    func : AddmmInferMeta
  kernel :
    func : addmm
  backward : addmm_grad

- api : all
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : all

- api : allclose
  args : (Tensor x, Tensor y, Scalar rtol, Scalar atol, bool equal_nan)
  output : Tensor(out)
  infer_meta :
    func : AllValueCompareInferMeta
    param: [x, y]
  kernel :
    func : allclose

- api : any
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : any

- api : arange
  args : (Tensor start, Tensor end, Tensor step, DataType dtype, Place place={})
  output : Tensor
  infer_meta :
    func : ArangeInferMeta
    param : [start, end, step]
  kernel :
    func : arange
    param : [start, end, step]
    data_type : dtype
    backend : place
  data_transform :
    support_trans_dtype : start, end, step

# arg_max
- api : argmax
  args : (Tensor x, int64_t axis, bool keepdims, bool flatten, int dtype)
  output : Tensor
  infer_meta :
    func : ArgMinMaxInferMeta
  kernel :
    func : arg_max

# arg_min
- api : argmin
  args : (Tensor x, int64_t axis, bool keepdims, bool flatten, int dtype)
  output : Tensor
  infer_meta :
    func : ArgMinMaxInferMeta
  kernel :
    func : arg_min

# argsort
- api : argsort
  args : (Tensor x, int axis, bool descending)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : ArgsortInferMeta
  kernel :
    func : argsort
  backward : argsort_grad

# asin
- api : asin
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : asin
  backward : asin_grad

# asinh
- api : asinh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : asinh
  backward : asinh_grad

# assign
- api : assign
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : assign
  backward : assign_grad

# atan
- api : atan
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : atan
  backward : atan_grad

- api : atan2
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : Atan2InferMeta
  kernel :
    func : atan2
  backward : atan2_grad

# atanh
- api : atanh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : atanh
  backward : atanh_grad

# auc
- api : auc
  args : (Tensor x, Tensor label, Tensor stat_pos, Tensor stat_neg, str curve, int num_thresholds, int slide_steps)
  output : Tensor(auc), Tensor(stat_pos_out), Tensor(stat_neg_out)
  infer_meta :
    func : AucInferMeta
  kernel :
    func : auc

# batch_norm
- api : batch_norm
  args : (Tensor x, Tensor scale, Tensor bias, Tensor mean, Tensor variance, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics, bool fuse_with_relu)
  output : Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean), Tensor(saved_variance), Tensor(reserve_space)
  invoke : batch_norm_impl(x, scale, bias, mean, variance, momentum, epsilon, data_layout, is_test, use_global_stats, trainable_statistics, fuse_with_relu)
  backward : batch_norm_grad

- api : bce_loss
  args : (Tensor input, Tensor label)
  output : Tensor
  infer_meta :
    func : BCELossInferMeta
  kernel :
    func : bce_loss
  backward : bce_loss_grad

# bernoulli
- api : bernoulli
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : bernoulli

# bitwise_and
- api : bitwise_and
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : bitwise_and

# bitwise_not
- api : bitwise_not
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : bitwise_not

# bitwise_or
- api : bitwise_or
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : bitwise_or

# bitwise_xor
- api : bitwise_xor
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : bitwise_xor

# brelu
- api : brelu
  args : (Tensor x, float t_min, float t_max)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : brelu
  backward : brelu_grad

- api : cast
  args : (Tensor x, DataType out_dtype)
  output : Tensor
  infer_meta :
    func : CastInferMeta
  kernel :
    func : cast
    param : [x, out_dtype]
    data_type : x
  backward : cast_grad

- api : ceil
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : ceil
  backward : ceil_grad

# cholesky
- api : cholesky
  args : (Tensor x, bool upper)
  output : Tensor
  infer_meta :
    func : CholeskyInferMeta
  kernel :
    func : cholesky
  backward : cholesky_grad

# cholesky_solve
- api : cholesky_solve
  args : (Tensor x, Tensor y, bool upper)
  output : Tensor
  infer_meta :
    func : CholeskySolveInferMeta
  kernel :
    func : cholesky_solve
  backward : cholesky_solve_grad

- api : clip
  args : (Tensor x, Scalar(float) min, Scalar(float) max)
  output : Tensor(out)
  inplace : (x -> out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : clip
  backward : clip_grad

- api : concat
  args : (Tensor[] x, Scalar(int64_t) axis)
  output : Tensor
  infer_meta :
    func : ConcatInferMeta
    param : [x, axis]
  kernel :
    func : concat
  backward : concat_grad

- api : conj
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : conj
  backward : conj_grad

- api : conv2d
  args : (Tensor input, Tensor filter, int[] strides, int[] paddings, str paddding_algorithm, int groups, int[] dilations, str data_format, bool use_addto, int workspace_size_MB, bool exhaustive_search)
  output : Tensor
  invoke : conv2d_impl(input, filter, strides, paddings, paddding_algorithm, groups, dilations, data_format, use_addto, workspace_size_MB, exhaustive_search)
  backward : conv2d_grad

- api : conv2d_transpose
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, int[] output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(out)
  infer_meta :
    func : ConvTransposeInferMeta
  kernel :
    func : conv2d_transpose
    use_gpudnn : true
  backward : conv2d_transpose_grad

- api : conv3d_transpose
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, int[] output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(out)
  infer_meta :
    func : ConvTransposeInferMeta
  kernel :
    func : conv3d_transpose
    use_gpudnn : true
  backward : conv3d_transpose_grad

- api : copy_to
  args : (Tensor x, Place place, bool blocking)
  output : Tensor
  invoke : copy_to_impl(x, place, blocking)

# cos
- api : cos
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : cos
  backward : cos_grad

# cosh
- api : cosh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : cosh
  backward : cosh_grad

- api : cross
  args : (Tensor x, Tensor y, int axis = 9)
  output : Tensor
  infer_meta :
    func : CrossInferMeta
  kernel :
    func : cross
  backward : cross_grad

# Part of python API paddle.nn.functional.cross_entropy
- api : cross_entropy_with_softmax
  args : (Tensor input, Tensor label, bool soft_label, bool use_softmax, bool numeric_stable_mode, int ignore_index, int axis)
  output : Tensor(softmax), Tensor(loss)
  infer_meta :
    func : CrossEntropyWithSoftmaxInferMeta
  kernel :
    func : cross_entropy_with_softmax
    data_type : input
  backward : cross_entropy_with_softmax_grad

- api : cumprod
  args : (Tensor x,  int dim)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : cumprod
  backward : cumprod_grad

- api : cumsum
  args : (Tensor x, int axis, bool flatten, bool exclusive, bool reverse)
  output : Tensor(out)
  infer_meta :
    func : CumsumInferMeta
  kernel :
    func : cumsum
  backward : cumsum_grad

- api : deformable_conv
  args : (Tensor x, Tensor offset, Tensor filter, Tensor mask, int[] strides, int[] paddings, int[] dilations, int deformable_groups, int groups, int im2col_step)
  output : Tensor(out)
  infer_meta :
    func : DeformableConvInferMeta
  kernel :
    func : deformable_conv
  optional : mask
  backward : deformable_conv_grad

- api : depthwise_conv2d_transpose
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, int[] output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(out)
  infer_meta :
    func : ConvTransposeInferMeta
  kernel :
    func : depthwise_conv2d_transpose
  backward : depthwise_conv2d_transpose_grad

- api : det
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : determinant
  backward : det_grad

- api : diag
  args : (Tensor x, int offset, float padding_value)
  output : Tensor
  infer_meta :
    func : DiagInferMeta
  kernel :
    func : diag

- api : diagonal
  args : (Tensor x, int offset, int axis1, int axis2)
  output : Tensor
  infer_meta :
    func : DiagonalInferMeta
  kernel :
    func : diagonal
  backward : diagonal_grad

- api : digamma
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : digamma
  backward : digamma_grad

- api : dist
  args : (Tensor x, Tensor y, float p)
  output : Tensor
  infer_meta :
    func : DistInferMeta
  kernel :
    func : dist
  backward : dist_grad

- api : divide
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : divide
  backward : divide_grad

- api : dot
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : DotInferMeta
  kernel :
    func : dot

- api : dropout
  args : (Tensor x, Tensor seed_tensor, float p, bool is_test, str mode, int seed, bool fix_seed)
  output : Tensor(out), Tensor(mask)
  infer_meta :
    func : DropoutInferMeta
  kernel :
    func : dropout
  optional : seed_tensor
  backward : dropout_grad

# eigh
- api : eigh
  args : (Tensor x, str uplo)
  output : Tensor(out_w), Tensor(out_v)
  infer_meta :
    func : EighInferMeta
  kernel :
    func : eigh
  backward : eigh_grad

- api : elementwise_pow
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : elementwise_pow
  backward : elementwise_pow_grad

# elu
- api : elu
  args : (Tensor x, float alpha)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : elu
  backward : elu_grad

- api : empty
  args : (IntArray shape, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output: Tensor
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : empty
    param : [shape, dtype]
    data_type : dtype
    backend : place

- api : empty_like
  args : (Tensor x, DataType dtype = DataType::UNDEFINED, Place place = {})
  output: Tensor
  infer_meta :
    func : CreateLikeInferMeta
    param : [x, dtype]
  kernel :
    func : empty_like
    param : [x, dtype]
    data_type : dtype > x
    backend : place > x

- api : equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : equal

- api : equal_all
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : CompareAllInferMeta
  kernel :
    func : equal_all

# erf
- api : erf
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : erf
  backward : erf_grad

# erfinv
- api : erfinv
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : erfinv
  backward : erfinv_grad

# exp
- api : exp
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : exp
  backward : exp_grad

# expand
- api : expand
  args : (Tensor x, IntArray shape)
  output : Tensor
  infer_meta :
    func : ExpandInferMeta
  kernel :
    func : expand
  backward : expand_grad

# expand_as
- api : expand_as
  args : (Tensor x, Tensor y, int[] target_shape)
  output : Tensor
  infer_meta :
    func : ExpandAsInferMeta
  kernel :
    func : expand_as
  optional : y
  backward : expand_as_grad

- api : expm1
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : expm1
  backward : expm1_grad

- api : eye
  args : (int64_t num_rows, int64_t num_columns, DataType dtype=DataType::FLOAT32, Place place={})
  output : Tensor(out)
  infer_meta :
    func : EyeInferMeta
    param : [num_rows, num_columns, dtype]
  kernel :
    func : eye
    param : [num_rows, num_columns, dtype]
    data_type : dtype
    backend : place

- api : flatten
  args : (Tensor x, int start_axis, int stop_axis)
  output : Tensor(out), Tensor(xshape)
  infer_meta :
    func : FlattenWithXShapeInferMeta
  kernel :
    func : flatten_with_xshape
    backend : x
  inplace : (x -> out)
  view : (x -> out)
  backward : flatten_grad

# flip
- api : flip
  args : (Tensor x, int[] axis)
  output : Tensor
  infer_meta :
    func : FlipInferMeta
  kernel :
    func : flip
  backward : flip_grad

- api : floor
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : floor
  backward : floor_grad

- api : floor_divide
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : floor_divide

- api : fmax
  args : (Tensor x, Tensor y,  int axis)
  output : Tensor(out)
  infer_meta :
    param: [x, y]
    func : ElementwiseInferMeta
  kernel :
    func : fmax
  backward : fmax_grad

- api : fmin
  args : (Tensor x, Tensor y,  int axis)
  output : Tensor(out)
  infer_meta :
    param: [x, y]
    func : ElementwiseInferMeta
  kernel :
    func : fmin
  backward : fmin_grad

- api : frobenius_norm
  args : (Tensor x, int64_t[] axis,  bool keep_dim,  bool reduce_all)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMetaBase
  kernel :
    func : frobenius_norm
  backward : frobenius_norm_grad

- api : full
  args : (IntArray shape, Scalar value, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output: Tensor
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : full
    param : [shape, value, dtype]
    data_type : dtype
    backend : place

- api : full_batch_size_like
  args : (Tensor input, int[] shape, DataType dtype, Scalar value, int input_dim_idx, int output_dim_idx, Place place=CPUPlace())
  output: Tensor
  infer_meta :
    func : FullBatchSizeLikeInferMeta
    param : [input, shape, value, dtype, input_dim_idx, output_dim_idx]
  kernel :
    func : full_batch_size_like
    param : [input, shape, value, dtype, input_dim_idx, output_dim_idx]
    data_type : dtype
    backend : place

- api : full_like
  args : (Tensor x, Scalar value, DataType dtype = DataType::UNDEFINED, Place place = {})
  output: Tensor
  infer_meta :
    func : CreateLikeInferMeta
    param : [x, dtype]
  kernel :
    func : full_like
    param : [x, value, dtype]
    data_type : dtype > x
    backend : place > x
  data_transform :
    skip_transform : x

- api : gather
  args : (Tensor x, Tensor index, Scalar axis=0)
  output : Tensor(out)
  infer_meta :
    func : GatherInferMeta
  kernel :
    func : gather
    data_type: x
  backward : gather_grad

- api : gather_nd
  args : (Tensor x, Tensor index)
  output : Tensor
  infer_meta :
    func : GatherNdInferMeta
  kernel :
    func : gather_nd
    data_type : x
  backward : gather_nd_grad

- api : gather_tree
  args : (Tensor ids, Tensor parents)
  output : Tensor
  infer_meta :
    func : GatherTreeMeta
  kernel :
    func : gather_tree

- api : gaussian_random
  args : (IntArray shape, float mean, float std, int seed, DataType dtype, Place place={})
  output: Tensor
  infer_meta :
    func : GaussianRandomInferMeta
    param : [shape, mean, std, seed, dtype]
  kernel :
    func : gaussian_random
    param : [shape, mean, std, seed, dtype]
    data_type : dtype
    backend : place

- api : gelu
  args : (Tensor x,  bool approximate)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : gelu
  backward : gelu_grad

- api : graph_send_recv
  args : (Tensor x, Tensor src_index, Tensor dst_index, str pool_type = "SUM", int64_t out_size = 0)
  output : Tensor(out), Tensor(dst_count)
  infer_meta :
    func : GraphSendRecvInferMeta
  kernel :
    func : graph_send_recv
    data_type : x
  intermediate : dst_count
  backward : graph_send_recv_grad

- api : greater_equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : greater_equal

- api : greater_than
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : greater_than

- api : gumbel_softmax
  args : (Tensor x, float temperature, bool hard, int axis)
  output : Tensor
  infer_meta :
    func : GumbelSoftmaxInferMeta
  kernel :
    func : gumbel_softmax
  backward : gumbel_softmax_grad

# hard_shrink
- api : hard_shrink
  args : (Tensor x, float threshold)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_shrink
  backward : hard_shrink_grad

# hard_sigmoid
- api : hard_sigmoid
  args : (Tensor x, float slope, float offset)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_sigmoid
  backward : hard_sigmoid_grad

- api : hard_swish
  args : (Tensor x, float threshold = 6.0, float scale = 6.0, float offset = 3.0)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_swish
  backward : hard_swish_grad

# histogram
- api : histogram
  args : (Tensor x, int64_t bins, int min, int max)
  output : Tensor
  infer_meta :
    func : HistogramInferMeta
  kernel :
    func : histogram

- api : huber_loss
  args : (Tensor input, Tensor label, float delta)
  output : Tensor(out), Tensor(residual)
  infer_meta :
    func : HuberLossInferMeta
  kernel :
    func : huber_loss
  backward : huber_loss_grad

- api : imag
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : imag
  backward : imag_grad

# increment
- api : increment
  args : (Tensor x, float value)
  output : Tensor
  infer_meta :
    func : IncrementInferMeta
  kernel :
    func : increment

- api : index_sample
  args : (Tensor x, Tensor index)
  output : Tensor
  infer_meta :
    func : IndexSampleInferMeta
  kernel :
    func : index_sample
    data_type : x
  backward : index_sample_grad

- api : index_select
  args : (Tensor x, Tensor index,  int dim)
  output : Tensor(out)
  infer_meta :
    func : IndexSelectInferMeta
  kernel :
    func : index_select
    data_type : x
  backward : index_select_grad

# is_empty
- api : is_empty
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : IsEmptyInferMeta
  kernel :
    func : is_empty

- api : isclose
  args : (Tensor x, Tensor y, Scalar rtol, Scalar atol,  bool equal_nan)
  output : Tensor(out)
  infer_meta :
    func : ValueCompareInferMeta
    param: [x, y]
  kernel :
    func : isclose

# isfinite
- api : isfinite
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : IsfiniteInferMeta
  kernel :
    func : isfinite, infinite_sr

# isinf
- api : isinf
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : IsfiniteInferMeta
  kernel :
    func : isinf, isinf_sr

# isnan
- api : isnan
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : IsfiniteInferMeta
  kernel :
    func : isnan, isnan_sr

- api : kldiv_loss
  args : (Tensor x, Tensor label, str reduction)
  output : Tensor(out)
  infer_meta :
    func : KLDivInferMeta
  kernel :
    func : kldiv_loss
    data_type : x
  backward : kldiv_loss_grad

- api : kron
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : KronInferMeta
  kernel :
    func : kron
  backward : kron_grad

- api : kthvalue
  args : (Tensor x, int k, int axis, bool keepdim)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : KthvalueInferMeta
  kernel :
    func : kthvalue
  backward : kthvalue_grad

# label_smooth
- api : label_smooth
  args : (Tensor label, Tensor prior_dist, float epsilon)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [label]
  kernel :
    func : label_smooth
    data_type : label
  optional : prior_dist
  backward : label_smooth_grad

- api : layer_norm
  args : (Tensor x, Tensor scale, Tensor bias, float epsilon, int begin_norm_axis, bool is_test)
  output : Tensor(out), Tensor(mean), Tensor(variance)
  infer_meta :
    func : LayerNormInferMeta
  kernel :
    func : layer_norm
  backward : layer_norm_grad
  optional : scale, bias

# leaky_relu
- api : leaky_relu
  args : (Tensor x, float alpha)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : leaky_relu
  backward : leaky_relu_grad

- api : lerp
  args : (Tensor x, Tensor y, Tensor weight)
  output : Tensor
  infer_meta :
    func : LerpInferMeta
  kernel :
    func : lerp
  backward : lerp_grad

- api : less_equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : less_equal

- api : less_than
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : less_than

- api : lgamma
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : lgamma
  backward : lgamma_grad

- api : linspace
  args : (Tensor start, Tensor stop, Tensor number, DataType dtype)
  output : Tensor
  infer_meta :
    func : LinspaceInferMeta
  kernel :
    func : linspace
    data_type : dtype

- api : log
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log
  backward: log_grad

- api : log10
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log10
  backward: log10_grad

- api : log1p
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log1p
  backward: log1p_grad

- api : log2
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log2
  backward: log2_grad

# log_loss
- api : log_loss
  args : (Tensor input, Tensor label, float epsilon)
  output : Tensor
  infer_meta :
    func : LogLossInferMeta
  kernel :
    func : log_loss
  backward : log_loss_grad

- api : log_softmax
  args : (Tensor x,  int axis)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMetaCheckAxis
  kernel :
    func : log_softmax
  backward : log_softmax_grad

# logical_and
- api : logical_and
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : logical_and

# logical_not
- api : logical_not
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : logical_not

# logical_or
- api : logical_or
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : logical_or

# logical_xor
- api : logical_xor
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : logical_xor

# logit
- api : logit
  args : (Tensor x, float eps = 1e-6f)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : logit
  backward : logit_grad

# logsigmoid
- api : logsigmoid
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : logsigmoid
  backward : logsigmoid_grad

- api : logsumexp
  args : (Tensor x, int64_t[] axis,  bool keepdim,  bool reduce_all)
  output : Tensor(out)
  infer_meta :
    func : LogsumexpInferMeta
  kernel :
    func : logsumexp
  backward : logsumexp_grad

# masked_select
- api : masked_select
  args : (Tensor x, Tensor mask)
  output : Tensor
  infer_meta :
    func : MaskedSelectInferMeta
  kernel :
    func : masked_select
    data_type : x
  backward : masked_select_grad

- api : matmul
  args : (Tensor x, Tensor y, bool transpose_x = false, bool transpose_y = false)
  output : Tensor
  infer_meta :
    func : MatmulInferMeta
  kernel :
    func : matmul
  backward : matmul_grad

# matrix_power
- api : matrix_power
  args : (Tensor x, int n)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : matrix_power
  backward : matrix_power_grad

- api : matrix_rank
  args : (Tensor x, float tol, bool use_default_tol=true, bool hermitian=false)
  output : Tensor(out)
  infer_meta :
    func : MatrixRankInferMeta
    param : [x, use_default_tol, hermitian]
  kernel :
    func : matrix_rank

- api : matrix_rank_tol
  args : (Tensor x, Tensor atol_tensor, bool use_default_tol=true, bool hermitian=false)
  output : Tensor(out)
  infer_meta :
    func : MatrixRankTolInferMeta
  kernel :
    func : matrix_rank_tol

- api : max
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : max
  backward : max_grad

- api : max_pool2d_with_index
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive)
  output : Tensor(out), Tensor(mask)
  infer_meta :
    func : MaxPoolWithIndexInferMeta
  kernel :
    func : max_pool2d_with_index
  backward : max_pool2d_with_index_grad

- api : max_pool3d_with_index
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive)
  output : Tensor(out), Tensor(mask)
  infer_meta :
    func : MaxPoolWithIndexInferMeta
  kernel :
    func : max_pool3d_with_index
  backward : max_pool3d_with_index_grad

- api : maximum
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : maximum
  backward : maximum_grad

- api : maxout
  args : (Tensor x, int groups, int axis)
  output : Tensor(out)
  infer_meta :
    func : MaxOutInferMeta
  kernel :
    func : maxout
  backward : maxout_grad

- api : mean
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : mean
  backward : mean_grad

- api : mean_all
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : MeanAllInferMeta
  kernel :
    func : mean_all
  backward : mean_all_grad

- api : meshgrid
  args : (Tensor[] inputs)
  output : Tensor[]{inputs.size()}
  infer_meta :
    func : MeshgridInferMeta
  kernel :
    func : meshgrid
  backward : meshgrid_grad

- api : min
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : min
  backward : min_grad

- api : minimum
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : minimum
  backward : minimum_grad

- api : mish
  args : (Tensor x, float lambda)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : mish
  backward : mish_grad

- api : mode
  args : (Tensor x,  int axis,  bool keepdim)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : ModeInferMeta
  kernel :
    func : mode
  backward : mode_grad

- api : modulo
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : modulo
  backward : modulo_grad

- api : momentum
  args : (Tensor param, Tensor grad, Tensor velocity, Tensor learning_rate, Tensor master_param, float mu, bool use_nesterov = false, str regularization_method = "", float regularization_coeff = 0.0, bool multi_precision = false, float rescale_grad = 1.0f)
  output : Tensor(param_out), Tensor(velocity_out), Tensor(master_param_out)
  invoke : momentum_impl(param, grad, velocity, learning_rate, master_param, mu, use_nesterov, regularization_method, regularization_coeff, multi_precision, rescale_grad)
  optional : master_param

- api : multi_dot
  args : (Tensor[] x)
  output : Tensor
  infer_meta :
    func : MultiDotInferMeta
  kernel :
    func : multi_dot
  backward : multi_dot_grad

# multinomial
- api : multinomial
  args : (Tensor x, int num_samples, bool replacement)
  output : Tensor
  infer_meta :
    func : MultinomialInferMeta
  kernel :
    func : multinomial

- api : multiplex
  args : (Tensor[] ins, Tensor ids)
  output : Tensor
  infer_meta :
    func : MultiplexInferMeta
  kernel :
    func : multiplex
    data_type : ins
  backward : multiplex_grad

- api : multiply
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : multiply
  backward : multiply_grad

- api : mv
  args : (Tensor x, Tensor vec)
  output : Tensor
  infer_meta :
    func : MvInferMeta
  kernel :
    func : mv
  backward : mv_grad

- api : nll_loss
  args : (Tensor input, Tensor label, Tensor weight, int64_t ignore_index, str reduction)
  output : Tensor(out), Tensor(total_weight)
  infer_meta :
    func : NllLossRawInferMeta
  kernel :
    func : nll_loss
    data_type : input
  optional : weight
  backward : nll_loss_grad

- api : norm
  args : (Tensor x, int axis, float epsilon, bool is_test)
  output : Tensor(out), Tensor(norm)
  infer_meta :
    func : NormInferMeta
  kernel :
    func : norm
  intermediate : norm
  backward : norm_grad

- api : not_equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : not_equal

- api : one_hot
  args : (Tensor x, Scalar(int) num_classes)
  output : Tensor
  infer_meta :
    func : OneHotInferMeta
  kernel :
    func : one_hot

- api : ones_like
  args : (Tensor x, DataType dtype=DataType::UNDEFINED, Place place={})
  output : Tensor
  invoke : full_like(x, 1, dtype, place)

- api : p_norm
  args : (Tensor x,  float porder,  int axis,  float epsilon,  bool keepdim,  bool asvector=false)
  output : Tensor(out)
  infer_meta :
    func : PNormInferMeta
  kernel :
    func : p_norm
  backward : p_norm_grad

# pad
- api : pad
  args : (Tensor x, int[] paddings, float pad_value)
  output : Tensor
  infer_meta :
    func : PadInferMeta
  kernel :
    func : pad
  # backward : pad_grad

- api : pad3d
  args : (Tensor x, IntArray paddings, str mode,  float pad_value, str data_format)
  output : Tensor(out)
  infer_meta :
    func : Pad3dInferMeta
  kernel :
    func : pad3d
  backward : pad3d_grad

# pixel_shuffle
- api : pixel_shuffle
  args : (Tensor x, int upscale_factor, str data_format)
  output : Tensor
  infer_meta :
    func : PixelShuffleInferMeta
  kernel :
    func : pixel_shuffle
  backward : pixel_shuffle_grad

# poisson
- api : poisson
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : poisson
  backward : poisson_grad

- api : pool2d
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm)
  output : Tensor(out)
  infer_meta :
    func : PoolInferMeta
  kernel :
    func : pool2d
    use_gpudnn : true
  backward : pool2d_grad

# Used in adaptive_avg_pool2d API
- api : pool2d_gpudnn_unused
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm)
  output : Tensor(out)
  infer_meta :
    func : PoolInferMeta
  kernel :
    func : pool2d
    use_gpudnn : false
  backward : pool2d_grad_gpudnn_unused

- api : pool3d
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm)
  output : Tensor(out)
  infer_meta :
    func : PoolInferMeta
  kernel :
    func : pool3d
    use_gpudnn : true
  backward : pool3d_grad

- api : pow
  args : (Tensor x, Scalar s)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pow
  backward : pow_grad

- api : prelu
  args : (Tensor x, Tensor alpha, str data_format, str mode)
  output : Tensor(out)
  infer_meta :
    func : PReluInferMeta
  kernel :
    func : prelu
  backward : prelu_grad

- api : psroi_pool
  args : (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, int output_channels, float spatial_scale)
  output : Tensor
  infer_meta :
    func : PsroiPoolInferMeta
  kernel :
    func : psroi_pool
  optional : boxes_num
  backward : psroi_pool_grad

# put_along_axis
- api : put_along_axis
  args : (Tensor x, Tensor index, Tensor value, int axis, str reduce)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [index]
  kernel :
    func : put_along_axis
    data_type : x
  backward : put_along_axis_grad

- api : qr
  args : (Tensor x, str mode)
  output : Tensor(q), Tensor(r)
  infer_meta :
    func : QrInferMeta
  kernel :
    func : qr
  # backward : qr_grad

- api : randint
  args : (int low, int high, IntArray shape, DataType dtype=DataType::INT64, Place place={})
  output : Tensor(out)
  infer_meta :
    func : RandintInferMeta
    param : [low, high, shape, dtype]
  kernel :
    func : randint
    param : [low, high, shape, dtype]
    data_type : dtype
    backend : place

- api : randperm
  args : (int n, DataType dtype, Place place={})
  output : Tensor
  infer_meta :
    func : RandpermInferMeta
    param : [n, dtype]
  kernel :
    func : randperm
    param : [n, dtype]
    data_type : dtype
    backend : place

- api : real
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : real
  backward : real_grad

- api : reciprocal
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : reciprocal
  backward : reciprocal_grad

# reduce_prod
- api : reduce_prod
  args : (Tensor x, int64_t[] dims, bool keep_dim, bool reduce_all)
  output : Tensor
  infer_meta :
    func : ReduceInferMetaBase
  kernel :
    func : prod_raw
  backward : reduce_prod_grad

- api : relu
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : relu
  inplace : (x -> out)
  backward : relu_grad

- api : reshape
  args : (Tensor x, IntArray shape)
  output : Tensor(out), Tensor(xshape)
  infer_meta :
    func : ReshapeWithXShapeInferMeta
  kernel :
    func : reshape_with_xshape
  inplace : (x -> out)
  view: (x -> out)
  intermediate : xshape
  backward: reshape_grad

- api : roi_align
  args : (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, float spatial_scale, int sampling_ratio, bool aligned)
  output : Tensor
  infer_meta :
    func : RoiAlignInferMeta
  kernel :
    func : roi_align
  optional : boxes_num
  backward : roi_align_grad

- api : roi_pool
  args : (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, float spatial_scale)
  output : Tensor(out), Tensor(arg_max)
  infer_meta :
    func : RoiPoolInferMeta
  kernel :
    func : roi_pool
  optional : boxes_num
  intermediate : arg_max
  backward : roi_pool_grad

- api : roll
  args : (Tensor x, IntArray shifts, int64_t[] axis)
  output : Tensor(out)
  infer_meta :
    func : RollInferMeta
  kernel :
    func : roll
  backward : roll_grad

- api : round
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : round
  backward : round_grad

- api : rsqrt
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : rsqrt
  inplace : (x -> out)
  backward : rsqrt_grad

- api : scale
  args : (Tensor x, Scalar scale, float bias, bool bias_after_scale)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : scale, scale_sr
  inplace : (x -> out)
  backward : scale_grad

- api : scatter
  args : (Tensor x, Tensor index, Tensor updates, bool overwrite)
  output : Tensor
  infer_meta :
    func : ScatterInferMeta
    dtype : x
  kernel :
    func : scatter
  backward : scatter_grad

- api : scatter_nd_add
  args : (Tensor x, Tensor index, Tensor updates)
  output : Tensor
  infer_meta :
    func : ScatterNdAddInferMeta
    dtype : x
  kernel :
    func : scatter_nd_add
  backward : scatter_nd_add_grad

- api : searchsorted
  args : (Tensor sorted_sequence, Tensor value, bool out_int32, bool right)
  output : Tensor(out)
  infer_meta :
    func : SearchsortedInferMeta
  kernel :
    func : searchsorted
    data_type : sorted_sequence

# segment_pool
- api : segment_pool
  args : (Tensor x, Tensor segment_ids, str pooltype)
  output : Tensor(out), Tensor(summed_ids)
  infer_meta :
    func : SegmentPoolInferMeta
  kernel :
    func : segment_pool
    data_type : x
  backward : segment_pool_grad

# selu
- api : selu
  args : (Tensor x, float scale, float alpha)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : selu
  backward : selu_grad

- api : sgd
  args : (Tensor param, Tensor learning_rate, Tensor grad, Tensor master_param, bool multi_precision)
  output : Tensor(param_out), Tensor(master_param_out)
  invoke : sgd_impl(param, learning_rate, grad, master_param, multi_precision)
  optional : master_param

- api : shape
  args : (Tensor input)
  output : Tensor
  infer_meta :
    func : ShapeInferMeta
  kernel :
    func : shape, shape_sr
  data_transform:
    skip_transform : input

# shard_index
- api : shard_index
  args : (Tensor in, int index_num, int nshards, int shard_id, int ignore_value)
  output : Tensor
  infer_meta :
    func : ShardIndexInferMeta
  kernel :
    func : shard_index

# sigmoid
- api : sigmoid
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sigmoid
  backward : sigmoid_grad

# sigmoid_cross_entropy_with_logits
- api : sigmoid_cross_entropy_with_logits
  args : (Tensor x, Tensor label, bool normalize, int ignore_index)
  output : Tensor
  infer_meta :
    func : SigmoidCrossEntropyWithLogitsInferMeta
  kernel :
    func : sigmoid_cross_entropy_with_logits
  backward : sigmoid_cross_entropy_with_logits_grad

- api : sign
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sign

# silu
- api : silu
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : silu
  backward : silu_grad

# sin
- api : sin
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sin
  backward : sin_grad

# sinh
- api : sinh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sinh
  backward : sinh_grad

# size
- api : size
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : SizeInferMeta
  kernel :
    func : size
  data_transform:
    skip_transform : x

- api : slice
  args : (Tensor input, int64_t[] axes, IntArray starts, IntArray ends, int64_t[] infer_flags, int64_t[] decrease_axis)
  output : Tensor
  infer_meta :
    func : SliceRawInferMeta
  kernel :
    func : slice
  backward : slice_grad

# soft_shrink
- api : soft_shrink
  args : (Tensor x, float lambda)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : soft_shrink
  backward : soft_shrink_grad

- api : softmax
  args : (Tensor x, int axis)
  output : Tensor
  infer_meta :
    func : SoftmaxInferMeta
  kernel :
    func : softmax
    use_gpudnn : true
  backward : softmax_grad

- api : split
  args : (Tensor x, IntArray num_or_sections, Scalar(int) axis)
  output : Tensor[]
  invoke : split_impl(x, num_or_sections, axis)
  backward : split_grad

- api : sqrt
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sqrt
  backward : sqrt_grad

- api : square
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : square
  backward : square_grad

- api : squeeze
  args : (Tensor x, int[] axes)
  output : Tensor(xshape), Tensor(out)
  infer_meta :
    func : SqueezeInferMeta
  kernel :
    func : squeeze
  view: (x -> out)
  backward : squeeze_grad

- api : stack
  args : (Tensor[] x, int axis)
  output : Tensor
  infer_meta :
    func : StackInferMeta
  kernel :
    func : stack
  backward : stack_grad

- api : strided_slice
  args : (Tensor x, int[] axes, IntArray starts, IntArray ends, IntArray strides)
  output : Tensor
  infer_meta :
    func : StridedSliceInferMeta
  kernel :
    func : strided_slice
  backward : strided_slice_grad

- api : subtract
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : subtract
  backward : subtract_grad

- api : sum
  args : (Tensor x, int64_t[] dims={}, DataType out_dtype=paddle::experimental::DataType::UNDEFINED, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : SumInferMeta
  kernel :
    func : sum
    data_type : x
  backward : sum_grad

# The python API paddle.nn.functional.swish has no `bete` argument, it may be removed later
- api : swish
  args : (Tensor x, float beta=1.0)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : swish
  backward : swish_grad

# take_along_axis
- api : take_along_axis
  args : (Tensor x, Tensor index, int axis)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [index]
  kernel :
    func : take_along_axis
    data_type : x
  backward : take_along_axis_grad

# tan
- api : tan
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tan
  backward : tan_grad

# tanh
- api : tanh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tanh
  backward : tanh_grad

# tanh_shrink
- api : tanh_shrink
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tanh_shrink
  backward : tanh_shrink_grad

# thresholded_relu
- api : thresholded_relu
  args : (Tensor x, float threshold)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : thresholded_relu
  backward : thresholded_relu_grad

# tile
- api : tile
  args : (Tensor x, IntArray repeat_times)
  output : Tensor
  infer_meta :
    func : TileInferMeta
  kernel :
    func : tile
  backward : tile_grad

- api : top_k
  args : (Tensor x, Scalar k, int axis = -1, bool largest = true, bool sorted = true)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : TopKInferMeta
  kernel :
    func : top_k
  backward : top_k_grad

- api : trace
  args : (Tensor x, int offset, int axis1, int axis2)
  output : Tensor
  infer_meta :
    func : TraceInferMeta
  kernel :
    func : trace
  backward : trace_grad

- api : transpose
  args : (Tensor x, int[] axis)
  output : Tensor
  infer_meta :
    func : TransposeInferMeta
  kernel :
    func : transpose
  backward : transpose_grad

- api : triangular_solve
  args : (Tensor x, Tensor y, bool upper, bool transpose, bool unitriangular)
  output : Tensor
  infer_meta :
    func : TriangularSolveInferMeta
  kernel :
    func : triangular_solve
  backward : triangular_solve_grad

- api : tril_triu
  args : (Tensor x,  int diagonal,  bool lower)
  output : Tensor(out)
  infer_meta :
    func : TrilTriuInferMeta
  kernel :
    func : tril_triu
  backward : tril_triu_grad

- api : trunc
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : trunc
  backward : trunc_grad

# python API: paddle.nn.initializer.TruncatedNormal
- api : truncated_gaussian_random
  args : (int[] shape, float mean, float std, int seed, DataType dtype=DataType::FLOAT32, Place place={})
  output : Tensor
  infer_meta :
    func : TruncatedGaussianRandomInferMeta
    param : [shape, mean, std, seed, dtype]
  kernel :
    func : truncated_gaussian_random
    param : [shape, mean, std, seed, dtype]
    backend : place
    data_type : dtype

- api : unbind
  args : (Tensor input, int axis)
  output : Tensor[] {axis<0 ? input.dims()[input.dims().size()+axis]:input.dims()[axis]}
  infer_meta :
    func : UnbindInferMeta
  kernel :
    func : unbind
  backward : unbind_grad

# unfold
- api : unfold
  args : (Tensor x, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations)
  output : Tensor
  infer_meta :
    func : UnfoldInferMeta
  kernel :
    func : unfold
  backward : unfold_grad

- api : uniform_random
  args : (IntArray shape,  DataType dtype,  float min,  float max,  int seed, Place place={})
  output : Tensor(out)
  infer_meta :
    func : UniformRandomInferMeta
    param: [shape, dtype, min, max, seed]
  kernel :
    func : uniform_random
    param: [shape, dtype, min, max, seed]
    data_type : dtype
    backend : place

# The `axis` argument of Python API paddle.unique is not vector
- api : unique
  args : (Tensor x, bool return_index, bool return_inverse, bool return_counts, int[] axis, DataType dtype=DataType::INT64)
  output : Tensor(out), Tensor(indices), Tensor(inverse), Tensor(counts)
  infer_meta :
    func : UniqueInferMeta
  kernel :
    func : unique
    data_type : x

- api : unsqueeze
  args : (Tensor x, IntArray axis)
  output : Tensor(xshape), Tensor(out)
  infer_meta :
    func : UnsqueezeInferMeta
  kernel :
    func : unsqueeze
  view: (x -> out)
  backward : unsqueeze_grad

# viterbi_decode
- api : viterbi_decode
  args : (Tensor input, Tensor transition, Tensor length, bool include_bos_eos_tag)
  output : Tensor(scores), Tensor(path)
  infer_meta :
    func : ViterbiDecodeInferMeta
  kernel :
    func : viterbi_decode
    data_type : input

- api : where
  args : (Tensor condition, Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : WhereInferMeta
  kernel :
    func : where
  backward : where_grad

# where_index
- api : where_index
  args : (Tensor condition)
  output : Tensor
  infer_meta :
    func : WhereIndexInferMeta
  kernel :
    func : where_index

# yolo_box
- api : yolo_box
  args : (Tensor x, Tensor img_size, int[] anchors, int class_num, float conf_thresh, int downsample_ratio, bool clip_bbox, float scale_x_y=1.0, bool iou_aware=false, float iou_aware_factor=0.5)
  output : Tensor(boxes), Tensor(scores)
  infer_meta :
    func : YoloBoxInferMeta
  kernel :
    func : yolo_box
    data_type : x

- api : zeros_like
  args : (Tensor x, DataType dtype=DataType::UNDEFINED, Place place = {})
  output : Tensor
  invoke : full_like(x, 0, dtype, place)

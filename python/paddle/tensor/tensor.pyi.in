# The base `Tensor` for generating `Tensor.pyi`, which overwrites the stub file generated from `tools/gen_tensor_stub.py`.
# Add attributes, methods with type annotaions for `Tensor`
# if not conveniently edit in original place (like c++ source file).

from __future__ import annotations

import numpy as np
import numpy.typing as npt

from typing import Any, Generic, TypeVar
from typing_extensions import overload

import paddle

_ShapeType = TypeVar("_ShapeType", bound=Any)
_DType = TypeVar("_DType", bound=Any)


class Tensor(Generic[_ShapeType, _DType]):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(
        self, dtype, dims, name: str, type, persistable: bool
    ) -> None: ...

    @overload
    def __init__(
        self,
        value: npt.NDArray[Any],
        place,
        persistable: bool,
        zero_copy: bool,
        name: str,
        stop_gradient: bool,
    ) -> None: ...

    @overload
    def __init__(self, value: npt.NDArray[Any]) -> None: ...

    @overload
    def __init__(self, value: Tensor) -> None: ...

    @overload
    def __init__(
        self, value: Tensor, place, name: str, process_mesh, placements
    ) -> None: ...

    @overload
    def __init__(
        self, value: Tensor, dims, name: str, process_mesh, placements
    ) -> None: ...

    @overload
    def __init__(self, value: Tensor, place, name: str) -> None: ...

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        """
        ref: paddle/fluid/pybind/eager.cc

        /** We should have init function with signature:
        * 1.
        * def __init__ ()
        * 2.
        * def __init__ (
        * ** dtype: paddle::framework::proto::VarType::Type,
        * ** dims: vector<int>,
        * ** name: std::string,
        * ** type: paddle::framework::proto::VarType::LodTensor,
        * ** persistable: bool)
        * 3. (multi-place)
        * (should have at least one parameter, one parameter equals to case 4, zero
        * parameter equals to case 1)
        * def __init__ (
        * ** value: ndarray,
        * ** place: paddle::platform::Place,
        * ** persistable: bool,
        * ** zero_copy: bool,
        * ** name: std::string,
        * ** stop_gradient: bool)
        * 4.
        * def __init__ (
        * ** value: ndarray)
        * 5.
        * def __init__ (
        * ** tensor: Tensor)
        * 6. (multi-place)
        * (should have at least one parameter, one parameter equals to case 5, zero
        * parameter equals to case 1.)
        * def __init__ (
        * ** global_tensor: Tensor,
        * ** place: paddle::platform::Place,
        * ** name: std::string,
        * ** process_mesh: phi::distributed::ProcessMesh
        * ** placements: std::vector<Placement>)
        * 7. (multi-place)
        * (should have at least one parameter, one parameter equals to case 5, zero
        * parameter equals to case 1.)
        * def __init__ (
        * ** local_tensor: Tensor,
        * ** global_dims: vector<int>,
        * ** name: std::string,
        * ** process_mesh: phi::distributed::ProcessMesh
        * ** placements: std::vector<Placement>)
        * 8. (multi-place) (should have at least one parameter, one parameter similar
        * to case 5, zero parameter equals to case 1.)
        * def __init__ (
        * ** tensor: FrameworkTensor,
        * ** place: paddle::platform::Place,
        * ** name: std::string)
        *  **/
        """
        ...

    def __add__(self, y: Tensor) -> Tensor: ...

    def __and__(
        self,
        y: Tensor,
        out: Tensor | None = None,
        name: str | None = None,
    ) -> Tensor: ...

    def __bool__(self) -> bool: ...

    def __div__(self, y: Tensor) -> Tensor: ...

    def __eq__(self, y: Tensor) -> Tensor[Any, bool]: ...  # type: ignore[override]

    def __float__(self) -> float: ...

    def __floordiv__(self, y: Tensor) -> Tensor: ...

    def __ge__(self, y: Tensor) -> Tensor[Any, bool]: ...

    def __getitem__(
        self,
        item: (
            None
            | bool
            | int
            | slice
            | ellipsis
            | tuple[None | bool | int | slice | ellipsis, ...]
            | list[Tensor | bool | int]
        ),
    ): ...

    def __gt__(self, y: Tensor) -> Tensor[Any, bool]: ...

    def __hash__(self) -> int: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __invert__(
        self, out: Tensor | None = None, name: str | None = None
    ) -> Tensor: ...

    def __le__(self, y: Tensor) -> Tensor[Any, bool]: ...

    def __len__(self) -> int: ...

    def __long__(self) -> float: ...

    def __lt__(self, y: Tensor) -> Tensor[Any, bool]: ...

    def __matmul__(self, y: Tensor) -> Tensor: ...

    def __mod__(self, y: Tensor) -> Tensor: ...

    def __mul__(self, y: Tensor) -> Tensor: ...

    def __ne__(self, y: Tensor) -> Tensor[Any, bool]: ...  # type: ignore[override]

    def __neg__(self) -> Tensor: ...

    def __nonzero__(self) -> bool: ...

    def __pow__(self, y: Tensor) -> Tensor: ...

    def __radd__(self, y: Tensor) -> Tensor: ...

    def __rdiv__(self, y: Tensor) -> Tensor: ...

    def __rmul__(self, y: Tensor) -> Tensor: ...

    def __rpow__(self, y: Tensor) -> Tensor: ...

    def __rsub__(self, y: Tensor) -> Tensor: ...

    def __rtruediv__(self, y: Tensor) -> Tensor: ...

    def __setitem__(
        self,
        item: (
            None
            | bool
            | int
            | slice
            | ellipsis
            | tuple[None | bool | int | slice | ellipsis, ...]
            | list[Tensor | bool | int]
        ),
        value: Tensor | npt.NDArray[Any] | int | float | complex | bool,
    ) -> None: ...

    def __sub__(self, y: Tensor) -> Tensor: ...

    def __truediv__(self, y: Tensor) -> Tensor: ...

    def clear_gradient(self, set_to_zero: bool = True) -> None: ...

    def clone(self) -> Tensor: ...

    def cols(self) -> Tensor: ...

    def contiguous(self) -> Tensor: ...

    def copy_(self) -> Tensor: ...

    def crows(self) -> Tensor: ...

    @property
    def data(self) -> Tensor: ...

    def data_ptr(self) -> int: ...

    def detach(self) -> Tensor: ...

    def detach_(self) -> Tensor: ...

    @property
    def dtype(self): ...

    def element_size(self) -> int: ...

    def get_map_tensor(self) -> Tensor: ...

    def get_selected_rows(self): ...

    def get_strides(self) -> list[int]: ...

    def get_tensor(self) -> Tensor: ...

    @property
    def grad(self) -> Tensor | None: ...

    @property
    def grad_(self) -> Tensor | None: ...

    @property
    def grad_fn(self): ...

    def is_contiguous(self) -> bool: ...

    def is_dense(self) -> bool: ...

    def is_dist(self) -> bool: ...

    @property
    def is_leaf(self) -> bool: ...

    def is_same_shape(self, y: Tensor) -> bool: ...

    def is_selected_rows(self) -> bool: ...

    def is_sparse(self) -> bool: ...

    def is_sparse_coo(self) -> bool: ...

    def is_sparse_csr(self) -> bool: ...

    @property
    def layout(self): ...

    @property
    def name(self) -> str: ...

    @property
    def ndim(self) -> int: ...

    def nnz(self) -> int: ...

    @property
    def num_shard(self) -> int: ...

    def numpy(self) -> npt.NDArray[Any]: ...

    @property
    def offset(self) -> int: ...

    @property
    def persistable(self) -> bool: ...

    @property
    def place(self): ...

    @property
    def placements(self): ...

    @property
    def process_mesh(self): ...

    def rows(self): ...

    def set_string_list(self): ...

    def set_vocab(self): ...

    @property
    def shape(self): ...

    @property
    def size(self) -> int: ...

    @property
    def strides(self) -> list[int]: ...

    @property
    def type(self): ...

    # annotation: tensor_methods

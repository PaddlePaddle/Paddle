# The base `Tensor` for generating `Tensor.pyi`, which overwrites the stub file generated from `tools/gen_tensor_stub.py`.
# Add attributes, methods with type annotaions for `Tensor`
# if not conveniently edit in original place (like c++ source file).

from __future__ import annotations

import numpy as np
import numpy.typing as npt

from typing import Any

import paddle


class Tensor:
    def __add__(self): ...

    def __and__(
        self,
        y: paddle.Tensor,
        out: paddle.Tensor | None = None,
        name: str = None,
    ) -> paddle.Tensor: ...

    def __bool__(self): ...

    def __div__(self): ...

    def __eq__(self) -> bool: ...

    def __float__(self): ...

    def __floordiv__(self): ...

    def __ge__(self) -> bool: ...

    def __getitem__(self, item): ...

    def __gt__(self) -> bool: ...

    def __hash__(self): ...

    def __index__(self): ...

    def __init__(self, *args, **kwargs) -> None: ...

    def __int__(self): ...

    def __invert__(
        self, out: paddle.Tensor | None = None, name: str | None = None
    ) -> paddle.Tensor: ...

    def __le__(self) -> bool: ...

    def __len__(self): ...

    def __long__(self): ...

    def __lt__(self) -> bool: ...

    def __matmul__(self): ...

    def __mod__(self): ...

    def __mul__(self): ...

    def __ne__(self) -> bool: ...

    def __neg__(self): ...

    def __nonzero__(self): ...

    def __pow__(self): ...

    def __radd__(self): ...

    def __rdiv__(self): ...

    def __rmul__(self): ...

    def __rpow__(self): ...

    def __rsub__(self): ...

    def __rtruediv__(self): ...

    def __setitem__(self, item, value): ...

    def __sub__(self): ...

    def __truediv__(self): ...

    def clear_gradient(self, set_to_zero: bool = True) -> None: ...

    def clone(self) -> paddle.Tensor: ...

    def cols(self) -> paddle.Tensor: ...

    def contiguous(self) -> paddle.Tensor: ...

    def copy_(self): ...

    def crows(self) -> paddle.Tensor: ...

    @property
    def data(self) -> paddle.Tensor: ...

    def data_ptr(self) -> int: ...

    def detach(self) -> paddle.Tensor: ...

    def detach_(self) -> paddle.Tensor: ...

    @property
    def dtype(self): ...

    def element_size(self) -> int: ...

    def get_map_tensor(self): ...

    def get_selected_rows(self): ...

    def get_strides(self) -> list[int]: ...

    def get_tensor(self) -> paddle.Tensor: ...

    @property
    def grad(self) -> paddle.Tensor | None: ...

    @property
    def grad_(self) -> paddle.Tensor | None: ...

    @property
    def grad_fn(self): ...

    def is_contiguous(self) -> bool: ...

    def is_dense(self) -> bool: ...

    def is_dist(self) -> bool: ...

    @property
    def is_leaf(self) -> bool: ...

    def is_same_shape(self, y: paddle.Tensor) -> bool: ...

    def is_selected_rows(self) -> bool: ...

    def is_sparse(self) -> bool: ...

    def is_sparse_coo(self) -> bool: ...

    def is_sparse_csr(self) -> bool: ...

    @property
    def layout(self): ...

    @property
    def name(self) -> str: ...

    @property
    def ndim(self) -> int: ...

    def nnz(self) -> int: ...

    @property
    def num_shard(self) -> int: ...

    def numpy(self) -> npt.NDArray[Any]: ...

    @property
    def offset(self) -> int: ...

    @property
    def persistable(self) -> bool: ...

    @property
    def place(self): ...

    @property
    def placements(self): ...

    @property
    def process_mesh(self): ...

    def rows(self): ...

    def set_string_list(self): ...

    def set_vocab(self): ...

    @property
    def shape(self): ...

    @property
    def size(self) -> int: ...

    @property
    def strides(self) -> list[int]: ...

    @property
    def type(self): ...

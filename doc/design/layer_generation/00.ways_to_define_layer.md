# 定义Layer/OP的几种方式对比


这篇文章主要是要说明Paddle中，用户定义配置文件现状，问题，并给出数种定义Layer/OP方式的对比。方便大家做出决策。


## 为什么我们要重构配置定义的过程

目前Paddle中，解析用户配置的过程非常繁复。这也是因为Paddle作为一个四年左右项目的遗留问题。为了**兼容**之前所有的Paddle配置文件格式，也为了简化用户配置流程，现阶段Paddle共有三种配置风格。最原始的配置文件格式(`config_parser.py`)，`trainer_config_helper`和`paddle.v2.layer`。三者的调用关系为 `paddle.v2` 调用 `trainer_config_helper`再调用`config_parser.py`。虽然我们没有重复的写这些代码，但是多层的封装让代码很难维护。

主要痛点在于:

* 用户使用Layer，想去查询某一个参数应该如何使用。深入调研Paddle的代码会非常迷惑。同时，这些代码中只有`trainer_config_helper`是具有良好注释和良好风格的。`paddle.v2`虽然也有注释与文档，但其函数是动态生成的，而不是静态的代码，所以也不能**阅读**，而`config_parser.py`缺乏文档和注释。
* 开发者如果想要新写一个Layer，需要修改多个文件。
	* 首先，新写一个Layer，开发者需要在Paddle的[Protobuf文件](https://github.com/PaddlePaddle/Paddle/blob/develop/proto/ModelConfig.proto)中，添加这个Layer需要的参数。
	* 其次，完成这个Layer需要的C/C++文件。完成这个Layer的前向后向代码。
	* 最后完成这个Layer配置文件解析`config_parser.py`，`trainer_config_helpers`和`paddle.v2`
* Paddle的维护成本很高。特别是需要修改某种Layer的实现的时候。
* 如果有其他Language Binding，需要开发的工作量太高。

所以这个设计的目标就是**治理**目前Paddle定义Layer和配置混乱复杂的问题，得到一个清爽的结果, **用户只需要**写一个`C/C++`实现即可完成一个Layer的开发。

同时，这个设计还会兼顾的问题有:

* 向后兼容性 ---- 即是否兼容之前的配置方式.
* 动态网络开发 ---- 神经网络配置解析为动态网络的基础部分。动态网络要求**配置解析必须快**。详细关于动态网络介绍，请参考[DynamicNet](../dynamic_net/00.how_to_implenment_dynamic_net.md)


## 重构配置文件的方法

目前想到了两种方式重构配置文件，他们是:

* 简化当前的Protobuf的配置方式。用户的配置文件最终还是序列化成Protobuf
	* 但是Protobuf需要尽量简化，只接受用户的输入参数。所有的参数推导功能放在C++端来做。
	* 整体设计参考[Generate Layer By Protobuf](./01.how_to_write_a_layer_in_protobuf.md)
* 使用C/C++暴露网络配置的API。网络配置使用第三方语言直接读写C/C++变量
	* Paddle的Layer配置构造和解析完全不依赖Protobuf，会导致无法向后兼容。这意味着新版本将不能构建`paddle_trainer`
	* 整体设计参考[Generate Layer By C/C++](./03.how_to_write_a_layer_in_pure_cpp.md)

这两种方法的优缺点对比为:

|  | 用户配置序列化成Protobuf | 用户直接操作C/C++对象 |
| --- | --- | --- |
| 解析速度 | 慢 | 快 |
| 支持序列化 | 直接支持 | 不直接支持，可以添加 |
| 实现难度 | 简单，但是向后兼容工作量大 | 一般，但是没有向后兼容的包袱 |
| 向后兼容性 | 可以做到向后兼容 | 无法向后兼容，无法实现`paddle_trainer` |


## 结论

经讨论，Paddle开发者认为XXXX是可行的，即使有XXX的问题，也是可以接受的方案。故采取XXXX作为Paddle Layer配置的重构方式。

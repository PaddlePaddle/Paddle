// Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// this file is generated by paddle/phi/api/yaml/generator/generate_op.py, do
// not edit.
#include <string>
#include "paddle/fluid/framework/convert_utils.h"
#include "paddle/fluid/framework/infershape_utils.h"
#include "paddle/fluid/framework/op_registry.h"
#include "paddle/fluid/framework/op_version_registry.h"
#include "paddle/fluid/prim/api/manual/backward/composite_backward_api.h"
#include "paddle/fluid/prim/utils/static/composite_grad_desc_maker.h"
#include "paddle/fluid/prim/utils/static/desc_tensor.h"
#include "paddle/phi/api/include/tensor.h"
#include "paddle/phi/core/infermeta_utils.h"
#include "paddle/phi/infermeta/backward.h"
#include "paddle/phi/infermeta/binary.h"
#include "paddle/phi/infermeta/multiary.h"
#include "paddle/phi/infermeta/nullary.h"
#include "paddle/phi/infermeta/ternary.h"
#include "paddle/phi/infermeta/unary.h"

namespace paddle {
namespace operators {

using paddle::framework::GradVarName;

class AcosOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of acos op.");
    AddOutput("Out", "(Tensor), output 0 of acos op.");
    AddComment(R"DOC(
TODO: Documentation of acos op.
)DOC");
  }
};

class AcosOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(acos,
                            AcosInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class AcoshOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of acosh op.");
    AddOutput("Out", "(Tensor), output 0 of acosh op.");
    AddComment(R"DOC(
TODO: Documentation of acosh op.
)DOC");
  }
};

class AcoshOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(acosh,
                            AcoshInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class AngleOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of angle op.");
    AddOutput("Out", "(Tensor), output 0 of angle op.");
    AddComment(R"DOC(
TODO: Documentation of angle op.
)DOC");
  }
};

class AngleOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(angle,
                            AngleInferShapeFunctor,
                            PD_INFER_META(phi::RealAndImagInferMeta));

class ArgsortOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of argsort op.");
    AddOutput("Out", "(Tensor), output 0 of argsort op.");
    AddOutput("Indices", "(Tensor), output 1 of argsort op.");
    AddAttr<int>("axis", "(int), attribute 0 for argsort op.").SetDefault(-1);
    AddAttr<bool>("descending", "(bool), attribute 1 for argsort op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of argsort op.
)DOC");
  }
};

class ArgsortOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(argsort,
                            ArgsortInferShapeFunctor,
                            PD_INFER_META(phi::ArgsortInferMeta));

class AsComplexOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of as_complex op.");
    AddOutput("Out", "(Tensor), output 0 of as_complex op.");
    AddComment(R"DOC(
TODO: Documentation of as_complex op.
)DOC");
  }
};

class AsComplexOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(as_complex,
                            AsComplexInferShapeFunctor,
                            PD_INFER_META(phi::AsComplexInferMeta));

class AsRealOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of as_real op.");
    AddOutput("Out", "(Tensor), output 0 of as_real op.");
    AddComment(R"DOC(
TODO: Documentation of as_real op.
)DOC");
  }
};

class AsRealOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(as_real,
                            AsRealInferShapeFunctor,
                            PD_INFER_META(phi::AsRealInferMeta));

class AsinOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of asin op.");
    AddOutput("Out", "(Tensor), output 0 of asin op.");
    AddComment(R"DOC(
TODO: Documentation of asin op.
)DOC");
  }
};

class AsinOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(asin,
                            AsinInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class AsinhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of asinh op.");
    AddOutput("Out", "(Tensor), output 0 of asinh op.");
    AddComment(R"DOC(
TODO: Documentation of asinh op.
)DOC");
  }
};

class AsinhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(asinh,
                            AsinhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class AtanOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of atan op.");
    AddOutput("Out", "(Tensor), output 0 of atan op.");
    AddComment(R"DOC(
TODO: Documentation of atan op.
)DOC");
  }
};

class AtanOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(atan,
                            AtanInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class Atan2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X1", "(Tensor), input 0 of atan2 op.");
    AddInput("X2", "(Tensor), input 1 of atan2 op.");
    AddOutput("Out", "(Tensor), output 0 of atan2 op.");
    AddComment(R"DOC(
TODO: Documentation of atan2 op.
)DOC");
  }
};

class Atan2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(atan2,
                            Atan2InferShapeFunctor,
                            PD_INFER_META(phi::Atan2InferMeta));

class AtanhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of atanh op.");
    AddOutput("Out", "(Tensor), output 0 of atanh op.");
    AddComment(R"DOC(
TODO: Documentation of atanh op.
)DOC");
  }
};

class AtanhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(atanh,
                            AtanhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class BernoulliOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of bernoulli op.");
    AddOutput("Out", "(Tensor), output 0 of bernoulli op.");
    AddComment(R"DOC(
TODO: Documentation of bernoulli op.
)DOC");
  }
};

class BernoulliOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(bernoulli,
                            BernoulliInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class BmmOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of bmm op.");
    AddInput("Y", "(Tensor), input 1 of bmm op.");
    AddOutput("Out", "(Tensor), output 0 of bmm op.");
    AddComment(R"DOC(
TODO: Documentation of bmm op.
)DOC");
  }
};

class BmmOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(bmm,
                            BmmInferShapeFunctor,
                            PD_INFER_META(phi::BmmInferMeta));

class CeilOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of ceil op.");
    AddOutput("Out", "(Tensor), output 0 of ceil op.");
    AddComment(R"DOC(
TODO: Documentation of ceil op.
)DOC");
  }
};

class CeilOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(ceil,
                            CeilInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(CeilInplaceInferer, {"X", "Out"});

class CeluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of celu op.");
    AddOutput("Out", "(Tensor), output 0 of celu op.");
    AddAttr<float>("alpha", "(float), attribute 0 for celu op.")
        .SetDefault(1.0);
    AddComment(R"DOC(
TODO: Documentation of celu op.
)DOC");
  }
};

class CeluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(celu,
                            CeluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class CholeskyOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of cholesky op.");
    AddOutput("Out", "(Tensor), output 0 of cholesky op.");
    AddAttr<bool>("upper", "(bool), attribute 0 for cholesky op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of cholesky op.
)DOC");
  }
};

class CholeskyOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cholesky,
                            CholeskyInferShapeFunctor,
                            PD_INFER_META(phi::CholeskyInferMeta));

class CholeskySolveOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of cholesky_solve op.");
    AddInput("Y", "(Tensor), input 1 of cholesky_solve op.");
    AddOutput("Out", "(Tensor), output 0 of cholesky_solve op.");
    AddAttr<bool>("upper", "(bool), attribute 0 for cholesky_solve op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of cholesky_solve op.
)DOC");
  }
};

class CholeskySolveOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cholesky_solve,
                            CholeskySolveInferShapeFunctor,
                            PD_INFER_META(phi::CholeskySolveInferMeta));

class ConjOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of conj op.");
    AddOutput("Out", "(Tensor), output 0 of conj op.");
    AddComment(R"DOC(
TODO: Documentation of conj op.
)DOC");
  }
};

class ConjOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(conj,
                            ConjInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class CosOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of cos op.");
    AddOutput("Out", "(Tensor), output 0 of cos op.");
    AddComment(R"DOC(
TODO: Documentation of cos op.
)DOC");
  }
};

class CosOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cos,
                            CosInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class CoshOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of cosh op.");
    AddOutput("Out", "(Tensor), output 0 of cosh op.");
    AddComment(R"DOC(
TODO: Documentation of cosh op.
)DOC");
  }
};

class CoshOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cosh,
                            CoshInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class CropTensorOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of crop_tensor op.");
    AddOutput("Out", "(Tensor), output 0 of crop_tensor op.");
    AddInput("Shape", "attribute 0 for crop_tensor op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("ShapeTensor",
             "attribute 0 for crop_tensor op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
    AddAttr<std::vector<int>>(
        "shape", "(std::vector<int>), attribute 0 for crop_tensor op.")
        .SetDefault({});
    AddInput("Offsets",
             "attribute 1 for crop_tensor op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("OffsetsTensor",
             "attribute 1 for crop_tensor op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
    AddAttr<std::vector<int>>(
        "offsets", "(std::vector<int>), attribute 1 for crop_tensor op.")
        .SetDefault({});
    AddComment(R"DOC(
TODO: Documentation of crop_tensor op.
)DOC");
  }
};

class CropTensorOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(crop_tensor,
                            CropTensorInferShapeFunctor,
                            PD_INFER_META(phi::CropInferMeta));

class CrossOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of cross op.");
    AddInput("Y", "(Tensor), input 1 of cross op.");
    AddOutput("Out", "(Tensor), output 0 of cross op.");
    AddAttr<int>("dim", "(int), attribute 0 for cross op.").SetDefault(9);
    AddComment(R"DOC(
TODO: Documentation of cross op.
)DOC");
  }
};

class CrossOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(cross,
                            CrossInferShapeFunctor,
                            PD_INFER_META(phi::CrossInferMeta));

class DeterminantOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of determinant op.");
    AddOutput("Out", "(Tensor), output 0 of determinant op.");
    AddComment(R"DOC(
TODO: Documentation of determinant op.
)DOC");
  }
};

class DeterminantOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(determinant,
                            DeterminantInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class DiagV2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of diag_v2 op.");
    AddOutput("Out", "(Tensor), output 0 of diag_v2 op.");
    AddAttr<int>("offset", "(int), attribute 0 for diag_v2 op.").SetDefault(0);
    AddAttr<float>("padding_value", "(float), attribute 1 for diag_v2 op.")
        .SetDefault(0.0);
    AddComment(R"DOC(
TODO: Documentation of diag_v2 op.
)DOC");
  }
};

class DiagV2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(diag_v2,
                            DiagV2InferShapeFunctor,
                            PD_INFER_META(phi::DiagInferMeta));

class DiagEmbedOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of diag_embed op.");
    AddOutput("Out", "(Tensor), output 0 of diag_embed op.");
    AddAttr<int>("offset", "(int), attribute 0 for diag_embed op.")
        .SetDefault(0);
    AddAttr<int>("dim1", "(int), attribute 1 for diag_embed op.")
        .SetDefault(-2);
    AddAttr<int>("dim2", "(int), attribute 2 for diag_embed op.")
        .SetDefault(-1);
    AddComment(R"DOC(
TODO: Documentation of diag_embed op.
)DOC");
  }
};

class DiagEmbedOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(diag_embed,
                            DiagEmbedInferShapeFunctor,
                            PD_INFER_META(phi::DiagEmbedInferMeta));

class DiagonalOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of diagonal op.");
    AddOutput("Out", "(Tensor), output 0 of diagonal op.");
    AddAttr<int>("offset", "(int), attribute 0 for diagonal op.").SetDefault(0);
    AddAttr<int>("axis1", "(int), attribute 1 for diagonal op.").SetDefault(0);
    AddAttr<int>("axis2", "(int), attribute 2 for diagonal op.").SetDefault(1);
    AddComment(R"DOC(
TODO: Documentation of diagonal op.
)DOC");
  }
};

class DiagonalOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(diagonal,
                            DiagonalInferShapeFunctor,
                            PD_INFER_META(phi::DiagonalInferMeta));

class DigammaOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of digamma op.");
    AddOutput("Out", "(Tensor), output 0 of digamma op.");
    AddComment(R"DOC(
TODO: Documentation of digamma op.
)DOC");
  }
};

class DigammaOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(digamma,
                            DigammaInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class DistOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of dist op.");
    AddInput("Y", "(Tensor), input 1 of dist op.");
    AddOutput("Out", "(Tensor), output 0 of dist op.");
    AddAttr<float>("p", "(float), attribute 0 for dist op.").SetDefault(2.0);
    AddComment(R"DOC(
TODO: Documentation of dist op.
)DOC");
  }
};

class DistOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(dist,
                            DistInferShapeFunctor,
                            PD_INFER_META(phi::DistInferMeta));

class DotOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of dot op.");
    AddInput("Y", "(Tensor), input 1 of dot op.");
    AddOutput("Out", "(Tensor), output 0 of dot op.");
    AddComment(R"DOC(
TODO: Documentation of dot op.
)DOC");
  }
};

class DotOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(dot,
                            DotInferShapeFunctor,
                            PD_INFER_META(phi::DotInferMeta));

class EigOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of eig op.");
    AddOutput("Eigenvalues", "(Tensor), output 0 of eig op.");
    AddOutput("Eigenvectors", "(Tensor), output 1 of eig op.");
    AddComment(R"DOC(
TODO: Documentation of eig op.
)DOC");
  }
};

class EigOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(eig,
                            EigInferShapeFunctor,
                            PD_INFER_META(phi::EigInferMeta));

class EighOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of eigh op.");
    AddOutput("Eigenvalues", "(Tensor), output 0 of eigh op.");
    AddOutput("Eigenvectors", "(Tensor), output 1 of eigh op.");
    AddAttr<std::string>("UPLO", "(std::string), attribute 0 for eigh op.")
        .SetDefault("L");
    AddComment(R"DOC(
TODO: Documentation of eigh op.
)DOC");
  }
};

class EighOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(eigh,
                            EighInferShapeFunctor,
                            PD_INFER_META(phi::EighInferMeta));

class EigvalsOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of eigvals op.");
    AddOutput("Out", "(Tensor), output 0 of eigvals op.");
    AddComment(R"DOC(
TODO: Documentation of eigvals op.
)DOC");
  }
};

class EigvalsOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(eigvals,
                            EigvalsInferShapeFunctor,
                            PD_INFER_META(phi::EigvalsInferMeta));

class EluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of elu op.");
    AddOutput("Out", "(Tensor), output 0 of elu op.");
    AddAttr<float>("alpha", "(float), attribute 0 for elu op.")
        .SetDefault(1.0f);
    AddComment(R"DOC(
TODO: Documentation of elu op.
)DOC");
  }
};

class EluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(elu,
                            EluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(EluInplaceInferer, {"X", "Out"});

class EqualAllOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of equal_all op.");
    AddInput("Y", "(Tensor), input 1 of equal_all op.");
    AddOutput("Out", "(Tensor), output 0 of equal_all op.");
    AddComment(R"DOC(
TODO: Documentation of equal_all op.
)DOC");
  }
};

class EqualAllOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(equal_all,
                            EqualAllInferShapeFunctor,
                            PD_INFER_META(phi::CompareAllInferMeta));

class ErfOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of erf op.");
    AddOutput("Out", "(Tensor), output 0 of erf op.");
    AddComment(R"DOC(
TODO: Documentation of erf op.
)DOC");
  }
};

class ErfOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(erf,
                            ErfInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class ErfinvOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of erfinv op.");
    AddOutput("Out", "(Tensor), output 0 of erfinv op.");
    AddComment(R"DOC(
TODO: Documentation of erfinv op.
)DOC");
  }
};

class ErfinvOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(erfinv,
                            ErfinvInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ErfinvInplaceInferer, {"X", "Out"});

class ExpOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of exp op.");
    AddOutput("Out", "(Tensor), output 0 of exp op.");
    AddComment(R"DOC(
TODO: Documentation of exp op.
)DOC");
  }
};

class ExpOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(exp,
                            ExpInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ExpInplaceInferer, {"X", "Out"});

class Expm1OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of expm1 op.");
    AddOutput("Out", "(Tensor), output 0 of expm1 op.");
    AddComment(R"DOC(
TODO: Documentation of expm1 op.
)DOC");
  }
};

class Expm1Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(expm1,
                            Expm1InferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class FftC2cOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of fft_c2c op.");
    AddOutput("Out", "(Tensor), output 0 of fft_c2c op.");
    AddAttr<std::vector<int64_t>>(
        "axes", "(std::vector<int64_t>), attribute 0 for fft_c2c op.");
    AddAttr<std::string>("normalization",
                         "(std::string), attribute 1 for fft_c2c op.");
    AddAttr<bool>("forward", "(bool), attribute 2 for fft_c2c op.");
    AddComment(R"DOC(
TODO: Documentation of fft_c2c op.
)DOC");
  }
};

class FftC2cOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(fft_c2c,
                            FftC2cInferShapeFunctor,
                            PD_INFER_META(phi::FFTC2CInferMeta));

class FftC2rOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of fft_c2r op.");
    AddOutput("Out", "(Tensor), output 0 of fft_c2r op.");
    AddAttr<std::vector<int64_t>>(
        "axes", "(std::vector<int64_t>), attribute 0 for fft_c2r op.");
    AddAttr<std::string>("normalization",
                         "(std::string), attribute 1 for fft_c2r op.");
    AddAttr<bool>("forward", "(bool), attribute 2 for fft_c2r op.");
    AddAttr<int64_t>("last_dim_size", "(int64_t), attribute 3 for fft_c2r op.")
        .SetDefault(0L);
    AddComment(R"DOC(
TODO: Documentation of fft_c2r op.
)DOC");
  }
};

class FftC2rOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(fft_c2r,
                            FftC2rInferShapeFunctor,
                            PD_INFER_META(phi::FFTC2RInferMeta));

class FftR2cOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of fft_r2c op.");
    AddOutput("Out", "(Tensor), output 0 of fft_r2c op.");
    AddAttr<std::vector<int64_t>>(
        "axes", "(std::vector<int64_t>), attribute 0 for fft_r2c op.");
    AddAttr<std::string>("normalization",
                         "(std::string), attribute 1 for fft_r2c op.");
    AddAttr<bool>("forward", "(bool), attribute 2 for fft_r2c op.");
    AddAttr<bool>("onesided", "(bool), attribute 3 for fft_r2c op.");
    AddComment(R"DOC(
TODO: Documentation of fft_r2c op.
)DOC");
  }
};

class FftR2cOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(fft_r2c,
                            FftR2cInferShapeFunctor,
                            PD_INFER_META(phi::FFTR2CInferMeta));

class FillDiagonalTensorOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of fill_diagonal_tensor op.");
    AddInput("Y", "(Tensor), input 1 of fill_diagonal_tensor op.");
    AddOutput("Out", "(Tensor), output 0 of fill_diagonal_tensor op.");
    AddAttr<int64_t>("offset",
                     "(int64_t), attribute 0 for fill_diagonal_tensor op.")
        .SetDefault(0);
    AddAttr<int>("dim1", "(int), attribute 1 for fill_diagonal_tensor op.")
        .SetDefault(0);
    AddAttr<int>("dim2", "(int), attribute 2 for fill_diagonal_tensor op.")
        .SetDefault(1);
    AddComment(R"DOC(
TODO: Documentation of fill_diagonal_tensor op.
)DOC");
  }
};

class FillDiagonalTensorOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(fill_diagonal_tensor,
                            FillDiagonalTensorInferShapeFunctor,
                            PD_INFER_META(phi::FillDiagonalTensorInferMeta));
DECLARE_INPLACE_OP_INFERER(FillDiagonalTensorInplaceInferer, {"X", "Out"});

class FlipOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of flip op.");
    AddOutput("Out", "(Tensor), output 0 of flip op.");
    AddAttr<std::vector<int>>("axis",
                              "(std::vector<int>), attribute 0 for flip op.");
    AddComment(R"DOC(
TODO: Documentation of flip op.
)DOC");
  }
};

class FlipOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(flip,
                            FlipInferShapeFunctor,
                            PD_INFER_META(phi::FlipInferMeta));

class FloorOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of floor op.");
    AddOutput("Out", "(Tensor), output 0 of floor op.");
    AddComment(R"DOC(
TODO: Documentation of floor op.
)DOC");
  }
};

class FloorOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(floor,
                            FloorInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(FloorInplaceInferer, {"X", "Out"});

class FoldOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of fold op.");
    AddOutput("Y", "(Tensor), output 0 of fold op.");
    AddAttr<std::vector<int>>("output_sizes",
                              "(std::vector<int>), attribute 0 for fold op.");
    AddAttr<std::vector<int>>("kernel_sizes",
                              "(std::vector<int>), attribute 1 for fold op.");
    AddAttr<std::vector<int>>("strides",
                              "(std::vector<int>), attribute 2 for fold op.");
    AddAttr<std::vector<int>>("paddings",
                              "(std::vector<int>), attribute 3 for fold op.");
    AddAttr<std::vector<int>>("dilations",
                              "(std::vector<int>), attribute 4 for fold op.");
    AddComment(R"DOC(
TODO: Documentation of fold op.
)DOC");
  }
};

class FoldOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(fold,
                            FoldInferShapeFunctor,
                            PD_INFER_META(phi::FoldInferMeta));

class GatherTreeOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Ids", "(Tensor), input 0 of gather_tree op.");
    AddInput("Parents", "(Tensor), input 1 of gather_tree op.");
    AddOutput("Out", "(Tensor), output 0 of gather_tree op.");
    AddComment(R"DOC(
TODO: Documentation of gather_tree op.
)DOC");
  }
};

class GatherTreeOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "Ids");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(gather_tree,
                            GatherTreeInferShapeFunctor,
                            PD_INFER_META(phi::GatherTreeMeta));

class GeluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of gelu op.");
    AddOutput("Out", "(Tensor), output 0 of gelu op.");
    AddAttr<bool>("approximate", "(bool), attribute 0 for gelu op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of gelu op.
)DOC");
  }
};

class GeluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(gelu,
                            GeluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class GridSamplerOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of grid_sampler op.");
    AddInput("Grid", "(Tensor), input 1 of grid_sampler op.");
    AddOutput("Output", "(Tensor), output 0 of grid_sampler op.");
    AddAttr<std::string>("mode",
                         "(std::string), attribute 0 for grid_sampler op.")
        .SetDefault("bilinear");
    AddAttr<std::string>("padding_mode",
                         "(std::string), attribute 1 for grid_sampler op.")
        .SetDefault("zeros");
    AddAttr<bool>("align_corners", "(bool), attribute 2 for grid_sampler op.")
        .SetDefault(true);
    AddComment(R"DOC(
TODO: Documentation of grid_sampler op.
)DOC");
  }
};

class GridSamplerOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(grid_sampler,
                            GridSamplerInferShapeFunctor,
                            PD_INFER_META(phi::GridSampleBaseInferMeta));

class GumbelSoftmaxOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of gumbel_softmax op.");
    AddOutput("Out", "(Tensor), output 0 of gumbel_softmax op.");
    AddAttr<float>("temperature", "(float), attribute 0 for gumbel_softmax op.")
        .SetDefault(1.0);
    AddAttr<bool>("hard", "(bool), attribute 1 for gumbel_softmax op.")
        .SetDefault(false);
    AddAttr<int>("axis", "(int), attribute 2 for gumbel_softmax op.")
        .SetDefault(-1);
    AddComment(R"DOC(
TODO: Documentation of gumbel_softmax op.
)DOC");
  }
};

class GumbelSoftmaxOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(gumbel_softmax,
                            GumbelSoftmaxInferShapeFunctor,
                            PD_INFER_META(phi::GumbelSoftmaxInferMeta));

class HardShrinkOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of hard_shrink op.");
    AddOutput("Out", "(Tensor), output 0 of hard_shrink op.");
    AddAttr<float>("threshold", "(float), attribute 0 for hard_shrink op.")
        .SetDefault(0.5);
    AddComment(R"DOC(
TODO: Documentation of hard_shrink op.
)DOC");
  }
};

class HardShrinkOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(hard_shrink,
                            HardShrinkInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class HardSigmoidOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of hard_sigmoid op.");
    AddOutput("Out", "(Tensor), output 0 of hard_sigmoid op.");
    AddAttr<float>("slope", "(float), attribute 0 for hard_sigmoid op.")
        .SetDefault(0.2);
    AddAttr<float>("offset", "(float), attribute 1 for hard_sigmoid op.")
        .SetDefault(0.5);
    AddComment(R"DOC(
TODO: Documentation of hard_sigmoid op.
)DOC");
  }
};

class HardSigmoidOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(hard_sigmoid,
                            HardSigmoidInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class HistogramOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of histogram op.");
    AddOutput("Out", "(Tensor), output 0 of histogram op.");
    AddAttr<int64_t>("bins", "(int64_t), attribute 0 for histogram op.")
        .SetDefault(100);
    AddAttr<int>("min", "(int), attribute 1 for histogram op.").SetDefault(0);
    AddAttr<int>("max", "(int), attribute 2 for histogram op.").SetDefault(0);
    AddComment(R"DOC(
TODO: Documentation of histogram op.
)DOC");
  }
};

class HistogramOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(histogram,
                            HistogramInferShapeFunctor,
                            PD_INFER_META(phi::HistogramInferMeta));

class IndexSampleOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of index_sample op.");
    AddInput("Index", "(Tensor), input 1 of index_sample op.");
    AddOutput("Out", "(Tensor), output 0 of index_sample op.");
    AddComment(R"DOC(
TODO: Documentation of index_sample op.
)DOC");
  }
};

class IndexSampleOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(index_sample,
                            IndexSampleInferShapeFunctor,
                            PD_INFER_META(phi::IndexSampleInferMeta));

class IndexSelectOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of index_select op.");
    AddInput("Index", "(Tensor), input 1 of index_select op.");
    AddOutput("Out", "(Tensor), output 0 of index_select op.");
    AddAttr<int>("dim", "(int), attribute 0 for index_select op.")
        .SetDefault(0);
    AddComment(R"DOC(
TODO: Documentation of index_select op.
)DOC");
  }
};

class IndexSelectOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(index_select,
                            IndexSelectInferShapeFunctor,
                            PD_INFER_META(phi::IndexSelectInferMeta));

class InverseOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of inverse op.");
    AddOutput("Output", "(Tensor), output 0 of inverse op.");
    AddComment(R"DOC(
TODO: Documentation of inverse op.
)DOC");
  }
};

class InverseOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(inverse,
                            InverseInferShapeFunctor,
                            PD_INFER_META(phi::InverseInferMeta));

class IsEmptyOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of is_empty op.");
    AddOutput("Out", "(Tensor), output 0 of is_empty op.");
    AddComment(R"DOC(
TODO: Documentation of is_empty op.
)DOC");
  }
};

class IsEmptyOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(is_empty,
                            IsEmptyInferShapeFunctor,
                            PD_INFER_META(phi::IsEmptyInferMeta));

class IsfiniteV2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of isfinite_v2 op.");
    AddOutput("Out", "(Tensor), output 0 of isfinite_v2 op.");
    AddComment(R"DOC(
TODO: Documentation of isfinite_v2 op.
)DOC");
  }
};

class IsfiniteV2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(isfinite_v2,
                            IsfiniteV2InferShapeFunctor,
                            PD_INFER_META(phi::IsfiniteInferMeta));

class IsinfV2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of isinf_v2 op.");
    AddOutput("Out", "(Tensor), output 0 of isinf_v2 op.");
    AddComment(R"DOC(
TODO: Documentation of isinf_v2 op.
)DOC");
  }
};

class IsinfV2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(isinf_v2,
                            IsinfV2InferShapeFunctor,
                            PD_INFER_META(phi::IsfiniteInferMeta));

class IsnanV2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of isnan_v2 op.");
    AddOutput("Out", "(Tensor), output 0 of isnan_v2 op.");
    AddComment(R"DOC(
TODO: Documentation of isnan_v2 op.
)DOC");
  }
};

class IsnanV2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(isnan_v2,
                            IsnanV2InferShapeFunctor,
                            PD_INFER_META(phi::IsfiniteInferMeta));

class KthvalueOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of kthvalue op.");
    AddOutput("Out", "(Tensor), output 0 of kthvalue op.");
    AddOutput("Indices", "(Tensor), output 1 of kthvalue op.");
    AddAttr<int>("k", "(int), attribute 0 for kthvalue op.").SetDefault(1);
    AddAttr<int>("axis", "(int), attribute 1 for kthvalue op.").SetDefault(-1);
    AddAttr<bool>("keepdim", "(bool), attribute 2 for kthvalue op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of kthvalue op.
)DOC");
  }
};

class KthvalueOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(kthvalue,
                            KthvalueInferShapeFunctor,
                            PD_INFER_META(phi::KthvalueInferMeta));

class LabelSmoothOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of label_smooth op.");
    AddInput("PriorDist", "(Tensor), input 1 of label_smooth op.")
        .AsDispensable();
    AddOutput("Out", "(Tensor), output 0 of label_smooth op.");
    AddAttr<float>("epsilon", "(float), attribute 0 for label_smooth op.")
        .SetDefault(0.0f);
    AddComment(R"DOC(
TODO: Documentation of label_smooth op.
)DOC");
  }
};

class LabelSmoothOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(label_smooth,
                            LabelSmoothInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class LeakyReluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of leaky_relu op.");
    AddOutput("Out", "(Tensor), output 0 of leaky_relu op.");
    AddAttr<float>("alpha", "(float), attribute 0 for leaky_relu op.")
        .SetDefault(0.02f);
    AddComment(R"DOC(
TODO: Documentation of leaky_relu op.
)DOC");
  }
};

class LeakyReluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(leaky_relu,
                            LeakyReluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class LerpOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of lerp op.");
    AddInput("Y", "(Tensor), input 1 of lerp op.");
    AddInput("Weight", "(Tensor), input 2 of lerp op.");
    AddOutput("Out", "(Tensor), output 0 of lerp op.");
    AddComment(R"DOC(
TODO: Documentation of lerp op.
)DOC");
  }
};

class LerpOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(lerp,
                            LerpInferShapeFunctor,
                            PD_INFER_META(phi::LerpInferMeta));
DECLARE_INPLACE_OP_INFERER(LerpInplaceInferer, {"X", "Out"});

class LgammaOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of lgamma op.");
    AddOutput("Out", "(Tensor), output 0 of lgamma op.");
    AddComment(R"DOC(
TODO: Documentation of lgamma op.
)DOC");
  }
};

class LgammaOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(lgamma,
                            LgammaInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class LogOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of log op.");
    AddOutput("Out", "(Tensor), output 0 of log op.");
    AddComment(R"DOC(
TODO: Documentation of log op.
)DOC");
  }
};

class LogOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log,
                            LogInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class Log10OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of log10 op.");
    AddOutput("Out", "(Tensor), output 0 of log10 op.");
    AddComment(R"DOC(
TODO: Documentation of log10 op.
)DOC");
  }
};

class Log10Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log10,
                            Log10InferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class Log1pOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of log1p op.");
    AddOutput("Out", "(Tensor), output 0 of log1p op.");
    AddComment(R"DOC(
TODO: Documentation of log1p op.
)DOC");
  }
};

class Log1pOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log1p,
                            Log1pInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class Log2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of log2 op.");
    AddOutput("Out", "(Tensor), output 0 of log2 op.");
    AddComment(R"DOC(
TODO: Documentation of log2 op.
)DOC");
  }
};

class Log2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log2,
                            Log2InferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class LogLossOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Predicted", "(Tensor), input 0 of log_loss op.");
    AddInput("Labels", "(Tensor), input 1 of log_loss op.");
    AddOutput("Loss", "(Tensor), output 0 of log_loss op.");
    AddAttr<float>("epsilon", "(float), attribute 0 for log_loss op.");
    AddComment(R"DOC(
TODO: Documentation of log_loss op.
)DOC");
  }
};

class LogLossOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log_loss,
                            LogLossInferShapeFunctor,
                            PD_INFER_META(phi::LogLossInferMeta));

class LogitOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of logit op.");
    AddOutput("Out", "(Tensor), output 0 of logit op.");
    AddAttr<float>("eps", "(float), attribute 0 for logit op.")
        .SetDefault(1e-6f);
    AddComment(R"DOC(
TODO: Documentation of logit op.
)DOC");
  }
};

class LogitOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(logit,
                            LogitInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class LogsigmoidOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of logsigmoid op.");
    AddOutput("Out", "(Tensor), output 0 of logsigmoid op.");
    AddComment(R"DOC(
TODO: Documentation of logsigmoid op.
)DOC");
  }
};

class LogsigmoidOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(logsigmoid,
                            LogsigmoidInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class LuUnpackOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of lu_unpack op.");
    AddInput("Pivots", "(Tensor), input 1 of lu_unpack op.");
    AddOutput("Pmat", "(Tensor), output 0 of lu_unpack op.");
    AddOutput("L", "(Tensor), output 1 of lu_unpack op.");
    AddOutput("U", "(Tensor), output 2 of lu_unpack op.");
    AddAttr<bool>("unpack_ludata", "(bool), attribute 0 for lu_unpack op.")
        .SetDefault(true);
    AddAttr<bool>("unpack_pivots", "(bool), attribute 1 for lu_unpack op.")
        .SetDefault(true);
    AddComment(R"DOC(
TODO: Documentation of lu_unpack op.
)DOC");
  }
};

class LuUnpackOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(lu_unpack,
                            LuUnpackInferShapeFunctor,
                            PD_INFER_META(phi::LUUnpackInferMeta));

class MaskedSelectOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of masked_select op.");
    AddInput("Mask", "(Tensor), input 1 of masked_select op.");
    AddOutput("Y", "(Tensor), output 0 of masked_select op.");
    AddComment(R"DOC(
TODO: Documentation of masked_select op.
)DOC");
  }
};

class MaskedSelectOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(masked_select,
                            MaskedSelectInferShapeFunctor,
                            PD_INFER_META(phi::MaskedSelectInferMeta));

class MatrixPowerOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of matrix_power op.");
    AddOutput("Out", "(Tensor), output 0 of matrix_power op.");
    AddAttr<int>("n", "(int), attribute 0 for matrix_power op.");
    AddComment(R"DOC(
TODO: Documentation of matrix_power op.
)DOC");
  }
};

class MatrixPowerOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(matrix_power,
                            MatrixPowerInferShapeFunctor,
                            PD_INFER_META(phi::MatrixPowerInferMeta));

class MaxoutOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of maxout op.");
    AddOutput("Out", "(Tensor), output 0 of maxout op.");
    AddAttr<int>("groups", "(int), attribute 0 for maxout op.");
    AddAttr<int>("axis", "(int), attribute 1 for maxout op.").SetDefault(1);
    AddComment(R"DOC(
TODO: Documentation of maxout op.
)DOC");
  }
};

class MaxoutOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(maxout,
                            MaxoutInferShapeFunctor,
                            PD_INFER_META(phi::MaxOutInferMeta));

class ModeOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of mode op.");
    AddOutput("Out", "(Tensor), output 0 of mode op.");
    AddOutput("Indices", "(Tensor), output 1 of mode op.");
    AddAttr<int>("axis", "(int), attribute 0 for mode op.").SetDefault(-1);
    AddAttr<bool>("keepdim", "(bool), attribute 1 for mode op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of mode op.
)DOC");
  }
};

class ModeOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(mode,
                            ModeInferShapeFunctor,
                            PD_INFER_META(phi::ModeInferMeta));

class MultinomialOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of multinomial op.");
    AddOutput("Out", "(Tensor), output 0 of multinomial op.");
    AddAttr<int>("num_samples", "(int), attribute 0 for multinomial op.")
        .SetDefault(1)
        .SupportTensor();
    AddAttr<bool>("replacement", "(bool), attribute 1 for multinomial op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of multinomial op.
)DOC");
  }
};

class MultinomialOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(multinomial,
                            MultinomialInferShapeFunctor,
                            PD_INFER_META(phi::MultinomialInferMeta));

class MvOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of mv op.");
    AddInput("Vec", "(Tensor), input 1 of mv op.");
    AddOutput("Out", "(Tensor), output 0 of mv op.");
    AddComment(R"DOC(
TODO: Documentation of mv op.
)DOC");
  }
};

class MvOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(mv,
                            MvInferShapeFunctor,
                            PD_INFER_META(phi::MvInferMeta));

class NllLossOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of nll_loss op.");
    AddInput("Label", "(Tensor), input 1 of nll_loss op.");
    AddInput("Weight", "(Tensor), input 2 of nll_loss op.").AsDispensable();
    AddOutput("Out", "(Tensor), output 0 of nll_loss op.");
    AddOutput("Total_weight", "(Tensor), output 1 of nll_loss op.");
    AddAttr<int64_t>("ignore_index", "(int64_t), attribute 0 for nll_loss op.")
        .SetDefault(-100);
    AddAttr<std::string>("reduction",
                         "(std::string), attribute 1 for nll_loss op.")
        .SetDefault("mean");
    AddComment(R"DOC(
TODO: Documentation of nll_loss op.
)DOC");
  }
};

class NllLossOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(nll_loss,
                            NllLossInferShapeFunctor,
                            PD_INFER_META(phi::NllLossRawInferMeta));

class NpuIdentityOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of npu_identity op.");
    AddOutput("out", "(Tensor), output 0 of npu_identity op.");
    AddAttr<int>("format", "(int), attribute 0 for npu_identity op.")
        .SetDefault(-1);
    AddComment(R"DOC(
TODO: Documentation of npu_identity op.
)DOC");
  }
};

class NpuIdentityOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(npu_identity,
                            NpuIdentityInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class PoissonOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of poisson op.");
    AddOutput("Out", "(Tensor), output 0 of poisson op.");
    AddComment(R"DOC(
TODO: Documentation of poisson op.
)DOC");
  }
};

class PoissonOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(poisson,
                            PoissonInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class PutAlongAxisOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of put_along_axis op.");
    AddInput("Index", "(Tensor), input 1 of put_along_axis op.");
    AddInput("Value", "(Tensor), input 2 of put_along_axis op.");
    AddOutput("Result", "(Tensor), output 0 of put_along_axis op.");
    AddAttr<int>("Axis", "(int), attribute 0 for put_along_axis op.");
    AddAttr<std::string>("Reduce",
                         "(std::string), attribute 1 for put_along_axis op.")
        .SetDefault("assign");
    AddComment(R"DOC(
TODO: Documentation of put_along_axis op.
)DOC");
  }
};

class PutAlongAxisOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "Input");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(put_along_axis,
                            PutAlongAxisInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(PutAlongAxisInplaceInferer, {"Input", "Result"});

class QrOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of qr op.");
    AddOutput("Q", "(Tensor), output 0 of qr op.");
    AddOutput("R", "(Tensor), output 1 of qr op.");
    AddAttr<std::string>("mode", "(std::string), attribute 0 for qr op.")
        .SetDefault("reduced");
    AddComment(R"DOC(
TODO: Documentation of qr op.
)DOC");
  }
};

class QrOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(qr,
                            QrInferShapeFunctor,
                            PD_INFER_META(phi::QrInferMeta));

class ReciprocalOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of reciprocal op.");
    AddOutput("Out", "(Tensor), output 0 of reciprocal op.");
    AddComment(R"DOC(
TODO: Documentation of reciprocal op.
)DOC");
  }
};

class ReciprocalOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(reciprocal,
                            ReciprocalInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ReciprocalInplaceInferer, {"X", "Out"});

class ReluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of relu op.");
    AddOutput("Out", "(Tensor), output 0 of relu op.");
    AddComment(R"DOC(
TODO: Documentation of relu op.
)DOC");
  }
};

class ReluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(relu,
                            ReluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ReluInplaceInferer, {"X", "Out"});

class RenormOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of renorm op.");
    AddOutput("Out", "(Tensor), output 0 of renorm op.");
    AddAttr<float>("p", "(float), attribute 0 for renorm op.");
    AddAttr<int>("axis", "(int), attribute 1 for renorm op.");
    AddAttr<float>("max_norm", "(float), attribute 2 for renorm op.");
    AddComment(R"DOC(
TODO: Documentation of renorm op.
)DOC");
  }
};

class RenormOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(renorm,
                            RenormInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class RoundOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of round op.");
    AddOutput("Out", "(Tensor), output 0 of round op.");
    AddComment(R"DOC(
TODO: Documentation of round op.
)DOC");
  }
};

class RoundOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(round,
                            RoundInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(RoundInplaceInferer, {"X", "Out"});

class RsqrtOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of rsqrt op.");
    AddOutput("Out", "(Tensor), output 0 of rsqrt op.");
    AddComment(R"DOC(
TODO: Documentation of rsqrt op.
)DOC");
  }
};

class RsqrtOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(rsqrt,
                            RsqrtInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(RsqrtInplaceInferer, {"X", "Out"});

class SearchsortedOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("SortedSequence", "(Tensor), input 0 of searchsorted op.");
    AddInput("Values", "(Tensor), input 1 of searchsorted op.");
    AddOutput("Out", "(Tensor), output 0 of searchsorted op.");
    AddAttr<bool>("out_int32", "(bool), attribute 0 for searchsorted op.")
        .SetDefault(false);
    AddAttr<bool>("right", "(bool), attribute 1 for searchsorted op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of searchsorted op.
)DOC");
  }
};

class SearchsortedOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, "SortedSequence");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(searchsorted,
                            SearchsortedInferShapeFunctor,
                            PD_INFER_META(phi::SearchsortedInferMeta));

class GraphSendUvOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of graph_send_uv op.");
    AddInput("y", "(Tensor), input 1 of graph_send_uv op.");
    AddInput("src_index", "(Tensor), input 2 of graph_send_uv op.");
    AddInput("dst_index", "(Tensor), input 3 of graph_send_uv op.");
    AddOutput("out", "(Tensor), output 0 of graph_send_uv op.");
    AddAttr<std::string>("message_op",
                         "(std::string), attribute 0 for graph_send_uv op.")
        .SetDefault("ADD");
    AddComment(R"DOC(
TODO: Documentation of graph_send_uv op.
)DOC");
  }
};

class GraphSendUvOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "x");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(graph_send_uv,
                            GraphSendUvInferShapeFunctor,
                            PD_INFER_META(phi::SendUVInferMeta));

class SigmoidOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of sigmoid op.");
    AddOutput("Out", "(Tensor), output 0 of sigmoid op.");
    AddComment(R"DOC(
TODO: Documentation of sigmoid op.
)DOC");
  }
};

class SigmoidOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sigmoid,
                            SigmoidInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SiluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of silu op.");
    AddOutput("Out", "(Tensor), output 0 of silu op.");
    AddComment(R"DOC(
TODO: Documentation of silu op.
)DOC");
  }
};

class SiluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(silu,
                            SiluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SinOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of sin op.");
    AddOutput("Out", "(Tensor), output 0 of sin op.");
    AddComment(R"DOC(
TODO: Documentation of sin op.
)DOC");
  }
};

class SinOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sin,
                            SinInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SinhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of sinh op.");
    AddOutput("Out", "(Tensor), output 0 of sinh op.");
    AddComment(R"DOC(
TODO: Documentation of sinh op.
)DOC");
  }
};

class SinhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sinh,
                            SinhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SoftplusOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of softplus op.");
    AddOutput("Out", "(Tensor), output 0 of softplus op.");
    AddAttr<float>("beta", "(float), attribute 0 for softplus op.")
        .SetDefault(1.0);
    AddAttr<float>("threshold", "(float), attribute 1 for softplus op.")
        .SetDefault(20.0f);
    AddComment(R"DOC(
TODO: Documentation of softplus op.
)DOC");
  }
};

class SoftplusOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(softplus,
                            SoftplusInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SoftshrinkOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of softshrink op.");
    AddOutput("Out", "(Tensor), output 0 of softshrink op.");
    AddAttr<float>("lambda", "(float), attribute 0 for softshrink op.")
        .SetDefault(0.5);
    AddComment(R"DOC(
TODO: Documentation of softshrink op.
)DOC");
  }
};

class SoftshrinkOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(softshrink,
                            SoftshrinkInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SoftsignOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of softsign op.");
    AddOutput("Out", "(Tensor), output 0 of softsign op.");
    AddComment(R"DOC(
TODO: Documentation of softsign op.
)DOC");
  }
};

class SoftsignOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(softsign,
                            SoftsignInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SolveOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of solve op.");
    AddInput("Y", "(Tensor), input 1 of solve op.");
    AddOutput("Out", "(Tensor), output 0 of solve op.");
    AddComment(R"DOC(
TODO: Documentation of solve op.
)DOC");
  }
};

class SolveOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(solve,
                            SolveInferShapeFunctor,
                            PD_INFER_META(phi::SolveInferMeta));

class SqrtOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of sqrt op.");
    AddOutput("Out", "(Tensor), output 0 of sqrt op.");
    AddComment(R"DOC(
TODO: Documentation of sqrt op.
)DOC");
  }
};

class SqrtOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sqrt,
                            SqrtInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SqrtInplaceInferer, {"X", "Out"});

class SquareOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of square op.");
    AddOutput("Out", "(Tensor), output 0 of square op.");
    AddComment(R"DOC(
TODO: Documentation of square op.
)DOC");
  }
};

class SquareOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(square,
                            SquareInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class SvdOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of svd op.");
    AddOutput("U", "(Tensor), output 0 of svd op.");
    AddOutput("S", "(Tensor), output 1 of svd op.");
    AddOutput("VH", "(Tensor), output 2 of svd op.");
    AddAttr<bool>("full_matrices", "(bool), attribute 0 for svd op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of svd op.
)DOC");
  }
};

class SvdOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(svd,
                            SvdInferShapeFunctor,
                            PD_INFER_META(phi::SvdInferMeta));

class TakeAlongAxisOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of take_along_axis op.");
    AddInput("Index", "(Tensor), input 1 of take_along_axis op.");
    AddOutput("Result", "(Tensor), output 0 of take_along_axis op.");
    AddAttr<int>("Axis", "(int), attribute 0 for take_along_axis op.");
    AddComment(R"DOC(
TODO: Documentation of take_along_axis op.
)DOC");
  }
};

class TakeAlongAxisOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "Input");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(take_along_axis,
                            TakeAlongAxisInferShapeFunctor,
                            PD_INFER_META(phi::TakeAlongAxisInferMeta));

class TanOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of tan op.");
    AddOutput("Out", "(Tensor), output 0 of tan op.");
    AddComment(R"DOC(
TODO: Documentation of tan op.
)DOC");
  }
};

class TanOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tan,
                            TanInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class TanhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of tanh op.");
    AddOutput("Out", "(Tensor), output 0 of tanh op.");
    AddComment(R"DOC(
TODO: Documentation of tanh op.
)DOC");
  }
};

class TanhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tanh,
                            TanhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(TanhInplaceInferer, {"X", "Out"});

class TanhShrinkOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of tanh_shrink op.");
    AddOutput("Out", "(Tensor), output 0 of tanh_shrink op.");
    AddComment(R"DOC(
TODO: Documentation of tanh_shrink op.
)DOC");
  }
};

class TanhShrinkOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tanh_shrink,
                            TanhShrinkInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class ThresholdedReluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of thresholded_relu op.");
    AddOutput("Out", "(Tensor), output 0 of thresholded_relu op.");
    AddAttr<float>("threshold", "(float), attribute 0 for thresholded_relu op.")
        .SetDefault(1.0);
    AddComment(R"DOC(
TODO: Documentation of thresholded_relu op.
)DOC");
  }
};

class ThresholdedReluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(thresholded_relu,
                            ThresholdedReluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class TopKV2OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of top_k_v2 op.");
    AddOutput("Out", "(Tensor), output 0 of top_k_v2 op.");
    AddOutput("Indices", "(Tensor), output 1 of top_k_v2 op.");
    AddInput("K", "attribute 0 for top_k_v2 op from 0D Tensor.")
        .AsDispensable();
    AddAttr<int>("k", "(int), attribute 0 for top_k_v2 op.").SetDefault(1);
    AddAttr<int>("axis", "(int), attribute 1 for top_k_v2 op.").SetDefault(-1);
    AddAttr<bool>("largest", "(bool), attribute 2 for top_k_v2 op.")
        .SetDefault(true);
    AddAttr<bool>("sorted", "(bool), attribute 3 for top_k_v2 op.")
        .SetDefault(true);
    AddComment(R"DOC(
TODO: Documentation of top_k_v2 op.
)DOC");
  }
};

class TopKV2Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(top_k_v2,
                            TopKV2InferShapeFunctor,
                            PD_INFER_META(phi::TopKInferMeta));

class TraceOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("Input", "(Tensor), input 0 of trace op.");
    AddOutput("Out", "(Tensor), output 0 of trace op.");
    AddAttr<int>("offset", "(int), attribute 0 for trace op.").SetDefault(0);
    AddAttr<int>("axis1", "(int), attribute 1 for trace op.").SetDefault(0);
    AddAttr<int>("axis2", "(int), attribute 2 for trace op.").SetDefault(1);
    AddComment(R"DOC(
TODO: Documentation of trace op.
)DOC");
  }
};

class TraceOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(trace,
                            TraceInferShapeFunctor,
                            PD_INFER_META(phi::TraceInferMeta));

class TruncOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of trunc op.");
    AddOutput("Out", "(Tensor), output 0 of trunc op.");
    AddComment(R"DOC(
TODO: Documentation of trunc op.
)DOC");
  }
};

class TruncOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(trunc,
                            TruncInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

class UnfoldOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("X", "(Tensor), input 0 of unfold op.");
    AddOutput("Y", "(Tensor), output 0 of unfold op.");
    AddAttr<std::vector<int>>("kernel_sizes",
                              "(std::vector<int>), attribute 0 for unfold op.");
    AddAttr<std::vector<int>>("strides",
                              "(std::vector<int>), attribute 1 for unfold op.");
    AddAttr<std::vector<int>>("paddings",
                              "(std::vector<int>), attribute 2 for unfold op.");
    AddAttr<std::vector<int>>("dilations",
                              "(std::vector<int>), attribute 3 for unfold op.");
    AddComment(R"DOC(
TODO: Documentation of unfold op.
)DOC");
  }
};

class UnfoldOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(unfold,
                            UnfoldInferShapeFunctor,
                            PD_INFER_META(phi::UnfoldInferMeta));

template <typename T>
class AcosGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("acos_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AcosGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(acos_grad,
                            AcosGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(AcosGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class AcoshGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("acosh_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AcoshGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(acosh_grad,
                            AcoshGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(AcoshGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class AngleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("angle_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AngleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(angle_grad,
                            AngleGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class ArgsortGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("argsort_grad");

    grad_op->SetInput("Indices", this->Output("Indices"));
    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ArgsortGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(argsort_grad,
                            ArgsortGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(ArgsortGradNoNeedBufferVarInferer, "X");

template <typename T>
class AsComplexGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("as_real");

    grad_op->SetInput("X", this->OutputGrad("Out"));

    grad_op->SetOutput("Out", this->InputGrad("X"));
  }
};

template <typename T>
class AsRealGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("as_complex");

    grad_op->SetInput("X", this->OutputGrad("Out"));

    grad_op->SetOutput("Out", this->InputGrad("X"));
  }
};

template <typename T>
class AsinGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("asin_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AsinGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(asin_grad,
                            AsinGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(AsinGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class AsinhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("asinh_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AsinhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(asinh_grad,
                            AsinhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(AsinhGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class Atan2GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("atan2_grad");

    grad_op->SetInput("X1", this->Input("X1"));
    grad_op->SetInput("X2", this->Input("X2"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X1"), this->InputGrad("X1"));
    grad_op->SetOutput(GradVarName("X2"), this->InputGrad("X2"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class Atan2GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(atan2_grad,
                            Atan2GradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class AtanGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("atan_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AtanGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(atan_grad,
                            AtanGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(AtanGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class AtanhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("atanh_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class AtanhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(atanh_grad,
                            AtanhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(AtanhGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class BmmGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("bmm_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class BmmGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(bmm_grad,
                            BmmGradInferShapeFunctor,
                            PD_INFER_META(phi::BmmGradInferMeta));

template <typename T>
class CeilGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("ceil_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CeilGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(ceil_grad,
                            CeilGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(CeilGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class CeluGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("celu_grad_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CeluGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(celu_grad_grad,
                            CeluGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(CeluGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class CeluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("celu_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CeluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(celu_grad,
                            CeluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(CeluGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class CholeskyGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cholesky_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CholeskyGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cholesky_grad,
                            CholeskyGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class CholeskySolveGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cholesky_solve_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CholeskySolveGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cholesky_solve_grad,
                            CholeskySolveGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class ConjGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("conj");

    grad_op->SetInput("X", this->OutputGrad("Out"));

    grad_op->SetOutput("Out", this->InputGrad("X"));
  }
};

template <typename T>
class CosDoubleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cos_double_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CosDoubleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cos_double_grad,
                            CosDoubleGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(CosDoubleGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class CosGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cos_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CosGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cos_grad,
                            CosGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(CosGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class CosTripleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cos_triple_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("grad_out_forward", this->Input("grad_out"));
    grad_op->SetInput("grad_x_grad_forward",
                      this->Input(GradVarName("grad_x")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("x")));
    grad_op->SetInput(GradVarName("grad_out_grad"),
                      this->OutputGrad(GradVarName("grad_out")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x"));
    grad_op->SetOutput(GradVarName("grad_out_forward"),
                       this->InputGrad("grad_out"));
    grad_op->SetOutput(GradVarName("grad_x_grad_forward"),
                       this->InputGrad(GradVarName("grad_x")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CosTripleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cos_triple_grad,
                            CosTripleGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(CosTripleGradInplaceInferer,
                           {"grad_x_grad_forward",
                            GradVarName("grad_out_forward")});

template <typename T>
class CoshGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cosh_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CoshGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(cosh_grad,
                            CoshGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(CoshGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class CropTensorGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("crop_tensor_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
    if (this->HasInput("Offsets")) {
      grad_op->SetInput("Offsets", this->Input("Offsets"));
    }
    if (this->HasInput("OffsetsTensor")) {
      grad_op->SetInput("OffsetsTensor", this->Input("OffsetsTensor"));
    }
  }
};

class CropTensorGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(crop_tensor_grad,
                            CropTensorGradInferShapeFunctor,
                            PD_INFER_META(phi::CropGradInferMeta));

template <typename T>
class CrossGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("cross_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class CrossGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(cross_grad,
                            CrossGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class DeterminantGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("determinant_grad");

    grad_op->SetInput("Input", this->Input("Input"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("Input"), this->InputGrad("Input"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class DeterminantGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(determinant_grad,
                            DeterminantGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class DiagV2GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("diag_v2_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class DiagV2GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(diag_v2_grad,
                            DiagV2GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(DiagV2GradNoNeedBufferVarInferer, "X");

template <typename T>
class DiagonalGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("diagonal_grad");

    grad_op->SetInput("Input", this->Input("Input"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("Input"), this->InputGrad("Input"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class DiagonalGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(diagonal_grad,
                            DiagonalGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(DiagonalGradNoNeedBufferVarInferer,
                                    "Input");

template <typename T>
class DigammaGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("digamma_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class DigammaGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(digamma_grad,
                            DigammaGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class DistGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("dist_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class DistGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(dist_grad,
                            DistGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class DotGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("dot_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class DotGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(dot_grad,
                            DotGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class EigGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("eig_grad");

    grad_op->SetInput("Eigenvalues", this->Output("Eigenvalues"));
    grad_op->SetInput("Eigenvectors", this->Output("Eigenvectors"));
    grad_op->SetInput(GradVarName("Eigenvalues"),
                      this->OutputGrad("Eigenvalues"));
    grad_op->SetInput(GradVarName("Eigenvectors"),
                      this->OutputGrad("Eigenvectors"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class EigGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "Eigenvectors");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(eig_grad,
                            EigGradInferShapeFunctor,
                            PD_INFER_META(phi::EigGradInferMeta));

template <typename T>
class EighGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("eigh_grad");

    grad_op->SetInput("Eigenvalues", this->Output("Eigenvalues"));
    grad_op->SetInput("Eigenvectors", this->Output("Eigenvectors"));
    grad_op->SetInput(GradVarName("Eigenvalues"),
                      this->OutputGrad("Eigenvalues"));
    grad_op->SetInput(GradVarName("Eigenvectors"),
                      this->OutputGrad("Eigenvectors"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class EighGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "Eigenvectors");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(eigh_grad,
                            EighGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class EluGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("elu_grad_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class EluGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(elu_grad_grad,
                            EluGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(EluGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class EluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("elu_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class EluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(elu_grad,
                            EluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(EluGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class ErfGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("erf_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ErfGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(erf_grad,
                            ErfGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class ErfinvGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("erfinv_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ErfinvGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(erfinv_grad,
                            ErfinvGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class ExpGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("exp_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ExpGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(exp_grad,
                            ExpGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ExpGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class Expm1GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("expm1_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class Expm1GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(expm1_grad,
                            Expm1GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(Expm1GradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class FftC2cGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("fft_c2c_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class FftC2cGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(fft_c2c_grad,
                            FftC2cGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class FftC2rGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("fft_c2r_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class FftC2rGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(fft_c2r_grad,
                            FftC2rGradInferShapeFunctor,
                            PD_INFER_META(phi::FFTC2RGradInferMeta));

template <typename T>
class FftR2cGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("fft_r2c_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class FftR2cGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(fft_r2c_grad,
                            FftR2cGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(FftR2cGradNoNeedBufferVarInferer, "X");

template <typename T>
class FillDiagonalTensorGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("fill_diagonal_tensor_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class FillDiagonalTensorGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(
    fill_diagonal_tensor_grad,
    FillDiagonalTensorGradInferShapeFunctor,
    PD_INFER_META(phi::FillDiagonalTensorGradInferMeta));
DECLARE_INPLACE_OP_INFERER(FillDiagonalTensorGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class FlipGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("flip");

    grad_op->SetInput("X", this->OutputGrad("Out"));

    grad_op->SetOutput("Out", this->InputGrad("X"));

    grad_op->SetAttr("axis", this->GetAttr("axis"));
  }
};

template <typename T>
class FloorGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("floor_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class FloorGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(floor_grad,
                            FloorGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(FloorGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class FoldGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("fold_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Y"), this->OutputGrad("Y"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class FoldGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Y"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(fold_grad,
                            FoldGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(FoldGradNoNeedBufferVarInferer, "X");

template <typename T>
class GeluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("gelu_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class GeluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(gelu_grad,
                            GeluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class GridSamplerGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("grid_sampler_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Grid", this->Input("Grid"));
    grad_op->SetInput(GradVarName("Output"), this->OutputGrad("Output"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Grid"), this->InputGrad("Grid"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class GridSamplerGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(grid_sampler_grad,
                            GridSamplerGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class GumbelSoftmaxGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("gumbel_softmax_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class GumbelSoftmaxGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(gumbel_softmax_grad,
                            GumbelSoftmaxGradInferShapeFunctor,
                            PD_INFER_META(phi::GumbelSoftmaxGradInferMeta));

template <typename T>
class HardShrinkGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("hard_shrink_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class HardShrinkGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(hard_shrink_grad,
                            HardShrinkGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(HardShrinkGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class HardSigmoidGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("hard_sigmoid_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class HardSigmoidGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(hard_sigmoid_grad,
                            HardSigmoidGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(HardSigmoidGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class IndexSampleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("index_sample_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Index", this->Input("Index"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class IndexSampleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(index_sample_grad,
                            IndexSampleGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(IndexSampleGradNoNeedBufferVarInferer, "X");

template <typename T>
class IndexSelectGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("index_select_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Index", this->Input("Index"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class IndexSelectGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(index_select_grad,
                            IndexSelectGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(IndexSelectGradNoNeedBufferVarInferer, "X");

template <typename T>
class InverseGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("inverse_grad");

    grad_op->SetInput("Output", this->Output("Output"));
    grad_op->SetInput(GradVarName("Output"), this->OutputGrad("Output"));

    grad_op->SetOutput(GradVarName("Input"), this->InputGrad("Input"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class InverseGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(inverse_grad,
                            InverseGradInferShapeFunctor,
                            PD_INFER_META(phi::InverseGradInferMeta));

template <typename T>
class KthvalueGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("kthvalue_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Indices", this->Output("Indices"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class KthvalueGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(kthvalue_grad,
                            KthvalueGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class LabelSmoothGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("label_smooth_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LabelSmoothGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(label_smooth_grad,
                            LabelSmoothGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class LeakyReluGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("leaky_relu_grad_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LeakyReluGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(leaky_relu_grad_grad,
                            LeakyReluGradGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(LeakyReluGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class LeakyReluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("leaky_relu_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LeakyReluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(leaky_relu_grad,
                            LeakyReluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(LeakyReluGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class LerpGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("lerp_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput("Weight", this->Input("Weight"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LerpGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(lerp_grad,
                            LerpGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class LgammaGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("lgamma_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LgammaGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(lgamma_grad,
                            LgammaGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class Log10GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("log10_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class Log10GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log10_grad,
                            Log10GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(Log10GradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class Log1pGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("log1p_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class Log1pGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log1p_grad,
                            Log1pGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(Log1pGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class Log2GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("log2_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class Log2GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log2_grad,
                            Log2GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(Log2GradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class LogGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("log_grad_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LogGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log_grad_grad,
                            LogGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(LogGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class LogGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("log_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LogGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log_grad,
                            LogGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(LogGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class LogLossGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("log_loss_grad");

    grad_op->SetInput("Predicted", this->Input("Predicted"));
    grad_op->SetInput("Labels", this->Input("Labels"));
    grad_op->SetInput(GradVarName("Loss"), this->OutputGrad("Loss"));

    grad_op->SetOutput(GradVarName("Predicted"), this->InputGrad("Predicted"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LogLossGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(log_loss_grad,
                            LogLossGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class LogitGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("logit_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LogitGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(logit_grad,
                            LogitGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class LogsigmoidGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("logsigmoid_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LogsigmoidGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(logsigmoid_grad,
                            LogsigmoidGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(LogsigmoidGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class LuUnpackGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("lu_unpack_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Pivots", this->Input("Pivots"));
    grad_op->SetInput("L", this->Output("L"));
    grad_op->SetInput("U", this->Output("U"));
    grad_op->SetInput("Pmat", this->Output("Pmat"));
    grad_op->SetInput(GradVarName("L"), this->OutputGrad("L"));
    grad_op->SetInput(GradVarName("U"), this->OutputGrad("U"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class LuUnpackGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(lu_unpack_grad,
                            LuUnpackGradInferShapeFunctor,
                            PD_INFER_META(phi::LUUnpackGradInferMeta));

template <typename T>
class MaskedSelectGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("masked_select_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Mask", this->Input("Mask"));
    grad_op->SetInput(GradVarName("Y"), this->OutputGrad("Y"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class MaskedSelectGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(masked_select_grad,
                            MaskedSelectGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(MaskedSelectGradNoNeedBufferVarInferer,
                                    "X");

template <typename T>
class MatrixPowerGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("matrix_power_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class MatrixPowerGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(matrix_power_grad,
                            MatrixPowerGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class MaxoutGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("maxout_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class MaxoutGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(maxout_grad,
                            MaxoutGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralUnaryGradInferMeta));

template <typename T>
class ModeGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("mode_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Indices", this->Output("Indices"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ModeGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(mode_grad,
                            ModeGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class MvGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("mv_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Vec", this->Input("Vec"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Vec"), this->InputGrad("Vec"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class MvGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(mv_grad,
                            MvGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class NllLossGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("nll_loss_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Label", this->Input("Label"));
    grad_op->SetInput("Weight", this->Input("Weight"));
    grad_op->SetInput("Total_weight", this->Output("Total_weight"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class NllLossGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "X");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(nll_loss_grad,
                            NllLossGradInferShapeFunctor,
                            PD_INFER_META(phi::NllLossGradInferMeta));

template <typename T>
class PoissonGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("poisson_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class PoissonGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(poisson_grad,
                            PoissonGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class PutAlongAxisGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("put_along_axis_grad");

    grad_op->SetInput("Input", this->Input("Input"));
    grad_op->SetInput("Index", this->Input("Index"));
    grad_op->SetInput(GradVarName("Result"), this->OutputGrad("Result"));

    grad_op->SetOutput(GradVarName("Input"), this->InputGrad("Input"));
    grad_op->SetOutput(GradVarName("value"), this->InputGrad("Value"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class PutAlongAxisGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(put_along_axis_grad,
                            PutAlongAxisGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class QrGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("qr_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Q", this->Output("Q"));
    grad_op->SetInput("R", this->Output("R"));
    grad_op->SetInput(GradVarName("Q"), this->OutputGrad("Q"));
    grad_op->SetInput(GradVarName("R"), this->OutputGrad("R"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class QrGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(qr_grad,
                            QrGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class ReciprocalGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("reciprocal_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ReciprocalGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(reciprocal_grad,
                            ReciprocalGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ReciprocalGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class ReluGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("relu_grad_grad");

    grad_op->SetInput("out", this->Input("Out"));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ReluGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(relu_grad_grad,
                            ReluGradGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ReluGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class ReluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("relu_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ReluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(relu_grad,
                            ReluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ReluGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class RenormGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("renorm_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class RenormGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(renorm_grad,
                            RenormGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class RoundGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("round_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class RoundGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(round_grad,
                            RoundGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(RoundGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class RsqrtGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("rsqrt_grad_grad");

    grad_op->SetInput("out", this->Input("Out"));
    grad_op->SetInput("grad_x", this->Output(GradVarName("X")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("out"), this->InputGrad("Out"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class RsqrtGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(rsqrt_grad_grad,
                            RsqrtGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(RsqrtGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class RsqrtGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("rsqrt_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class RsqrtGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(rsqrt_grad,
                            RsqrtGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(RsqrtGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class GraphSendUvGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("graph_send_uv_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput("src_index", this->Input("src_index"));
    grad_op->SetInput("dst_index", this->Input("dst_index"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x"));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class GraphSendUvGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type =
        framework::OperatorWithKernel::IndicateVarDataType(ctx, "x");
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(graph_send_uv_grad,
                            GraphSendUvGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class SigmoidGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sigmoid_grad_grad");

    grad_op->SetInput("out", this->Input("Out"));
    grad_op->SetInput("fwd_grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("out"), this->InputGrad("Out"));
    grad_op->SetOutput(GradVarName("fwd_grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SigmoidGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sigmoid_grad_grad,
                            SigmoidGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(SigmoidGradGradInplaceInferer,
                           {GradVarName("grad_x"),
                            GradVarName("fwd_grad_out")});

template <typename T>
class SigmoidGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sigmoid_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SigmoidGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sigmoid_grad,
                            SigmoidGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SigmoidGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SigmoidTripleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sigmoid_triple_grad");

    grad_op->SetInput("out", this->Input("out"));
    grad_op->SetInput("fwd_grad_out", this->Input("fwd_grad_out"));
    grad_op->SetInput("grad_grad_x", this->Input(GradVarName("grad_x")));
    grad_op->SetInput(GradVarName("grad_out"),
                      this->OutputGrad(GradVarName("out")));
    grad_op->SetInput(GradVarName("grad_grad_out"),
                      this->OutputGrad(GradVarName("fwd_grad_out")));

    grad_op->SetOutput(GradVarName("out"), this->InputGrad("out"));
    grad_op->SetOutput(GradVarName("fwd_grad_out"),
                       this->InputGrad("fwd_grad_out"));
    grad_op->SetOutput(GradVarName("grad_grad_x"),
                       this->InputGrad(GradVarName("grad_x")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SigmoidTripleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sigmoid_triple_grad,
                            SigmoidTripleGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(SigmoidTripleGradInplaceInferer,
                           {"grad_grad_x", GradVarName("fwd_grad_out")});

template <typename T>
class SiluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("silu_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SiluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(silu_grad,
                            SiluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SiluGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SinDoubleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sin_double_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SinDoubleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sin_double_grad,
                            SinDoubleGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(SinDoubleGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class SinGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sin_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SinGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sin_grad,
                            SinGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SinGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SinTripleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sin_triple_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("grad_out_forward", this->Input("grad_out"));
    grad_op->SetInput("grad_x_grad_forward",
                      this->Input(GradVarName("grad_x")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("x")));
    grad_op->SetInput(GradVarName("grad_out_grad"),
                      this->OutputGrad(GradVarName("grad_out")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x"));
    grad_op->SetOutput(GradVarName("grad_out_forward"),
                       this->InputGrad("grad_out"));
    grad_op->SetOutput(GradVarName("grad_x_grad_forward"),
                       this->InputGrad(GradVarName("grad_x")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SinTripleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sin_triple_grad,
                            SinTripleGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(SinTripleGradInplaceInferer,
                           {"grad_x_grad_forward",
                            GradVarName("grad_out_forward")});

template <typename T>
class SinhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sinh_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SinhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sinh_grad,
                            SinhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SinhGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SoftplusGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("softplus_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SoftplusGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(softplus_grad,
                            SoftplusGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SoftplusGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SoftshrinkGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("softshrink_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SoftshrinkGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(softshrink_grad,
                            SoftshrinkGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SoftshrinkGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SoftsignGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("softsign_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SoftsignGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(softsign_grad,
                            SoftsignGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SoftsignGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SolveGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("solve_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Y", this->Input("Y"));
    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("Y"), this->InputGrad("Y"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SolveGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(solve_grad,
                            SolveGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));

template <typename T>
class SqrtGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sqrt_grad_grad");

    grad_op->SetInput("out", this->Input("Out"));
    grad_op->SetInput("grad_x", this->Output(GradVarName("X")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("out"), this->InputGrad("Out"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SqrtGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sqrt_grad_grad,
                            SqrtGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(SqrtGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class SqrtGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sqrt_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SqrtGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(sqrt_grad,
                            SqrtGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SqrtGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SquareGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("square_grad_grad");

    grad_op->SetInput("x", this->Input("X"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("X"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SquareGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(square_grad_grad,
                            SquareGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(SquareGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class SquareGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("square_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SquareGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(square_grad,
                            SquareGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(SquareGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class SvdGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("svd_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("U", this->Output("U"));
    grad_op->SetInput("VH", this->Output("VH"));
    grad_op->SetInput("S", this->Output("S"));
    grad_op->SetInput(GradVarName("U"), this->OutputGrad("U"));
    grad_op->SetInput(GradVarName("VH"), this->OutputGrad("VH"));
    grad_op->SetInput(GradVarName("S"), this->OutputGrad("S"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class SvdGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(svd_grad,
                            SvdGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class TakeAlongAxisGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("take_along_axis_grad");

    grad_op->SetInput("Input", this->Input("Input"));
    grad_op->SetInput("Index", this->Input("Index"));
    grad_op->SetInput(GradVarName("Result"), this->OutputGrad("Result"));

    grad_op->SetOutput(GradVarName("Input"), this->InputGrad("Input"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TakeAlongAxisGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(take_along_axis_grad,
                            TakeAlongAxisGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class TanGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("tan_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TanhCompositeGradOpMaker : public prim::GradCompositeOpMakerBase {
 public:
  using prim::GradCompositeOpMakerBase::GradCompositeOpMakerBase;

  void Apply() override {
    paddle::experimental::Tensor out = paddle::experimental::Tensor(
        std::make_shared<prim::DescTensor>(this->SingleForwardOutput("Out")));
    paddle::experimental::Tensor grad_out = paddle::experimental::Tensor(
        std::make_shared<prim::DescTensor>(this->SingleOutputGrad("Out")));
    paddle::experimental::Tensor grad_x = paddle::experimental::Tensor(
        std::make_shared<prim::DescTensor>(this->SingleInputGrad("X")));
    prim::tanh_grad<prim::DescTensor>(out, grad_out, &grad_x);
  }
};

class TanGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tan_grad,
                            TanGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(TanGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class TanhGradGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("tanh_grad_grad");

    grad_op->SetInput("out", this->Input("Out"));
    grad_op->SetInput("grad_out", this->Input(GradVarName("Out")));
    grad_op->SetInput(GradVarName("grad_x"),
                      this->OutputGrad(GradVarName("X")));

    grad_op->SetOutput(GradVarName("out"), this->InputGrad("Out"));
    grad_op->SetOutput(GradVarName("grad_out"),
                       this->InputGrad(GradVarName("Out")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TanhGradGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tanh_grad_grad,
                            TanhGradGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(TanhGradGradInplaceInferer,
                           {GradVarName("grad_x"), GradVarName("grad_out")});

template <typename T>
class TanhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("tanh_grad");

    grad_op->SetInput("Out", this->Output("Out"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TanhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tanh_grad,
                            TanhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(TanhGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class TanhShrinkGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("tanh_shrink_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TanhShrinkGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tanh_shrink_grad,
                            TanhShrinkGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(TanhShrinkGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class TanhTripleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("tanh_triple_grad");

    grad_op->SetInput("out", this->Input("out"));
    grad_op->SetInput("grad_out_forward", this->Input("grad_out"));
    grad_op->SetInput("grad_x_grad_forward",
                      this->Input(GradVarName("grad_x")));
    grad_op->SetInput(GradVarName("grad_out_new"),
                      this->OutputGrad(GradVarName("out")));
    grad_op->SetInput(GradVarName("grad_out_grad"),
                      this->OutputGrad(GradVarName("grad_out")));

    grad_op->SetOutput(GradVarName("out"), this->InputGrad("out"));
    grad_op->SetOutput(GradVarName("grad_out_forward"),
                       this->InputGrad("grad_out"));
    grad_op->SetOutput(GradVarName("grad_x_grad_forward"),
                       this->InputGrad(GradVarName("grad_x")));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TanhTripleGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(tanh_triple_grad,
                            TanhTripleGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));
DECLARE_INPLACE_OP_INFERER(TanhTripleGradInplaceInferer,
                           {"grad_x_grad_forward",
                            GradVarName("grad_out_forward")});

template <typename T>
class ThresholdedReluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("thresholded_relu_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class ThresholdedReluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(thresholded_relu_grad,
                            ThresholdedReluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));
DECLARE_INPLACE_OP_INFERER(ThresholdedReluGradInplaceInferer,
                           {GradVarName("Out"), GradVarName("X")});

template <typename T>
class TopKV2GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("top_k_v2_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput("Indices", this->Output("Indices"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
    if (this->HasInput("K")) {
      grad_op->SetInput("K", this->Input("K"));
    }
  }
};

class TopKV2GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(top_k_v2_grad,
                            TopKV2GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class TraceGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("trace_grad");

    grad_op->SetInput("Input", this->Input("Input"));
    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("Input"), this->InputGrad("Input"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TraceGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Out"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(trace_grad,
                            TraceGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(TraceGradNoNeedBufferVarInferer, "Input");

template <typename T>
class TruncGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("trunc_grad");

    grad_op->SetInput(GradVarName("Out"), this->OutputGrad("Out"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class TruncGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
};

DECLARE_INFER_SHAPE_FUNCTOR(trunc_grad,
                            TruncGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

template <typename T>
class UnfoldGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("unfold_grad");

    grad_op->SetInput("X", this->Input("X"));
    grad_op->SetInput(GradVarName("Y"), this->OutputGrad("Y"));

    grad_op->SetOutput(GradVarName("X"), this->InputGrad("X"));

    grad_op->SetAttrMap(this->Attrs());
  }
};

class UnfoldGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;

 protected:
  framework::OpKernelType GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(
        ctx, GradVarName("Y"));
    return framework::OpKernelType(data_type, ctx.GetPlace());
  }
};

DECLARE_INFER_SHAPE_FUNCTOR(unfold_grad,
                            UnfoldGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));

DECLARE_NO_NEED_BUFFER_VARS_INFERER(UnfoldGradNoNeedBufferVarInferer, "X");

}  // namespace operators
}  // namespace paddle

namespace ops = paddle::operators;
REGISTER_OPERATOR(acos,
                  ops::AcosOp,
                  ops::AcosOpMaker,
                  ops::AcosGradOpMaker<paddle::framework::OpDesc>,
                  ops::AcosGradOpMaker<paddle::imperative::OpBase>,
                  ops::AcosInferShapeFunctor);

REGISTER_OPERATOR(acosh,
                  ops::AcoshOp,
                  ops::AcoshOpMaker,
                  ops::AcoshGradOpMaker<paddle::framework::OpDesc>,
                  ops::AcoshGradOpMaker<paddle::imperative::OpBase>,
                  ops::AcoshInferShapeFunctor);

REGISTER_OPERATOR(angle,
                  ops::AngleOp,
                  ops::AngleOpMaker,
                  ops::AngleGradOpMaker<paddle::framework::OpDesc>,
                  ops::AngleGradOpMaker<paddle::imperative::OpBase>,
                  ops::AngleInferShapeFunctor);

REGISTER_OPERATOR(argsort,
                  ops::ArgsortOp,
                  ops::ArgsortOpMaker,
                  ops::ArgsortGradOpMaker<paddle::framework::OpDesc>,
                  ops::ArgsortGradOpMaker<paddle::imperative::OpBase>,
                  ops::ArgsortInferShapeFunctor);

REGISTER_OPERATOR(as_complex,
                  ops::AsComplexOp,
                  ops::AsComplexOpMaker,
                  ops::AsComplexGradOpMaker<paddle::framework::OpDesc>,
                  ops::AsComplexGradOpMaker<paddle::imperative::OpBase>,
                  ops::AsComplexInferShapeFunctor);

REGISTER_OPERATOR(as_real,
                  ops::AsRealOp,
                  ops::AsRealOpMaker,
                  ops::AsRealGradOpMaker<paddle::framework::OpDesc>,
                  ops::AsRealGradOpMaker<paddle::imperative::OpBase>,
                  ops::AsRealInferShapeFunctor);

REGISTER_OPERATOR(asin,
                  ops::AsinOp,
                  ops::AsinOpMaker,
                  ops::AsinGradOpMaker<paddle::framework::OpDesc>,
                  ops::AsinGradOpMaker<paddle::imperative::OpBase>,
                  ops::AsinInferShapeFunctor);

REGISTER_OPERATOR(asinh,
                  ops::AsinhOp,
                  ops::AsinhOpMaker,
                  ops::AsinhGradOpMaker<paddle::framework::OpDesc>,
                  ops::AsinhGradOpMaker<paddle::imperative::OpBase>,
                  ops::AsinhInferShapeFunctor);

REGISTER_OPERATOR(atan,
                  ops::AtanOp,
                  ops::AtanOpMaker,
                  ops::AtanGradOpMaker<paddle::framework::OpDesc>,
                  ops::AtanGradOpMaker<paddle::imperative::OpBase>,
                  ops::AtanInferShapeFunctor);

REGISTER_OPERATOR(atan2,
                  ops::Atan2Op,
                  ops::Atan2OpMaker,
                  ops::Atan2GradOpMaker<paddle::framework::OpDesc>,
                  ops::Atan2GradOpMaker<paddle::imperative::OpBase>,
                  ops::Atan2InferShapeFunctor);

REGISTER_OPERATOR(atanh,
                  ops::AtanhOp,
                  ops::AtanhOpMaker,
                  ops::AtanhGradOpMaker<paddle::framework::OpDesc>,
                  ops::AtanhGradOpMaker<paddle::imperative::OpBase>,
                  ops::AtanhInferShapeFunctor);

REGISTER_OPERATOR(
    bernoulli,
    ops::BernoulliOp,
    ops::BernoulliOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::BernoulliInferShapeFunctor);

REGISTER_OPERATOR(bmm,
                  ops::BmmOp,
                  ops::BmmOpMaker,
                  ops::BmmGradOpMaker<paddle::framework::OpDesc>,
                  ops::BmmGradOpMaker<paddle::imperative::OpBase>,
                  ops::BmmInferShapeFunctor);

REGISTER_OPERATOR(ceil,
                  ops::CeilOp,
                  ops::CeilOpMaker,
                  ops::CeilGradOpMaker<paddle::framework::OpDesc>,
                  ops::CeilGradOpMaker<paddle::imperative::OpBase>,
                  ops::CeilInplaceInferer,
                  ops::CeilInferShapeFunctor);

REGISTER_OPERATOR(celu,
                  ops::CeluOp,
                  ops::CeluOpMaker,
                  ops::CeluGradOpMaker<paddle::framework::OpDesc>,
                  ops::CeluGradOpMaker<paddle::imperative::OpBase>,
                  ops::CeluInferShapeFunctor);

REGISTER_OPERATOR(cholesky,
                  ops::CholeskyOp,
                  ops::CholeskyOpMaker,
                  ops::CholeskyGradOpMaker<paddle::framework::OpDesc>,
                  ops::CholeskyGradOpMaker<paddle::imperative::OpBase>,
                  ops::CholeskyInferShapeFunctor);

REGISTER_OPERATOR(cholesky_solve,
                  ops::CholeskySolveOp,
                  ops::CholeskySolveOpMaker,
                  ops::CholeskySolveGradOpMaker<paddle::framework::OpDesc>,
                  ops::CholeskySolveGradOpMaker<paddle::imperative::OpBase>,
                  ops::CholeskySolveInferShapeFunctor);

REGISTER_OPERATOR(conj,
                  ops::ConjOp,
                  ops::ConjOpMaker,
                  ops::ConjGradOpMaker<paddle::framework::OpDesc>,
                  ops::ConjGradOpMaker<paddle::imperative::OpBase>,
                  ops::ConjInferShapeFunctor);

REGISTER_OPERATOR(cos,
                  ops::CosOp,
                  ops::CosOpMaker,
                  ops::CosGradOpMaker<paddle::framework::OpDesc>,
                  ops::CosGradOpMaker<paddle::imperative::OpBase>,
                  ops::CosInferShapeFunctor);

REGISTER_OPERATOR(cosh,
                  ops::CoshOp,
                  ops::CoshOpMaker,
                  ops::CoshGradOpMaker<paddle::framework::OpDesc>,
                  ops::CoshGradOpMaker<paddle::imperative::OpBase>,
                  ops::CoshInferShapeFunctor);

REGISTER_OPERATOR(crop_tensor,
                  ops::CropTensorOp,
                  ops::CropTensorOpMaker,
                  ops::CropTensorGradOpMaker<paddle::framework::OpDesc>,
                  ops::CropTensorGradOpMaker<paddle::imperative::OpBase>,
                  ops::CropTensorInferShapeFunctor);

REGISTER_OPERATOR(cross,
                  ops::CrossOp,
                  ops::CrossOpMaker,
                  ops::CrossGradOpMaker<paddle::framework::OpDesc>,
                  ops::CrossGradOpMaker<paddle::imperative::OpBase>,
                  ops::CrossInferShapeFunctor);

REGISTER_OPERATOR(determinant,
                  ops::DeterminantOp,
                  ops::DeterminantOpMaker,
                  ops::DeterminantGradOpMaker<paddle::framework::OpDesc>,
                  ops::DeterminantGradOpMaker<paddle::imperative::OpBase>,
                  ops::DeterminantInferShapeFunctor);

REGISTER_OPERATOR(diag_v2,
                  ops::DiagV2Op,
                  ops::DiagV2OpMaker,
                  ops::DiagV2GradOpMaker<paddle::framework::OpDesc>,
                  ops::DiagV2GradOpMaker<paddle::imperative::OpBase>,
                  ops::DiagV2InferShapeFunctor);

REGISTER_OPERATOR(
    diag_embed,
    ops::DiagEmbedOp,
    ops::DiagEmbedOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DiagEmbedInferShapeFunctor);

REGISTER_OPERATOR(diagonal,
                  ops::DiagonalOp,
                  ops::DiagonalOpMaker,
                  ops::DiagonalGradOpMaker<paddle::framework::OpDesc>,
                  ops::DiagonalGradOpMaker<paddle::imperative::OpBase>,
                  ops::DiagonalInferShapeFunctor);

REGISTER_OPERATOR(digamma,
                  ops::DigammaOp,
                  ops::DigammaOpMaker,
                  ops::DigammaGradOpMaker<paddle::framework::OpDesc>,
                  ops::DigammaGradOpMaker<paddle::imperative::OpBase>,
                  ops::DigammaInferShapeFunctor);

REGISTER_OPERATOR(dist,
                  ops::DistOp,
                  ops::DistOpMaker,
                  ops::DistGradOpMaker<paddle::framework::OpDesc>,
                  ops::DistGradOpMaker<paddle::imperative::OpBase>,
                  ops::DistInferShapeFunctor);

REGISTER_OPERATOR(dot,
                  ops::DotOp,
                  ops::DotOpMaker,
                  ops::DotGradOpMaker<paddle::framework::OpDesc>,
                  ops::DotGradOpMaker<paddle::imperative::OpBase>,
                  ops::DotInferShapeFunctor);

REGISTER_OPERATOR(eig,
                  ops::EigOp,
                  ops::EigOpMaker,
                  ops::EigGradOpMaker<paddle::framework::OpDesc>,
                  ops::EigGradOpMaker<paddle::imperative::OpBase>,
                  ops::EigInferShapeFunctor);

REGISTER_OPERATOR(eigh,
                  ops::EighOp,
                  ops::EighOpMaker,
                  ops::EighGradOpMaker<paddle::framework::OpDesc>,
                  ops::EighGradOpMaker<paddle::imperative::OpBase>,
                  ops::EighInferShapeFunctor);

REGISTER_OPERATOR(
    eigvals,
    ops::EigvalsOp,
    ops::EigvalsOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::EigvalsInferShapeFunctor);

REGISTER_OPERATOR(elu,
                  ops::EluOp,
                  ops::EluOpMaker,
                  ops::EluGradOpMaker<paddle::framework::OpDesc>,
                  ops::EluGradOpMaker<paddle::imperative::OpBase>,
                  ops::EluInplaceInferer,
                  ops::EluInferShapeFunctor);

REGISTER_OPERATOR(
    equal_all,
    ops::EqualAllOp,
    ops::EqualAllOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::EqualAllInferShapeFunctor);

REGISTER_OPERATOR(erf,
                  ops::ErfOp,
                  ops::ErfOpMaker,
                  ops::ErfGradOpMaker<paddle::framework::OpDesc>,
                  ops::ErfGradOpMaker<paddle::imperative::OpBase>,
                  ops::ErfInferShapeFunctor);

REGISTER_OPERATOR(erfinv,
                  ops::ErfinvOp,
                  ops::ErfinvOpMaker,
                  ops::ErfinvGradOpMaker<paddle::framework::OpDesc>,
                  ops::ErfinvGradOpMaker<paddle::imperative::OpBase>,
                  ops::ErfinvInplaceInferer,
                  ops::ErfinvInferShapeFunctor);

REGISTER_OPERATOR(exp,
                  ops::ExpOp,
                  ops::ExpOpMaker,
                  ops::ExpGradOpMaker<paddle::framework::OpDesc>,
                  ops::ExpGradOpMaker<paddle::imperative::OpBase>,
                  ops::ExpInplaceInferer,
                  ops::ExpInferShapeFunctor);

REGISTER_OPERATOR(expm1,
                  ops::Expm1Op,
                  ops::Expm1OpMaker,
                  ops::Expm1GradOpMaker<paddle::framework::OpDesc>,
                  ops::Expm1GradOpMaker<paddle::imperative::OpBase>,
                  ops::Expm1InferShapeFunctor);

REGISTER_OPERATOR(fft_c2c,
                  ops::FftC2cOp,
                  ops::FftC2cOpMaker,
                  ops::FftC2cGradOpMaker<paddle::framework::OpDesc>,
                  ops::FftC2cGradOpMaker<paddle::imperative::OpBase>,
                  ops::FftC2cInferShapeFunctor);

REGISTER_OPERATOR(fft_c2r,
                  ops::FftC2rOp,
                  ops::FftC2rOpMaker,
                  ops::FftC2rGradOpMaker<paddle::framework::OpDesc>,
                  ops::FftC2rGradOpMaker<paddle::imperative::OpBase>,
                  ops::FftC2rInferShapeFunctor);

REGISTER_OPERATOR(fft_r2c,
                  ops::FftR2cOp,
                  ops::FftR2cOpMaker,
                  ops::FftR2cGradOpMaker<paddle::framework::OpDesc>,
                  ops::FftR2cGradOpMaker<paddle::imperative::OpBase>,
                  ops::FftR2cInferShapeFunctor);

REGISTER_OPERATOR(
    fill_diagonal_tensor,
    ops::FillDiagonalTensorOp,
    ops::FillDiagonalTensorOpMaker,
    ops::FillDiagonalTensorGradOpMaker<paddle::framework::OpDesc>,
    ops::FillDiagonalTensorGradOpMaker<paddle::imperative::OpBase>,
    ops::FillDiagonalTensorInplaceInferer,
    ops::FillDiagonalTensorInferShapeFunctor);

REGISTER_OPERATOR(flip,
                  ops::FlipOp,
                  ops::FlipOpMaker,
                  ops::FlipGradOpMaker<paddle::framework::OpDesc>,
                  ops::FlipGradOpMaker<paddle::imperative::OpBase>,
                  ops::FlipInferShapeFunctor);

REGISTER_OP_VERSION(flip).AddCheckpoint(
    R"ROC(Upgrade flip, add new attr [axis] and delete attr [dims])ROC",
    paddle::framework::compatible::OpVersionDesc()
        .NewAttr("axis",
                 "The added attr 'axis' doesn't set default value",
                 paddle::none)
        .DeleteAttr("dims", "The attr 'dims' is deleted."));

REGISTER_OPERATOR(floor,
                  ops::FloorOp,
                  ops::FloorOpMaker,
                  ops::FloorGradOpMaker<paddle::framework::OpDesc>,
                  ops::FloorGradOpMaker<paddle::imperative::OpBase>,
                  ops::FloorInplaceInferer,
                  ops::FloorInferShapeFunctor);

REGISTER_OPERATOR(fold,
                  ops::FoldOp,
                  ops::FoldOpMaker,
                  ops::FoldGradOpMaker<paddle::framework::OpDesc>,
                  ops::FoldGradOpMaker<paddle::imperative::OpBase>,
                  ops::FoldInferShapeFunctor);

REGISTER_OPERATOR(
    gather_tree,
    ops::GatherTreeOp,
    ops::GatherTreeOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::GatherTreeInferShapeFunctor);

REGISTER_OPERATOR(gelu,
                  ops::GeluOp,
                  ops::GeluOpMaker,
                  ops::GeluGradOpMaker<paddle::framework::OpDesc>,
                  ops::GeluGradOpMaker<paddle::imperative::OpBase>,
                  ops::GeluInferShapeFunctor);

REGISTER_OPERATOR(grid_sampler,
                  ops::GridSamplerOp,
                  ops::GridSamplerOpMaker,
                  ops::GridSamplerGradOpMaker<paddle::framework::OpDesc>,
                  ops::GridSamplerGradOpMaker<paddle::imperative::OpBase>,
                  ops::GridSamplerInferShapeFunctor);

REGISTER_OP_VERSION(grid_sampler)
    .AddCheckpoint(R"ROC(Upgrade grid_sampler add a new attribute [mode])ROC",
                   paddle::framework::compatible::OpVersionDesc().NewAttr(
                       "mode",
                       "In order to specify interpolation mode",
                       std::string("bilinear")));

REGISTER_OPERATOR(gumbel_softmax,
                  ops::GumbelSoftmaxOp,
                  ops::GumbelSoftmaxOpMaker,
                  ops::GumbelSoftmaxGradOpMaker<paddle::framework::OpDesc>,
                  ops::GumbelSoftmaxGradOpMaker<paddle::imperative::OpBase>,
                  ops::GumbelSoftmaxInferShapeFunctor);

REGISTER_OPERATOR(hard_shrink,
                  ops::HardShrinkOp,
                  ops::HardShrinkOpMaker,
                  ops::HardShrinkGradOpMaker<paddle::framework::OpDesc>,
                  ops::HardShrinkGradOpMaker<paddle::imperative::OpBase>,
                  ops::HardShrinkInferShapeFunctor);

REGISTER_OPERATOR(hard_sigmoid,
                  ops::HardSigmoidOp,
                  ops::HardSigmoidOpMaker,
                  ops::HardSigmoidGradOpMaker<paddle::framework::OpDesc>,
                  ops::HardSigmoidGradOpMaker<paddle::imperative::OpBase>,
                  ops::HardSigmoidInferShapeFunctor);

REGISTER_OPERATOR(
    histogram,
    ops::HistogramOp,
    ops::HistogramOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::HistogramInferShapeFunctor);

REGISTER_OPERATOR(index_sample,
                  ops::IndexSampleOp,
                  ops::IndexSampleOpMaker,
                  ops::IndexSampleGradOpMaker<paddle::framework::OpDesc>,
                  ops::IndexSampleGradOpMaker<paddle::imperative::OpBase>,
                  ops::IndexSampleInferShapeFunctor);

REGISTER_OPERATOR(index_select,
                  ops::IndexSelectOp,
                  ops::IndexSelectOpMaker,
                  ops::IndexSelectGradOpMaker<paddle::framework::OpDesc>,
                  ops::IndexSelectGradOpMaker<paddle::imperative::OpBase>,
                  ops::IndexSelectInferShapeFunctor);

REGISTER_OPERATOR(inverse,
                  ops::InverseOp,
                  ops::InverseOpMaker,
                  ops::InverseGradOpMaker<paddle::framework::OpDesc>,
                  ops::InverseGradOpMaker<paddle::imperative::OpBase>,
                  ops::InverseInferShapeFunctor);

REGISTER_OPERATOR(
    is_empty,
    ops::IsEmptyOp,
    ops::IsEmptyOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::IsEmptyInferShapeFunctor);

REGISTER_OPERATOR(
    isfinite_v2,
    ops::IsfiniteV2Op,
    ops::IsfiniteV2OpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::IsfiniteV2InferShapeFunctor);

REGISTER_OPERATOR(
    isinf_v2,
    ops::IsinfV2Op,
    ops::IsinfV2OpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::IsinfV2InferShapeFunctor);

REGISTER_OPERATOR(
    isnan_v2,
    ops::IsnanV2Op,
    ops::IsnanV2OpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::IsnanV2InferShapeFunctor);

REGISTER_OPERATOR(kthvalue,
                  ops::KthvalueOp,
                  ops::KthvalueOpMaker,
                  ops::KthvalueGradOpMaker<paddle::framework::OpDesc>,
                  ops::KthvalueGradOpMaker<paddle::imperative::OpBase>,
                  ops::KthvalueInferShapeFunctor);

REGISTER_OPERATOR(label_smooth,
                  ops::LabelSmoothOp,
                  ops::LabelSmoothOpMaker,
                  ops::LabelSmoothGradOpMaker<paddle::framework::OpDesc>,
                  ops::LabelSmoothGradOpMaker<paddle::imperative::OpBase>,
                  ops::LabelSmoothInferShapeFunctor);

REGISTER_OPERATOR(leaky_relu,
                  ops::LeakyReluOp,
                  ops::LeakyReluOpMaker,
                  ops::LeakyReluGradOpMaker<paddle::framework::OpDesc>,
                  ops::LeakyReluGradOpMaker<paddle::imperative::OpBase>,
                  ops::LeakyReluInferShapeFunctor);

REGISTER_OPERATOR(lerp,
                  ops::LerpOp,
                  ops::LerpOpMaker,
                  ops::LerpGradOpMaker<paddle::framework::OpDesc>,
                  ops::LerpGradOpMaker<paddle::imperative::OpBase>,
                  ops::LerpInplaceInferer,
                  ops::LerpInferShapeFunctor);

REGISTER_OPERATOR(lgamma,
                  ops::LgammaOp,
                  ops::LgammaOpMaker,
                  ops::LgammaGradOpMaker<paddle::framework::OpDesc>,
                  ops::LgammaGradOpMaker<paddle::imperative::OpBase>,
                  ops::LgammaInferShapeFunctor);

REGISTER_OPERATOR(log,
                  ops::LogOp,
                  ops::LogOpMaker,
                  ops::LogGradOpMaker<paddle::framework::OpDesc>,
                  ops::LogGradOpMaker<paddle::imperative::OpBase>,
                  ops::LogInferShapeFunctor);

REGISTER_OPERATOR(log10,
                  ops::Log10Op,
                  ops::Log10OpMaker,
                  ops::Log10GradOpMaker<paddle::framework::OpDesc>,
                  ops::Log10GradOpMaker<paddle::imperative::OpBase>,
                  ops::Log10InferShapeFunctor);

REGISTER_OPERATOR(log1p,
                  ops::Log1pOp,
                  ops::Log1pOpMaker,
                  ops::Log1pGradOpMaker<paddle::framework::OpDesc>,
                  ops::Log1pGradOpMaker<paddle::imperative::OpBase>,
                  ops::Log1pInferShapeFunctor);

REGISTER_OPERATOR(log2,
                  ops::Log2Op,
                  ops::Log2OpMaker,
                  ops::Log2GradOpMaker<paddle::framework::OpDesc>,
                  ops::Log2GradOpMaker<paddle::imperative::OpBase>,
                  ops::Log2InferShapeFunctor);

REGISTER_OPERATOR(log_loss,
                  ops::LogLossOp,
                  ops::LogLossOpMaker,
                  ops::LogLossGradOpMaker<paddle::framework::OpDesc>,
                  ops::LogLossGradOpMaker<paddle::imperative::OpBase>,
                  ops::LogLossInferShapeFunctor);

REGISTER_OPERATOR(logit,
                  ops::LogitOp,
                  ops::LogitOpMaker,
                  ops::LogitGradOpMaker<paddle::framework::OpDesc>,
                  ops::LogitGradOpMaker<paddle::imperative::OpBase>,
                  ops::LogitInferShapeFunctor);

REGISTER_OPERATOR(logsigmoid,
                  ops::LogsigmoidOp,
                  ops::LogsigmoidOpMaker,
                  ops::LogsigmoidGradOpMaker<paddle::framework::OpDesc>,
                  ops::LogsigmoidGradOpMaker<paddle::imperative::OpBase>,
                  ops::LogsigmoidInferShapeFunctor);

REGISTER_OPERATOR(lu_unpack,
                  ops::LuUnpackOp,
                  ops::LuUnpackOpMaker,
                  ops::LuUnpackGradOpMaker<paddle::framework::OpDesc>,
                  ops::LuUnpackGradOpMaker<paddle::imperative::OpBase>,
                  ops::LuUnpackInferShapeFunctor);

REGISTER_OPERATOR(masked_select,
                  ops::MaskedSelectOp,
                  ops::MaskedSelectOpMaker,
                  ops::MaskedSelectGradOpMaker<paddle::framework::OpDesc>,
                  ops::MaskedSelectGradOpMaker<paddle::imperative::OpBase>,
                  ops::MaskedSelectInferShapeFunctor);

REGISTER_OPERATOR(matrix_power,
                  ops::MatrixPowerOp,
                  ops::MatrixPowerOpMaker,
                  ops::MatrixPowerGradOpMaker<paddle::framework::OpDesc>,
                  ops::MatrixPowerGradOpMaker<paddle::imperative::OpBase>,
                  ops::MatrixPowerInferShapeFunctor);

REGISTER_OPERATOR(maxout,
                  ops::MaxoutOp,
                  ops::MaxoutOpMaker,
                  ops::MaxoutGradOpMaker<paddle::framework::OpDesc>,
                  ops::MaxoutGradOpMaker<paddle::imperative::OpBase>,
                  ops::MaxoutInferShapeFunctor);

REGISTER_OPERATOR(mode,
                  ops::ModeOp,
                  ops::ModeOpMaker,
                  ops::ModeGradOpMaker<paddle::framework::OpDesc>,
                  ops::ModeGradOpMaker<paddle::imperative::OpBase>,
                  ops::ModeInferShapeFunctor);

REGISTER_OPERATOR(
    multinomial,
    ops::MultinomialOp,
    ops::MultinomialOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::MultinomialInferShapeFunctor);

REGISTER_OPERATOR(mv,
                  ops::MvOp,
                  ops::MvOpMaker,
                  ops::MvGradOpMaker<paddle::framework::OpDesc>,
                  ops::MvGradOpMaker<paddle::imperative::OpBase>,
                  ops::MvInferShapeFunctor);

REGISTER_OPERATOR(nll_loss,
                  ops::NllLossOp,
                  ops::NllLossOpMaker,
                  ops::NllLossGradOpMaker<paddle::framework::OpDesc>,
                  ops::NllLossGradOpMaker<paddle::imperative::OpBase>,
                  ops::NllLossInferShapeFunctor);

REGISTER_OPERATOR(
    npu_identity,
    ops::NpuIdentityOp,
    ops::NpuIdentityOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::NpuIdentityInferShapeFunctor);

REGISTER_OPERATOR(poisson,
                  ops::PoissonOp,
                  ops::PoissonOpMaker,
                  ops::PoissonGradOpMaker<paddle::framework::OpDesc>,
                  ops::PoissonGradOpMaker<paddle::imperative::OpBase>,
                  ops::PoissonInferShapeFunctor);

REGISTER_OPERATOR(put_along_axis,
                  ops::PutAlongAxisOp,
                  ops::PutAlongAxisOpMaker,
                  ops::PutAlongAxisGradOpMaker<paddle::framework::OpDesc>,
                  ops::PutAlongAxisGradOpMaker<paddle::imperative::OpBase>,
                  ops::PutAlongAxisInplaceInferer,
                  ops::PutAlongAxisInferShapeFunctor);

REGISTER_OPERATOR(qr,
                  ops::QrOp,
                  ops::QrOpMaker,
                  ops::QrGradOpMaker<paddle::framework::OpDesc>,
                  ops::QrGradOpMaker<paddle::imperative::OpBase>,
                  ops::QrInferShapeFunctor);

REGISTER_OPERATOR(reciprocal,
                  ops::ReciprocalOp,
                  ops::ReciprocalOpMaker,
                  ops::ReciprocalGradOpMaker<paddle::framework::OpDesc>,
                  ops::ReciprocalGradOpMaker<paddle::imperative::OpBase>,
                  ops::ReciprocalInplaceInferer,
                  ops::ReciprocalInferShapeFunctor);

REGISTER_OPERATOR(relu,
                  ops::ReluOp,
                  ops::ReluOpMaker,
                  ops::ReluGradOpMaker<paddle::framework::OpDesc>,
                  ops::ReluGradOpMaker<paddle::imperative::OpBase>,
                  ops::ReluInplaceInferer,
                  ops::ReluInferShapeFunctor);

REGISTER_OPERATOR(renorm,
                  ops::RenormOp,
                  ops::RenormOpMaker,
                  ops::RenormGradOpMaker<paddle::framework::OpDesc>,
                  ops::RenormGradOpMaker<paddle::imperative::OpBase>,
                  ops::RenormInferShapeFunctor);

REGISTER_OPERATOR(round,
                  ops::RoundOp,
                  ops::RoundOpMaker,
                  ops::RoundGradOpMaker<paddle::framework::OpDesc>,
                  ops::RoundGradOpMaker<paddle::imperative::OpBase>,
                  ops::RoundInplaceInferer,
                  ops::RoundInferShapeFunctor);

REGISTER_OPERATOR(rsqrt,
                  ops::RsqrtOp,
                  ops::RsqrtOpMaker,
                  ops::RsqrtGradOpMaker<paddle::framework::OpDesc>,
                  ops::RsqrtGradOpMaker<paddle::imperative::OpBase>,
                  ops::RsqrtInplaceInferer,
                  ops::RsqrtInferShapeFunctor);

REGISTER_OPERATOR(
    searchsorted,
    ops::SearchsortedOp,
    ops::SearchsortedOpMaker,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SearchsortedInferShapeFunctor);

REGISTER_OPERATOR(graph_send_uv,
                  ops::GraphSendUvOp,
                  ops::GraphSendUvOpMaker,
                  ops::GraphSendUvGradOpMaker<paddle::framework::OpDesc>,
                  ops::GraphSendUvGradOpMaker<paddle::imperative::OpBase>,
                  ops::GraphSendUvInferShapeFunctor);

REGISTER_OPERATOR(sigmoid,
                  ops::SigmoidOp,
                  ops::SigmoidOpMaker,
                  ops::SigmoidGradOpMaker<paddle::framework::OpDesc>,
                  ops::SigmoidGradOpMaker<paddle::imperative::OpBase>,
                  ops::SigmoidInferShapeFunctor);

REGISTER_OPERATOR(silu,
                  ops::SiluOp,
                  ops::SiluOpMaker,
                  ops::SiluGradOpMaker<paddle::framework::OpDesc>,
                  ops::SiluGradOpMaker<paddle::imperative::OpBase>,
                  ops::SiluInferShapeFunctor);

REGISTER_OPERATOR(sin,
                  ops::SinOp,
                  ops::SinOpMaker,
                  ops::SinGradOpMaker<paddle::framework::OpDesc>,
                  ops::SinGradOpMaker<paddle::imperative::OpBase>,
                  ops::SinInferShapeFunctor);

REGISTER_OPERATOR(sinh,
                  ops::SinhOp,
                  ops::SinhOpMaker,
                  ops::SinhGradOpMaker<paddle::framework::OpDesc>,
                  ops::SinhGradOpMaker<paddle::imperative::OpBase>,
                  ops::SinhInferShapeFunctor);

REGISTER_OPERATOR(softplus,
                  ops::SoftplusOp,
                  ops::SoftplusOpMaker,
                  ops::SoftplusGradOpMaker<paddle::framework::OpDesc>,
                  ops::SoftplusGradOpMaker<paddle::imperative::OpBase>,
                  ops::SoftplusInferShapeFunctor);

REGISTER_OPERATOR(softshrink,
                  ops::SoftshrinkOp,
                  ops::SoftshrinkOpMaker,
                  ops::SoftshrinkGradOpMaker<paddle::framework::OpDesc>,
                  ops::SoftshrinkGradOpMaker<paddle::imperative::OpBase>,
                  ops::SoftshrinkInferShapeFunctor);

REGISTER_OPERATOR(softsign,
                  ops::SoftsignOp,
                  ops::SoftsignOpMaker,
                  ops::SoftsignGradOpMaker<paddle::framework::OpDesc>,
                  ops::SoftsignGradOpMaker<paddle::imperative::OpBase>,
                  ops::SoftsignInferShapeFunctor);

REGISTER_OPERATOR(solve,
                  ops::SolveOp,
                  ops::SolveOpMaker,
                  ops::SolveGradOpMaker<paddle::framework::OpDesc>,
                  ops::SolveGradOpMaker<paddle::imperative::OpBase>,
                  ops::SolveInferShapeFunctor);

REGISTER_OPERATOR(sqrt,
                  ops::SqrtOp,
                  ops::SqrtOpMaker,
                  ops::SqrtGradOpMaker<paddle::framework::OpDesc>,
                  ops::SqrtGradOpMaker<paddle::imperative::OpBase>,
                  ops::SqrtInplaceInferer,
                  ops::SqrtInferShapeFunctor);

REGISTER_OPERATOR(square,
                  ops::SquareOp,
                  ops::SquareOpMaker,
                  ops::SquareGradOpMaker<paddle::framework::OpDesc>,
                  ops::SquareGradOpMaker<paddle::imperative::OpBase>,
                  ops::SquareInferShapeFunctor);

REGISTER_OPERATOR(svd,
                  ops::SvdOp,
                  ops::SvdOpMaker,
                  ops::SvdGradOpMaker<paddle::framework::OpDesc>,
                  ops::SvdGradOpMaker<paddle::imperative::OpBase>,
                  ops::SvdInferShapeFunctor);

REGISTER_OPERATOR(take_along_axis,
                  ops::TakeAlongAxisOp,
                  ops::TakeAlongAxisOpMaker,
                  ops::TakeAlongAxisGradOpMaker<paddle::framework::OpDesc>,
                  ops::TakeAlongAxisGradOpMaker<paddle::imperative::OpBase>,
                  ops::TakeAlongAxisInferShapeFunctor);

REGISTER_OPERATOR(tan,
                  ops::TanOp,
                  ops::TanOpMaker,
                  ops::TanGradOpMaker<paddle::framework::OpDesc>,
                  ops::TanGradOpMaker<paddle::imperative::OpBase>,
                  ops::TanInferShapeFunctor);

REGISTER_OPERATOR(tanh,
                  ops::TanhOp,
                  ops::TanhOpMaker,
                  ops::TanhGradOpMaker<paddle::framework::OpDesc>,
                  ops::TanhGradOpMaker<paddle::imperative::OpBase>,
                  ops::TanhCompositeGradOpMaker,
                  ops::TanhInplaceInferer,
                  ops::TanhInferShapeFunctor);

REGISTER_OPERATOR(tanh_shrink,
                  ops::TanhShrinkOp,
                  ops::TanhShrinkOpMaker,
                  ops::TanhShrinkGradOpMaker<paddle::framework::OpDesc>,
                  ops::TanhShrinkGradOpMaker<paddle::imperative::OpBase>,
                  ops::TanhShrinkInferShapeFunctor);

REGISTER_OPERATOR(thresholded_relu,
                  ops::ThresholdedReluOp,
                  ops::ThresholdedReluOpMaker,
                  ops::ThresholdedReluGradOpMaker<paddle::framework::OpDesc>,
                  ops::ThresholdedReluGradOpMaker<paddle::imperative::OpBase>,
                  ops::ThresholdedReluInferShapeFunctor);

REGISTER_OPERATOR(top_k_v2,
                  ops::TopKV2Op,
                  ops::TopKV2OpMaker,
                  ops::TopKV2GradOpMaker<paddle::framework::OpDesc>,
                  ops::TopKV2GradOpMaker<paddle::imperative::OpBase>,
                  ops::TopKV2InferShapeFunctor);

REGISTER_OPERATOR(trace,
                  ops::TraceOp,
                  ops::TraceOpMaker,
                  ops::TraceGradOpMaker<paddle::framework::OpDesc>,
                  ops::TraceGradOpMaker<paddle::imperative::OpBase>,
                  ops::TraceInferShapeFunctor);

REGISTER_OP_VERSION(trace).AddCheckpoint(
    R"ROC(Upgrade trace add a new attribute [axis2])ROC",
    paddle::framework::compatible::OpVersionDesc()
        .NewAttr("axis1",
                 "The added attribute 'axis1' is not yet registered.",
                 std::vector<float>{0.0f})
        .NewAttr("None",
                 "The added attribute 'axis2' is not yet registered.",
                 std::vector<float>{1.0f})
        .DeleteAttr("dim1",
                    "The attribute 'dim1' is not recommend according to the "
                    "specification 2.0.")
        .DeleteAttr("dim2",
                    "The attribute 'dim2' is not recommend according to the "
                    "specification 2.0."));

REGISTER_OPERATOR(trunc,
                  ops::TruncOp,
                  ops::TruncOpMaker,
                  ops::TruncGradOpMaker<paddle::framework::OpDesc>,
                  ops::TruncGradOpMaker<paddle::imperative::OpBase>,
                  ops::TruncInferShapeFunctor);

REGISTER_OPERATOR(unfold,
                  ops::UnfoldOp,
                  ops::UnfoldOpMaker,
                  ops::UnfoldGradOpMaker<paddle::framework::OpDesc>,
                  ops::UnfoldGradOpMaker<paddle::imperative::OpBase>,
                  ops::UnfoldInferShapeFunctor);

REGISTER_OPERATOR(
    acos_grad,
    ops::AcosGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AcosGradInplaceInferer,
    ops::AcosGradInferShapeFunctor);

REGISTER_OPERATOR(
    acosh_grad,
    ops::AcoshGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AcoshGradInplaceInferer,
    ops::AcoshGradInferShapeFunctor);

REGISTER_OPERATOR(
    angle_grad,
    ops::AngleGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AngleGradInferShapeFunctor);

REGISTER_OPERATOR(
    argsort_grad,
    ops::ArgsortGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ArgsortGradNoNeedBufferVarInferer,
    ops::ArgsortGradInferShapeFunctor);

REGISTER_OPERATOR(
    asin_grad,
    ops::AsinGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AsinGradInplaceInferer,
    ops::AsinGradInferShapeFunctor);

REGISTER_OPERATOR(
    asinh_grad,
    ops::AsinhGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AsinhGradInplaceInferer,
    ops::AsinhGradInferShapeFunctor);

REGISTER_OPERATOR(
    atan2_grad,
    ops::Atan2GradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::Atan2GradInferShapeFunctor);

REGISTER_OPERATOR(
    atan_grad,
    ops::AtanGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AtanGradInplaceInferer,
    ops::AtanGradInferShapeFunctor);

REGISTER_OPERATOR(
    atanh_grad,
    ops::AtanhGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::AtanhGradInplaceInferer,
    ops::AtanhGradInferShapeFunctor);

REGISTER_OPERATOR(
    bmm_grad,
    ops::BmmGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::BmmGradInferShapeFunctor);

REGISTER_OPERATOR(
    ceil_grad,
    ops::CeilGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CeilGradInplaceInferer,
    ops::CeilGradInferShapeFunctor);

REGISTER_OPERATOR(
    celu_grad_grad,
    ops::CeluGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CeluGradGradInplaceInferer,
    ops::CeluGradGradInferShapeFunctor);

REGISTER_OPERATOR(celu_grad,
                  ops::CeluGradOp,
                  ops::CeluGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::CeluGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::CeluGradInplaceInferer,
                  ops::CeluGradInferShapeFunctor);

REGISTER_OPERATOR(
    cholesky_grad,
    ops::CholeskyGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CholeskyGradInferShapeFunctor);

REGISTER_OPERATOR(
    cholesky_solve_grad,
    ops::CholeskySolveGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CholeskySolveGradInferShapeFunctor);

REGISTER_OPERATOR(cos_double_grad,
                  ops::CosDoubleGradOp,
                  ops::CosTripleGradOpMaker<paddle::framework::OpDesc>,
                  ops::CosTripleGradOpMaker<paddle::imperative::OpBase>,
                  ops::CosDoubleGradInplaceInferer,
                  ops::CosDoubleGradInferShapeFunctor);

REGISTER_OPERATOR(cos_grad,
                  ops::CosGradOp,
                  ops::CosDoubleGradOpMaker<paddle::framework::OpDesc>,
                  ops::CosDoubleGradOpMaker<paddle::imperative::OpBase>,
                  ops::CosGradInplaceInferer,
                  ops::CosGradInferShapeFunctor);

REGISTER_OPERATOR(
    cos_triple_grad,
    ops::CosTripleGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CosTripleGradInplaceInferer,
    ops::CosTripleGradInferShapeFunctor);

REGISTER_OPERATOR(
    cosh_grad,
    ops::CoshGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CoshGradInplaceInferer,
    ops::CoshGradInferShapeFunctor);

REGISTER_OPERATOR(
    crop_tensor_grad,
    ops::CropTensorGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CropTensorGradInferShapeFunctor);

REGISTER_OPERATOR(
    cross_grad,
    ops::CrossGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::CrossGradInferShapeFunctor);

REGISTER_OPERATOR(
    determinant_grad,
    ops::DeterminantGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DeterminantGradInferShapeFunctor);

REGISTER_OPERATOR(
    diag_v2_grad,
    ops::DiagV2GradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DiagV2GradNoNeedBufferVarInferer,
    ops::DiagV2GradInferShapeFunctor);

REGISTER_OPERATOR(
    diagonal_grad,
    ops::DiagonalGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DiagonalGradNoNeedBufferVarInferer,
    ops::DiagonalGradInferShapeFunctor);

REGISTER_OPERATOR(
    digamma_grad,
    ops::DigammaGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DigammaGradInferShapeFunctor);

REGISTER_OPERATOR(
    dist_grad,
    ops::DistGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DistGradInferShapeFunctor);

REGISTER_OPERATOR(
    dot_grad,
    ops::DotGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::DotGradInferShapeFunctor);

REGISTER_OPERATOR(
    eig_grad,
    ops::EigGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::EigGradInferShapeFunctor);

REGISTER_OPERATOR(
    eigh_grad,
    ops::EighGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::EighGradInferShapeFunctor);

REGISTER_OPERATOR(
    elu_grad_grad,
    ops::EluGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::EluGradGradInplaceInferer,
    ops::EluGradGradInferShapeFunctor);

REGISTER_OPERATOR(elu_grad,
                  ops::EluGradOp,
                  ops::EluGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::EluGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::EluGradInplaceInferer,
                  ops::EluGradInferShapeFunctor);

REGISTER_OPERATOR(
    erf_grad,
    ops::ErfGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ErfGradInferShapeFunctor);

REGISTER_OPERATOR(
    erfinv_grad,
    ops::ErfinvGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ErfinvGradInferShapeFunctor);

REGISTER_OPERATOR(
    exp_grad,
    ops::ExpGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ExpGradInplaceInferer,
    ops::ExpGradInferShapeFunctor);

REGISTER_OPERATOR(
    expm1_grad,
    ops::Expm1GradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::Expm1GradInplaceInferer,
    ops::Expm1GradInferShapeFunctor);

REGISTER_OPERATOR(
    fft_c2c_grad,
    ops::FftC2cGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::FftC2cGradInferShapeFunctor);

REGISTER_OPERATOR(
    fft_c2r_grad,
    ops::FftC2rGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::FftC2rGradInferShapeFunctor);

REGISTER_OPERATOR(
    fft_r2c_grad,
    ops::FftR2cGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::FftR2cGradNoNeedBufferVarInferer,
    ops::FftR2cGradInferShapeFunctor);

REGISTER_OPERATOR(
    fill_diagonal_tensor_grad,
    ops::FillDiagonalTensorGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::FillDiagonalTensorGradInplaceInferer,
    ops::FillDiagonalTensorGradInferShapeFunctor);

REGISTER_OPERATOR(
    floor_grad,
    ops::FloorGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::FloorGradInplaceInferer,
    ops::FloorGradInferShapeFunctor);

REGISTER_OPERATOR(
    fold_grad,
    ops::FoldGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::FoldGradNoNeedBufferVarInferer,
    ops::FoldGradInferShapeFunctor);

REGISTER_OPERATOR(
    gelu_grad,
    ops::GeluGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::GeluGradInferShapeFunctor);

REGISTER_OPERATOR(
    grid_sampler_grad,
    ops::GridSamplerGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::GridSamplerGradInferShapeFunctor);

REGISTER_OPERATOR(
    gumbel_softmax_grad,
    ops::GumbelSoftmaxGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::GumbelSoftmaxGradInferShapeFunctor);

REGISTER_OPERATOR(
    hard_shrink_grad,
    ops::HardShrinkGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::HardShrinkGradInplaceInferer,
    ops::HardShrinkGradInferShapeFunctor);

REGISTER_OPERATOR(
    hard_sigmoid_grad,
    ops::HardSigmoidGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::HardSigmoidGradInplaceInferer,
    ops::HardSigmoidGradInferShapeFunctor);

REGISTER_OPERATOR(
    index_sample_grad,
    ops::IndexSampleGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::IndexSampleGradNoNeedBufferVarInferer,
    ops::IndexSampleGradInferShapeFunctor);

REGISTER_OPERATOR(
    index_select_grad,
    ops::IndexSelectGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::IndexSelectGradNoNeedBufferVarInferer,
    ops::IndexSelectGradInferShapeFunctor);

REGISTER_OPERATOR(
    inverse_grad,
    ops::InverseGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::InverseGradInferShapeFunctor);

REGISTER_OPERATOR(
    kthvalue_grad,
    ops::KthvalueGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::KthvalueGradInferShapeFunctor);

REGISTER_OPERATOR(
    label_smooth_grad,
    ops::LabelSmoothGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LabelSmoothGradInferShapeFunctor);

REGISTER_OPERATOR(
    leaky_relu_grad_grad,
    ops::LeakyReluGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LeakyReluGradGradInplaceInferer,
    ops::LeakyReluGradGradInferShapeFunctor);

REGISTER_OPERATOR(leaky_relu_grad,
                  ops::LeakyReluGradOp,
                  ops::LeakyReluGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::LeakyReluGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::LeakyReluGradInplaceInferer,
                  ops::LeakyReluGradInferShapeFunctor);

REGISTER_OPERATOR(
    lerp_grad,
    ops::LerpGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LerpGradInferShapeFunctor);

REGISTER_OPERATOR(
    lgamma_grad,
    ops::LgammaGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LgammaGradInferShapeFunctor);

REGISTER_OPERATOR(
    log10_grad,
    ops::Log10GradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::Log10GradInplaceInferer,
    ops::Log10GradInferShapeFunctor);

REGISTER_OPERATOR(
    log1p_grad,
    ops::Log1pGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::Log1pGradInplaceInferer,
    ops::Log1pGradInferShapeFunctor);

REGISTER_OPERATOR(
    log2_grad,
    ops::Log2GradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::Log2GradInplaceInferer,
    ops::Log2GradInferShapeFunctor);

REGISTER_OPERATOR(
    log_grad_grad,
    ops::LogGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LogGradGradInplaceInferer,
    ops::LogGradGradInferShapeFunctor);

REGISTER_OPERATOR(log_grad,
                  ops::LogGradOp,
                  ops::LogGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::LogGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::LogGradInplaceInferer,
                  ops::LogGradInferShapeFunctor);

REGISTER_OPERATOR(
    log_loss_grad,
    ops::LogLossGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LogLossGradInferShapeFunctor);

REGISTER_OPERATOR(
    logit_grad,
    ops::LogitGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LogitGradInferShapeFunctor);

REGISTER_OPERATOR(
    logsigmoid_grad,
    ops::LogsigmoidGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LogsigmoidGradInplaceInferer,
    ops::LogsigmoidGradInferShapeFunctor);

REGISTER_OPERATOR(
    lu_unpack_grad,
    ops::LuUnpackGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::LuUnpackGradInferShapeFunctor);

REGISTER_OPERATOR(
    masked_select_grad,
    ops::MaskedSelectGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::MaskedSelectGradNoNeedBufferVarInferer,
    ops::MaskedSelectGradInferShapeFunctor);

REGISTER_OPERATOR(
    matrix_power_grad,
    ops::MatrixPowerGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::MatrixPowerGradInferShapeFunctor);

REGISTER_OPERATOR(
    maxout_grad,
    ops::MaxoutGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::MaxoutGradInferShapeFunctor);

REGISTER_OPERATOR(
    mode_grad,
    ops::ModeGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ModeGradInferShapeFunctor);

REGISTER_OPERATOR(
    mv_grad,
    ops::MvGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::MvGradInferShapeFunctor);

REGISTER_OPERATOR(
    nll_loss_grad,
    ops::NllLossGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::NllLossGradInferShapeFunctor);

REGISTER_OPERATOR(
    poisson_grad,
    ops::PoissonGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::PoissonGradInferShapeFunctor);

REGISTER_OPERATOR(
    put_along_axis_grad,
    ops::PutAlongAxisGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::PutAlongAxisGradInferShapeFunctor);

REGISTER_OPERATOR(
    qr_grad,
    ops::QrGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::QrGradInferShapeFunctor);

REGISTER_OPERATOR(
    reciprocal_grad,
    ops::ReciprocalGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ReciprocalGradInplaceInferer,
    ops::ReciprocalGradInferShapeFunctor);

REGISTER_OPERATOR(
    relu_grad_grad,
    ops::ReluGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ReluGradGradInplaceInferer,
    ops::ReluGradGradInferShapeFunctor);

REGISTER_OPERATOR(relu_grad,
                  ops::ReluGradOp,
                  ops::ReluGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::ReluGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::ReluGradInplaceInferer,
                  ops::ReluGradInferShapeFunctor);

REGISTER_OPERATOR(
    renorm_grad,
    ops::RenormGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::RenormGradInferShapeFunctor);

REGISTER_OPERATOR(
    round_grad,
    ops::RoundGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::RoundGradInplaceInferer,
    ops::RoundGradInferShapeFunctor);

REGISTER_OPERATOR(
    rsqrt_grad_grad,
    ops::RsqrtGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::RsqrtGradGradInplaceInferer,
    ops::RsqrtGradGradInferShapeFunctor);

REGISTER_OPERATOR(rsqrt_grad,
                  ops::RsqrtGradOp,
                  ops::RsqrtGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::RsqrtGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::RsqrtGradInplaceInferer,
                  ops::RsqrtGradInferShapeFunctor);

REGISTER_OPERATOR(
    graph_send_uv_grad,
    ops::GraphSendUvGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::GraphSendUvGradInferShapeFunctor);

REGISTER_OPERATOR(sigmoid_grad_grad,
                  ops::SigmoidGradGradOp,
                  ops::SigmoidTripleGradOpMaker<paddle::framework::OpDesc>,
                  ops::SigmoidTripleGradOpMaker<paddle::imperative::OpBase>,
                  ops::SigmoidGradGradInplaceInferer,
                  ops::SigmoidGradGradInferShapeFunctor);

REGISTER_OPERATOR(sigmoid_grad,
                  ops::SigmoidGradOp,
                  ops::SigmoidGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::SigmoidGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::SigmoidGradInplaceInferer,
                  ops::SigmoidGradInferShapeFunctor);

REGISTER_OPERATOR(
    sigmoid_triple_grad,
    ops::SigmoidTripleGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SigmoidTripleGradInplaceInferer,
    ops::SigmoidTripleGradInferShapeFunctor);

REGISTER_OPERATOR(
    silu_grad,
    ops::SiluGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SiluGradInplaceInferer,
    ops::SiluGradInferShapeFunctor);

REGISTER_OPERATOR(sin_double_grad,
                  ops::SinDoubleGradOp,
                  ops::SinTripleGradOpMaker<paddle::framework::OpDesc>,
                  ops::SinTripleGradOpMaker<paddle::imperative::OpBase>,
                  ops::SinDoubleGradInplaceInferer,
                  ops::SinDoubleGradInferShapeFunctor);

REGISTER_OPERATOR(sin_grad,
                  ops::SinGradOp,
                  ops::SinDoubleGradOpMaker<paddle::framework::OpDesc>,
                  ops::SinDoubleGradOpMaker<paddle::imperative::OpBase>,
                  ops::SinGradInplaceInferer,
                  ops::SinGradInferShapeFunctor);

REGISTER_OPERATOR(
    sin_triple_grad,
    ops::SinTripleGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SinTripleGradInplaceInferer,
    ops::SinTripleGradInferShapeFunctor);

REGISTER_OPERATOR(
    sinh_grad,
    ops::SinhGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SinhGradInplaceInferer,
    ops::SinhGradInferShapeFunctor);

REGISTER_OPERATOR(
    softplus_grad,
    ops::SoftplusGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SoftplusGradInplaceInferer,
    ops::SoftplusGradInferShapeFunctor);

REGISTER_OPERATOR(
    softshrink_grad,
    ops::SoftshrinkGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SoftshrinkGradInplaceInferer,
    ops::SoftshrinkGradInferShapeFunctor);

REGISTER_OPERATOR(
    softsign_grad,
    ops::SoftsignGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SoftsignGradInplaceInferer,
    ops::SoftsignGradInferShapeFunctor);

REGISTER_OPERATOR(
    solve_grad,
    ops::SolveGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SolveGradInferShapeFunctor);

REGISTER_OPERATOR(
    sqrt_grad_grad,
    ops::SqrtGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SqrtGradGradInplaceInferer,
    ops::SqrtGradGradInferShapeFunctor);

REGISTER_OPERATOR(sqrt_grad,
                  ops::SqrtGradOp,
                  ops::SqrtGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::SqrtGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::SqrtGradInplaceInferer,
                  ops::SqrtGradInferShapeFunctor);

REGISTER_OPERATOR(
    square_grad_grad,
    ops::SquareGradGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SquareGradGradInplaceInferer,
    ops::SquareGradGradInferShapeFunctor);

REGISTER_OPERATOR(square_grad,
                  ops::SquareGradOp,
                  ops::SquareGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::SquareGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::SquareGradInplaceInferer,
                  ops::SquareGradInferShapeFunctor);

REGISTER_OPERATOR(
    svd_grad,
    ops::SvdGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::SvdGradInferShapeFunctor);

REGISTER_OPERATOR(
    take_along_axis_grad,
    ops::TakeAlongAxisGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TakeAlongAxisGradInferShapeFunctor);

REGISTER_OPERATOR(
    tan_grad,
    ops::TanGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TanGradInplaceInferer,
    ops::TanGradInferShapeFunctor);

REGISTER_OPERATOR(tanh_grad_grad,
                  ops::TanhGradGradOp,
                  ops::TanhTripleGradOpMaker<paddle::framework::OpDesc>,
                  ops::TanhTripleGradOpMaker<paddle::imperative::OpBase>,
                  ops::TanhGradGradInplaceInferer,
                  ops::TanhGradGradInferShapeFunctor);

REGISTER_OPERATOR(tanh_grad,
                  ops::TanhGradOp,
                  ops::TanhGradGradOpMaker<paddle::framework::OpDesc>,
                  ops::TanhGradGradOpMaker<paddle::imperative::OpBase>,
                  ops::TanhGradInplaceInferer,
                  ops::TanhGradInferShapeFunctor);

REGISTER_OPERATOR(
    tanh_shrink_grad,
    ops::TanhShrinkGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TanhShrinkGradInplaceInferer,
    ops::TanhShrinkGradInferShapeFunctor);

REGISTER_OPERATOR(
    tanh_triple_grad,
    ops::TanhTripleGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TanhTripleGradInplaceInferer,
    ops::TanhTripleGradInferShapeFunctor);

REGISTER_OPERATOR(
    thresholded_relu_grad,
    ops::ThresholdedReluGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::ThresholdedReluGradInplaceInferer,
    ops::ThresholdedReluGradInferShapeFunctor);

REGISTER_OPERATOR(
    top_k_v2_grad,
    ops::TopKV2GradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TopKV2GradInferShapeFunctor);

REGISTER_OPERATOR(
    trace_grad,
    ops::TraceGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TraceGradNoNeedBufferVarInferer,
    ops::TraceGradInferShapeFunctor);

REGISTER_OPERATOR(
    trunc_grad,
    ops::TruncGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::TruncGradInferShapeFunctor);

REGISTER_OPERATOR(
    unfold_grad,
    ops::UnfoldGradOp,
    paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
    paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
    ops::UnfoldGradNoNeedBufferVarInferer,
    ops::UnfoldGradInferShapeFunctor);

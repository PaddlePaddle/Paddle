{% from "operator_utils.c.j2" import op_maker, backward_op_maker, backward_op_reused_maker, operator, register_op_with_components, register_op_version, composite_grad_op_maker %}
// this file is generated by paddle/phi/api/generator/generate_op.py, do not edit.
#include <string>
#include "paddle/fluid/framework/convert_utils.h"
#include "paddle/fluid/framework/infershape_utils.h"
#include "paddle/fluid/framework/op_registry.h"
#include "paddle/fluid/framework/op_version_registry.h"
#include "paddle/fluid/prim/api/composite_backward/composite_backward_api.h"
#include "paddle/fluid/prim/utils/static/composite_grad_desc_maker.h"
#include "paddle/fluid/prim/utils/static/desc_tensor.h"
#include "paddle/fluid/operators/generator/get_expected_kernel_func.h"
#include "paddle/phi/core/infermeta_utils.h"
#include "paddle/phi/infermeta/backward.h"
#include "paddle/phi/infermeta/binary.h"
#include "paddle/phi/infermeta/fusion.h"
#include "paddle/phi/infermeta/multiary.h"
#include "paddle/phi/infermeta/nullary.h"
#include "paddle/phi/infermeta/ternary.h"
#include "paddle/phi/infermeta/unary.h"

namespace paddle {
namespace operators {

using paddle::framework::GradVarName;

{% for op in ops %}
  {% if op is base_op %}

{{op_maker(op)}}

{{operator(op)}}
  {% endif %}
{% endfor %}

{% for op in backward_ops %}
  {% if op is base_op %}

{{backward_op_maker(op, op_dict[op["forward"]["name"]])}}

{{operator(op)}}
  {% elif op is only_composite_op %}

  {% else %}
{{backward_op_reused_maker(op, op_dict[op["forward"]["name"]], op["invoke"])}}
  {% endif %}
  {% if op is composite_op %}
{{composite_grad_op_maker(op_dict[op["name"]], op_dict[op["forward"]["name"]])}}
  {% endif %}
{% endfor %}
}  // namespace operators
}  // namespace paddle

namespace ops = paddle::operators;
{% for op in ops + backward_ops %}
{% if op is base_op %}
{{register_op_with_components(op)}}
{{register_op_version(op)}}
{% endif %}
{% endfor %}

// This file is generated by "paddle/fluid/pir/dialect/op_generator/op_gen.py"
#include "/home/aistudio/fix_op/Paddle/paddle/fluid/pir/dialect/operator/ir/pd_op.h"
#include "paddle/fluid/pir/dialect/operator/ir/op_type.h"
#include "paddle/fluid/pir/dialect/operator/ir/op_attribute.h"
#include "paddle/fluid/pir/dialect/operator/ir/ir_tensor.h"
#include "paddle/fluid/pir/dialect/operator/ir/ir_selected_rows.h"
#include "paddle/fluid/pir/dialect/operator/ir/ir_meta_tensor.h"
#include "paddle/pir/core/builtin_attribute.h"
#include "paddle/pir/core/builtin_type.h"
#include "paddle/pir/core/builtin_op.h"
#include "paddle/pir/core/ir_context.h"
#include "paddle/phi/core/enforce.h"
#include "paddle/phi/core/dense_tensor.h"
#include "paddle/phi/infermeta/binary.h"
#include "paddle/phi/infermeta/multiary.h"
#include "paddle/phi/infermeta/nullary.h"
#include "paddle/phi/infermeta/unary.h"
#include "paddle/phi/infermeta/ternary.h"
#include "paddle/phi/infermeta/backward.h"
#include "paddle/phi/infermeta/fusion.h"
#include "paddle/phi/api/lib/utils/allocator.h"
#include "paddle/fluid/primitive/rule/vjp/vjp.h"
#include "paddle/pir/core/op_base.h"

namespace paddle {
namespace dialect {

const char *ArangeOp::attributes_name[2] = { "dtype", "place" };

OpInfoTuple ArangeOp::GetOpInfo() {
  std::vector<paddle::dialect::OpInputInfo> inputs = { paddle::dialect::OpInputInfo("start", "paddle::dialect::ScalarAttribute", false, false, true, false), paddle::dialect::OpInputInfo("end", "paddle::dialect::ScalarAttribute", false, false, true, false), paddle::dialect::OpInputInfo("step", "paddle::dialect::ScalarAttribute", false, false, true, false) };
  std::vector<paddle::dialect::OpAttributeInfo> attributes = { paddle::dialect::OpAttributeInfo("dtype", "paddle::dialect::DataTypeAttribute", ""), paddle::dialect::OpAttributeInfo("place", "paddle::dialect::PlaceAttribute", "") };
  std::vector<paddle::dialect::OpOutputInfo> outputs = { paddle::dialect::OpOutputInfo("out", "paddle::dialect::DenseTensorType", false, false) };
  paddle::dialect::OpRunTimeInfo run_time_info = paddle::dialect::OpRunTimeInfo("ArangeInferMeta", {"start", "end", "step", "dtype"}, "arange", {"start", "end", "step"}, {"dtype"}, {"place"}, {}, {});
  return std::make_tuple(inputs, attributes, outputs, run_time_info, "arange");
}

void ArangeOp::Build(pir::Builder &builder, pir::OperationArgument &argument, float start, float end, float step, phi::DataType dtype, const Place& place) {
  VLOG(4) << "Start build ArangeOp";


  // Generate scalar mutable attribute: start
  paddle::dialect::FullOp full_start_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, start, phi::DataType::FLOAT32, phi::CPUPlace());
  pir::OpResult start_ = full_start_op->result(0);
      // Generate scalar mutable attribute: end
  paddle::dialect::FullOp full_end_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, end, phi::DataType::FLOAT32, phi::CPUPlace());
  pir::OpResult end_ = full_end_op->result(0);
      // Generate scalar mutable attribute: step
  paddle::dialect::FullOp full_step_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, step, phi::DataType::FLOAT32, phi::CPUPlace());
  pir::OpResult step_ = full_step_op->result(0);
    
  VLOG(4) << "Builder construction inputs";
  std::vector<pir::Value> argument_inputs = {start_, end_, step_};
  argument.AddInputs(argument_inputs);

  VLOG(4) << "Builder construction attributes";
  pir::Attribute attr_dtype = paddle::dialect::DataTypeAttribute::get(pir::IrContext::Instance(), dtype);
  argument.AddAttribute("dtype", attr_dtype);
  pir::Attribute attr_place = paddle::dialect::PlaceAttribute::get(pir::IrContext::Instance(), place);
  argument.AddAttribute("place", attr_place);

  VLOG(4) << "Builder construction outputs";
  paddle::dialect::IrTensor dense_out;
  paddle::dialect::IrMetaTensor meta_out(&dense_out);

  phi::ArangeInferMeta(start, end, step, dtype, &meta_out);

  std::vector<pir::Type> argument_outputs;
  pir::Type out_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_out.dtype()), dense_out.dims(), dense_out.layout(), dense_out.lod(), dense_out.offset());
  argument_outputs.push_back(out_dense_tensor_type);
  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());
  ::pir::PassStopGradientsDefaultly(argument);

}

void ArangeOp::Build(pir::Builder &builder, pir::OperationArgument &argument, pir::AttributeMap attributes) {
  VLOG(4) << "Start build ArangeOp";


  IR_ENFORCE(
      attributes.find("start") != attributes.end(),
          "'start' Attribute is expected for ArangeOp. ");
  float start = attributes.at("start").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<float>();

  IR_ENFORCE(
      attributes.find("end") != attributes.end(),
          "'end' Attribute is expected for ArangeOp. ");
  float end = attributes.at("end").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<float>();

  IR_ENFORCE(
      attributes.find("step") != attributes.end(),
          "'step' Attribute is expected for ArangeOp. ");
  float step = attributes.at("step").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<float>();

  IR_ENFORCE(
      attributes.find("dtype") != attributes.end(),
          "'dtype' Attribute is expected for ArangeOp. ");
  phi::DataType dtype = attributes.at("dtype").dyn_cast<paddle::dialect::DataTypeAttribute>().data();

  IR_ENFORCE(
      attributes.find("place") != attributes.end(),
          "'place' Attribute is expected for ArangeOp. ");
  Place place = attributes.at("place").dyn_cast<paddle::dialect::PlaceAttribute>().data();

  // Generate scalar mutable attribute: start
  paddle::dialect::FullOp full_start_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, start, phi::DataType::FLOAT32, phi::CPUPlace());
  pir::OpResult start_ = full_start_op->result(0);
      // Generate scalar mutable attribute: end
  paddle::dialect::FullOp full_end_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, end, phi::DataType::FLOAT32, phi::CPUPlace());
  pir::OpResult end_ = full_end_op->result(0);
      // Generate scalar mutable attribute: step
  paddle::dialect::FullOp full_step_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, step, phi::DataType::FLOAT32, phi::CPUPlace());
  pir::OpResult step_ = full_step_op->result(0);
    
  VLOG(4) << "Builder construction inputs";
  std::vector<pir::Value> argument_inputs = {start_, end_, step_};
  argument.AddInputs(argument_inputs);

  VLOG(4) << "Builder construction attributes";
  pir::Attribute attr_dtype = paddle::dialect::DataTypeAttribute::get(pir::IrContext::Instance(), dtype);
  argument.AddAttribute("dtype", attr_dtype);
  pir::Attribute attr_place = paddle::dialect::PlaceAttribute::get(pir::IrContext::Instance(), place);
  argument.AddAttribute("place", attr_place);

  VLOG(4) << "Builder construction outputs";
  paddle::dialect::IrTensor dense_out;
  paddle::dialect::IrMetaTensor meta_out(&dense_out);

  phi::ArangeInferMeta(start, end, step, dtype, &meta_out);

  std::vector<pir::Type> argument_outputs;
  pir::Type out_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_out.dtype()), dense_out.dims(), dense_out.layout(), dense_out.lod(), dense_out.offset());
  argument_outputs.push_back(out_dense_tensor_type);
  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());
  ::pir::PassStopGradientsDefaultly(argument);

}

void ArangeOp::Build(pir::Builder &builder, pir::OperationArgument &argument, pir::Value start_, pir::Value end_, pir::Value step_, phi::DataType dtype, const Place& place) {
  VLOG(4) << "Start build ArangeOp";



  VLOG(4) << "Builder construction inputs";
  std::vector<pir::Value> argument_inputs = {start_, end_, step_};
  argument.AddInputs(argument_inputs);

  VLOG(4) << "Builder construction attributes";
  pir::Attribute attr_dtype = paddle::dialect::DataTypeAttribute::get(pir::IrContext::Instance(), dtype);
  argument.AddAttribute("dtype", attr_dtype);
  pir::Attribute attr_place = paddle::dialect::PlaceAttribute::get(pir::IrContext::Instance(), place);
  argument.AddAttribute("place", attr_place);

  VLOG(4) << "Builder construction outputs";
  phi::Scalar start;
  if (start_.dyn_cast<pir::OpResult>() && start_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {
    start = std::move(phi::Scalar(start_.dyn_cast<pir::OpResult>().owner()
                                  ->dyn_cast<paddle::dialect::FullOp>()
                                  .attribute("value")
                                  .dyn_cast<paddle::dialect::ScalarAttribute>()
                                  .data()
                                  .to<int>()));
  }
  else {
    start = std::move(phi::Scalar(-1));
    start.SetFromTensor(true);
  }
  phi::Scalar end;
  if (end_.dyn_cast<pir::OpResult>() && end_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {
    end = std::move(phi::Scalar(end_.dyn_cast<pir::OpResult>().owner()
                                  ->dyn_cast<paddle::dialect::FullOp>()
                                  .attribute("value")
                                  .dyn_cast<paddle::dialect::ScalarAttribute>()
                                  .data()
                                  .to<int>()));
  }
  else {
    end = std::move(phi::Scalar(-1));
    end.SetFromTensor(true);
  }
  phi::Scalar step;
  if (step_.dyn_cast<pir::OpResult>() && step_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {
    step = std::move(phi::Scalar(step_.dyn_cast<pir::OpResult>().owner()
                                  ->dyn_cast<paddle::dialect::FullOp>()
                                  .attribute("value")
                                  .dyn_cast<paddle::dialect::ScalarAttribute>()
                                  .data()
                                  .to<int>()));
  }
  else {
    step = std::move(phi::Scalar(-1));
    step.SetFromTensor(true);
  }

  paddle::dialect::IrTensor dense_out;
  paddle::dialect::IrMetaTensor meta_out(&dense_out);

  phi::ArangeInferMeta(start, end, step, dtype, &meta_out);

  std::vector<pir::Type> argument_outputs;
  pir::Type out_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_out.dtype()), dense_out.dims(), dense_out.layout(), dense_out.lod(), dense_out.offset());
  argument_outputs.push_back(out_dense_tensor_type);
  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());
  ::pir::PassStopGradientsDefaultly(argument);

}

void ArangeOp::VerifySig() {
  VLOG(4) << "Start Verifying inputs, outputs and attributes for: ArangeOp.";
  VLOG(4) << "Verifying inputs:";
  {
  auto input_size = num_operands();
  IR_ENFORCE(input_size == 3u,
                    "The size %d of inputs must be equal to 3.", input_size);
  IR_ENFORCE((*this)->operand_source(0).type().isa<paddle::dialect::DenseTensorType>(),
                  "Type validation failed for the 0th input, got %s.", (*this)->operand_source(0).type());
  IR_ENFORCE((*this)->operand_source(1).type().isa<paddle::dialect::DenseTensorType>(),
                  "Type validation failed for the 1th input, got %s.", (*this)->operand_source(1).type());
  IR_ENFORCE((*this)->operand_source(2).type().isa<paddle::dialect::DenseTensorType>(),
                  "Type validation failed for the 2th input, got %s.", (*this)->operand_source(2).type());
  }
  VLOG(4) << "Verifying attributes:";
  {
  auto& attributes = this->attributes();
  IR_ENFORCE(attributes.count("dtype")>0,
                 "dtype does not exist.");
  IR_ENFORCE(attributes.at("dtype").isa<paddle::dialect::DataTypeAttribute>(),
                 "Type of attribute: dtype is not paddle::dialect::DataTypeAttribute.");

  IR_ENFORCE(attributes.count("place")>0,
                 "place does not exist.");
  IR_ENFORCE(attributes.at("place").isa<paddle::dialect::PlaceAttribute>(),
                 "Type of attribute: place is not paddle::dialect::PlaceAttribute.");

  }
  VLOG(4) << "Verifying outputs:";
  {
  auto output_size = num_results();
  IR_ENFORCE(output_size == 1u,
                    "The size %d of outputs must be equal to 1.", output_size);
  IR_ENFORCE((*this)->result(0).type().isa<paddle::dialect::DenseTensorType>(),
                 "Type validation failed for the 0th output.");
  }
  VLOG(4) << "End Verifying for: ArangeOp.";
}

void ArangeOp::InferMeta( phi::InferMetaContext *infer_meta ) {
  auto fn = PD_INFER_META(phi::ArangeInferMeta);
  fn(infer_meta);
}

phi::DataType ArangeOp::GetKernelTypeForVar(
    const std::string& var_name,
    const phi::DataType& tensor_dtype,
    const phi::DataType& expected_kernel_dtype) {
  VLOG(4) << "Get KernelType for Var of op: ArangeOp";
  


  return expected_kernel_dtype;
}

const char *SequenceMaskOp::attributes_name[1] = { "out_dtype" };

OpInfoTuple SequenceMaskOp::GetOpInfo() {
  std::vector<paddle::dialect::OpInputInfo> inputs = { paddle::dialect::OpInputInfo("x", "paddle::dialect::DenseTensorType", false, false, false, false), paddle::dialect::OpInputInfo("max_len", "paddle::dialect::ScalarAttribute", false, false, true, false) };
  std::vector<paddle::dialect::OpAttributeInfo> attributes = { paddle::dialect::OpAttributeInfo("out_dtype", "pir::Int32Attribute", "") };
  std::vector<paddle::dialect::OpOutputInfo> outputs = { paddle::dialect::OpOutputInfo("y", "paddle::dialect::DenseTensorType", false, false) };
  paddle::dialect::OpRunTimeInfo run_time_info = paddle::dialect::OpRunTimeInfo("SequenceMaskScalarInferMeta", {"x", "max_len", "out_dtype"}, "sequence_mask_scalar", {"x", "max_len", "out_dtype"}, {"x"}, {}, {}, {});
  return std::make_tuple(inputs, attributes, outputs, run_time_info, "sequence_mask");
}

void SequenceMaskOp::Build(pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, int max_len, int out_dtype) {
  VLOG(4) << "Start build SequenceMaskOp";


  // Generate scalar mutable attribute: max_len
  paddle::dialect::FullOp full_max_len_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, max_len, phi::DataType::INT32, phi::CPUPlace());
  pir::OpResult max_len_ = full_max_len_op->result(0);
    
  VLOG(4) << "Builder construction inputs";
  std::vector<pir::Value> argument_inputs = {x_, max_len_};
  argument.AddInputs(argument_inputs);

  VLOG(4) << "Builder construction attributes";
  pir::Attribute attr_out_dtype = pir::Int32Attribute::get(pir::IrContext::Instance(), out_dtype);
  argument.AddAttribute("out_dtype", attr_out_dtype);

  VLOG(4) << "Builder construction outputs";
  paddle::dialect::DenseTensorType x = x_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void)x;

  VLOG(4) << "Builder construction  dense_x";
  paddle::dialect::IrTensor ir_tensor_x(paddle::dialect::TransToPhiDataType(x.dtype()),
                                                      x.dims(),
                                                      x.data_layout(),
                                                      x.lod(),
                                                      x.offset());
  VLOG(4) << "Builder construction  meta_x";
  paddle::dialect::IrMetaTensor meta_x(&ir_tensor_x);
  paddle::dialect::IrTensor dense_y;
  paddle::dialect::IrMetaTensor meta_y(&dense_y);

  phi::SequenceMaskScalarInferMeta(meta_x, max_len, out_dtype, &meta_y);

  std::vector<pir::Type> argument_outputs;
  pir::Type y_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_y.dtype()), dense_y.dims(), dense_y.layout(), dense_y.lod(), dense_y.offset());
  argument_outputs.push_back(y_dense_tensor_type);
  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());
  ::pir::PassStopGradientsDefaultly(argument);

}

void SequenceMaskOp::Build(pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, pir::AttributeMap attributes) {
  VLOG(4) << "Start build SequenceMaskOp";


  IR_ENFORCE(
      attributes.find("max_len") != attributes.end(),
          "'max_len' Attribute is expected for SequenceMaskOp. ");
  int max_len = attributes.at("max_len").dyn_cast<pir::Int32Attribute>().data();

  IR_ENFORCE(
      attributes.find("out_dtype") != attributes.end(),
          "'out_dtype' Attribute is expected for SequenceMaskOp. ");
  int out_dtype = attributes.at("out_dtype").dyn_cast<pir::Int32Attribute>().data();

  // Generate scalar mutable attribute: max_len
  paddle::dialect::FullOp full_max_len_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{1}, max_len, phi::DataType::INT32, phi::CPUPlace());
  pir::OpResult max_len_ = full_max_len_op->result(0);
    
  VLOG(4) << "Builder construction inputs";
  std::vector<pir::Value> argument_inputs = {x_, max_len_};
  argument.AddInputs(argument_inputs);

  VLOG(4) << "Builder construction attributes";
  pir::Attribute attr_out_dtype = pir::Int32Attribute::get(pir::IrContext::Instance(), out_dtype);
  argument.AddAttribute("out_dtype", attr_out_dtype);

  VLOG(4) << "Builder construction outputs";
  paddle::dialect::DenseTensorType x = x_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void)x;

  VLOG(4) << "Builder construction  dense_x";
  paddle::dialect::IrTensor ir_tensor_x(paddle::dialect::TransToPhiDataType(x.dtype()),
                                                      x.dims(),
                                                      x.data_layout(),
                                                      x.lod(),
                                                      x.offset());
  VLOG(4) << "Builder construction  meta_x";
  paddle::dialect::IrMetaTensor meta_x(&ir_tensor_x);
  paddle::dialect::IrTensor dense_y;
  paddle::dialect::IrMetaTensor meta_y(&dense_y);

  phi::SequenceMaskScalarInferMeta(meta_x, max_len, out_dtype, &meta_y);

  std::vector<pir::Type> argument_outputs;
  pir::Type y_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_y.dtype()), dense_y.dims(), dense_y.layout(), dense_y.lod(), dense_y.offset());
  argument_outputs.push_back(y_dense_tensor_type);
  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());
  ::pir::PassStopGradientsDefaultly(argument);

}

void SequenceMaskOp::Build(pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, pir::Value max_len_, int out_dtype) {
  VLOG(4) << "Start build SequenceMaskOp";



  VLOG(4) << "Builder construction inputs";
  std::vector<pir::Value> argument_inputs = {x_, max_len_};
  argument.AddInputs(argument_inputs);

  VLOG(4) << "Builder construction attributes";
  pir::Attribute attr_out_dtype = pir::Int32Attribute::get(pir::IrContext::Instance(), out_dtype);
  argument.AddAttribute("out_dtype", attr_out_dtype);

  VLOG(4) << "Builder construction outputs";
  paddle::dialect::DenseTensorType x = x_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void)x;
  phi::Scalar max_len;
  if (max_len_.dyn_cast<pir::OpResult>() && max_len_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {
    max_len = std::move(phi::Scalar(max_len_.dyn_cast<pir::OpResult>().owner()
                                  ->dyn_cast<paddle::dialect::FullOp>()
                                  .attribute("value")
                                  .dyn_cast<paddle::dialect::ScalarAttribute>()
                                  .data()
                                  .to<int>()));
  }
  else {
    max_len = std::move(phi::Scalar(-1));
    max_len.SetFromTensor(true);
  }


  VLOG(4) << "Builder construction  dense_x";
  paddle::dialect::IrTensor ir_tensor_x(paddle::dialect::TransToPhiDataType(x.dtype()),
                                                      x.dims(),
                                                      x.data_layout(),
                                                      x.lod(),
                                                      x.offset());
  VLOG(4) << "Builder construction  meta_x";
  paddle::dialect::IrMetaTensor meta_x(&ir_tensor_x);
  paddle::dialect::IrTensor dense_y;
  paddle::dialect::IrMetaTensor meta_y(&dense_y);

  phi::SequenceMaskScalarInferMeta(meta_x, max_len, out_dtype, &meta_y);

  std::vector<pir::Type> argument_outputs;
  pir::Type y_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_y.dtype()), dense_y.dims(), dense_y.layout(), dense_y.lod(), dense_y.offset());
  argument_outputs.push_back(y_dense_tensor_type);
  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());
  ::pir::PassStopGradientsDefaultly(argument);

}

void SequenceMaskOp::VerifySig() {
  VLOG(4) << "Start Verifying inputs, outputs and attributes for: SequenceMaskOp.";
  VLOG(4) << "Verifying inputs:";
  {
  auto input_size = num_operands();
  IR_ENFORCE(input_size == 2u,
                    "The size %d of inputs must be equal to 2.", input_size);
  IR_ENFORCE((*this)->operand_source(0).type().isa<paddle::dialect::DenseTensorType>(),
                  "Type validation failed for the 0th input, got %s.", (*this)->operand_source(0).type());
  IR_ENFORCE((*this)->operand_source(1).type().isa<paddle::dialect::DenseTensorType>(),
                  "Type validation failed for the 1th input, got %s.", (*this)->operand_source(1).type());
  }
  VLOG(4) << "Verifying attributes:";
  {
  auto& attributes = this->attributes();
  IR_ENFORCE(attributes.count("out_dtype")>0,
                 "out_dtype does not exist.");
  IR_ENFORCE(attributes.at("out_dtype").isa<pir::Int32Attribute>(),
                 "Type of attribute: out_dtype is not pir::Int32Attribute.");

  }
  VLOG(4) << "Verifying outputs:";
  {
  auto output_size = num_results();
  IR_ENFORCE(output_size == 1u,
                    "The size %d of outputs must be equal to 1.", output_size);
  IR_ENFORCE((*this)->result(0).type().isa<paddle::dialect::DenseTensorType>(),
                 "Type validation failed for the 0th output.");
  }
  VLOG(4) << "End Verifying for: SequenceMaskOp.";
}

void SequenceMaskOp::InferMeta( phi::InferMetaContext *infer_meta ) {
  auto fn = PD_INFER_META(phi::SequenceMaskScalarInferMeta);
  fn(infer_meta);
}

phi::DataType SequenceMaskOp::GetKernelTypeForVar(
    const std::string& var_name,
    const phi::DataType& tensor_dtype,
    const phi::DataType& expected_kernel_dtype) {
  VLOG(4) << "Get KernelType for Var of op: SequenceMaskOp";
  


  return expected_kernel_dtype;
}

} // namespace dialect
} // namespace paddle


IR_DEFINE_EXPLICIT_TYPE_ID(paddle::dialect::ArangeOp)

IR_DEFINE_EXPLICIT_TYPE_ID(paddle::dialect::SequenceMaskOp)


//   Copyright (c) 2018 PaddlePaddle Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#include "paddle/fluid/platform/place.h"

namespace paddle {
namespace framework {
namespace details {
class OpHandleBase;

// VarHandleBase is the var node in the dependency graph.
// A variable can only be generated by a single operator. i.e.
// This is a single assignment graph.
struct VarHandleBase {
  virtual ~VarHandleBase();
  virtual std::string DebugString() const = 0;

  // The operator who generate this variable. nullptr if the variable
  // is a root node.
  OpHandleBase* generated_op_{nullptr};

  // Operators which depend on this variable ready.
  std::unordered_set<OpHandleBase*> pending_ops_;
};

// VarHandle is actually a single version of Runtime Variable.
// Variable in Runtime mapped to many VarHandles in Graph.
// Each assignment will generate a new var handle with newer version.
//
// NOTE: runtime variables have place.
struct VarHandle : public VarHandleBase {
  std::string DebugString() const override;

  VarHandle(size_t version, size_t scope_index, std::string name,
            platform::Place place)
      : version_(version),
        scope_idx_(scope_index),
        name_(std::move(name)),
        place_(std::move(place)) {}

  // version field currently is not used, however, just store the version to
  // debug easily.
  size_t version_;
  size_t scope_idx_;
  std::string name_;
  platform::Place place_;
};

// Dummy Variable. It is used to represent dependencies between operators
struct DummyVarHandle : public VarHandleBase {
  std::string DebugString() const override;
};

/// variable unique_id generator, threadsafe singleton.
class UUIDGenerator {
public:
  int operator()(const std::string& name) { return hasher(name); }
  int Hash(const std::string& name) { return hasher(name); }
  static UUIDGenerator& Instance() {
    std::call_once(once_flag, &UUIDGenerator::InitOnce);
    return *g;
  }

private:
  static void InitOnce() { g = new UUIDGenerator(); }
  UUIDGenerator() {}
  std::hash<std::string> hasher;
  static UUIDGenerator* g;
  static std::once_flag once_flag;
  DISABLE_COPY_AND_ASSIGN(UUIDGenerator);
};

UUIDGenerator* UUIDGenerator::g = nullptr;
std::once_flag UUIDGenerator::once_flag;

// a runtime unique variable identity.
struct VarUUID {
  explicit VarUUID(const std::string& name) : name(name) {
    // UUIDGenerator& gen = UUIDGenerator::Instance();
    // unique_id = gen(name);
    unique_id = UUIDGenerator::Instance()(name);
  }
  VarUUID(const std::string& name, int id) : name(name), unique_id(id) {}
  bool operator==(const VarUUID& rhs) const {
    return unique_id == rhs.unique_id;
  }
  bool operator!=(const VarUUID& rhs) const {
    return unique_id != rhs.unique_id;
  }
  std::string name;
  int unique_id; /*default -1 if uninitialized*/
};

struct VarUUIDHash {
  size_t operator()(const VarUUID& id) const { return id.unique_id; }
};

inline std::ostream& operator<<(std::ostream& os, const VarUUID& var) {
  os << var.name;
  if (VLOG_IS_ON(5)) {
    os << "[" << var.unique_id << "]";
  }
  return os;
}


}  // namespace details
}  // namespace framework
}  // namespace paddle

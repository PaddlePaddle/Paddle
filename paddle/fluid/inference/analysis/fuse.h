/* Copyright (c) 2018 PaddlePaddle Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. */

#ifdef PADDLE_WITH_TESTING
#include <gtest/gtest_prod.h>
#endif

#include "paddle/fluid/inference/analysis/data_flow_graph.h"
#include "paddle/fluid/inference/analysis/node.h"

namespace paddle {
namespace inference {
namespace analysis {
namespace fuse {

struct PatternRecord;

using hit_t = std::pair<Node*, int32_t>;

class Pattern {
 public:
  using handle_t =
      std::function<void(const PatternRecord& pattern, DataFlowGraph* graph)>;

  FusePatternNode* AddNode();
  void AddEdge(FusePatternNode* source, FusePatternNode* target);
  void SetHandle(const handle_t& handle);

  // Extract all the sub-graphs that match a pattern, mark the nodes with a
  // pattern-id(unique for different matched results).
  std::vector<PatternRecord> Match(DataFlowGraph* graph);

  // Fuse the nodes inside a pattern with a Node generated by a `handle`.
  void Fuse(DataFlowGraph* graph);

 private:
  void MarkNodesInPattern(DataFlowGraph* graph);

  // std::vector<std::pair<hit_t, hit_t>> Extract2GramPatterns( DataFlowGraph*
  // graph);

  std::vector<PatternRecord> ExtractPatterns(DataFlowGraph* graph);

 private:
#ifdef PADDLE_WITH_TESTING
  FRIEND_TEST(Pattern, AddNode);
  FRIEND_TEST(Pattern, AddEdge);
  FRIEND_TEST(Pattern, SetHandle);
  FRIEND_TEST(Pattern, Match);
  FRIEND_TEST(Pattern, Fuse);
  FRIEND_TEST(Pattern, MarkNodesInPattern);
  FRIEND_TEST(Pattern, ExtractPatterns);
#endif

  handle_t handle_;
  std::vector<std::pair<FusePatternNode*, FusePatternNode*>> edges_;
  DataFlowGraph pattern_graph_;
  std::unordered_map<int32_t /*pnode_id*/, std::unordered_set<Node*> /*nodes*/>
      pattern_to_node_map_;
};

struct PatternRecord {
  std::unordered_map<int32_t /*pattern id*/, Node*> symbol_table;
  std::vector<hit_t> hits;

  PatternRecord() = default;

  PatternRecord(const PatternRecord& o) = default;

  PatternRecord(int32_t pnode_id, Node* node) { MatchOrInsert(node, pnode_id); }

  PatternRecord(const hit_t& source, const hit_t target) {
    if (!MatchOrInsert(source.first, source.second)) return;
    if (!MatchOrInsert(target.first, target.second)) return;
  }

  bool is_valid() const { return valid_; }
  void set_valid() { valid_ = true; }
  void set_invalid() { valid_ = false; }

  bool MatchOrInsert(Node* node, int32_t pnode_id) {
    if (!symbol_table.count(pnode_id)) {
      symbol_table[pnode_id] = node;
    }
    return symbol_table[pnode_id] == node;
  }

  bool Match(const Node* node, int32_t pnode_id) const {
    return (!symbol_table.count(pnode_id)) || symbol_table.at(pnode_id) == node;
  }

 private:
#ifdef PADDLE_WITH_TESTING
  FRIEND_TEST(Pattern, Match);
  FRIEND_TEST(Pattern, MatchOrInsert);
#endif

  bool valid_{true};
};

}  // namespace fuse
}  // namespace analysis
}  // namespace inference
}  // namespace paddle

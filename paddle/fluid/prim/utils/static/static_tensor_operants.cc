// Generated by paddle/fluid/prim/api/auto_code_generated/tensor_operants_gen.py

#include "paddle/fluid/prim/utils/static/static_tensor_operants.h"

#include "paddle/fluid/prim/api/generated_prim/prim_generated_api.h"
#include "paddle/fluid/prim/utils/static/desc_tensor.h"


namespace paddle {

namespace prim {
using DescTensor = paddle::prim::DescTensor;

Tensor StaticTensorOperants::abs(const Tensor& x) {
  return paddle::prim::abs<DescTensor>(x);
}

Tensor StaticTensorOperants::add(const Tensor& x, const Tensor& y) {
  return paddle::prim::add<DescTensor>(x, y);
}

Tensor StaticTensorOperants::assign(const Tensor& x) {
  return paddle::prim::assign<DescTensor>(x);
}

Tensor StaticTensorOperants::divide(const Tensor& x, const Tensor& y) {
  return paddle::prim::divide<DescTensor>(x, y);
}

Tensor StaticTensorOperants::elementwise_pow(const Tensor& x, const Tensor& y) {
  return paddle::prim::elementwise_pow<DescTensor>(x, y);
}

Tensor StaticTensorOperants::expand(const Tensor& x, const IntArray& shape) {
  return paddle::prim::expand<DescTensor>(x, shape);
}

Tensor StaticTensorOperants::matmul(const Tensor& x, const Tensor& y, bool transpose_x, bool transpose_y) {
  return paddle::prim::matmul<DescTensor>(x, y, transpose_x, transpose_y);
}

Tensor StaticTensorOperants::max(const Tensor& x, const IntArray& axis, bool keepdim) {
  return paddle::prim::max<DescTensor>(x, axis, keepdim);
}

Tensor StaticTensorOperants::maximum(const Tensor& x, const Tensor& y) {
  return paddle::prim::maximum<DescTensor>(x, y);
}

Tensor StaticTensorOperants::minimum(const Tensor& x, const Tensor& y) {
  return paddle::prim::minimum<DescTensor>(x, y);
}

Tensor StaticTensorOperants::multiply(const Tensor& x, const Tensor& y) {
  return paddle::prim::multiply<DescTensor>(x, y);
}

Tensor StaticTensorOperants::prod(const Tensor& x, const IntArray& dims, bool keep_dim, bool reduce_all) {
  return paddle::prim::prod<DescTensor>(x, dims, keep_dim, reduce_all);
}

Tensor StaticTensorOperants::subtract(const Tensor& x, const Tensor& y) {
  return paddle::prim::subtract<DescTensor>(x, y);
}

Tensor StaticTensorOperants::sum(const Tensor& x, const IntArray& axis, DataType dtype, bool keepdim) {
  return paddle::prim::sum<DescTensor>(x, axis, dtype, keepdim);
}

Tensor StaticTensorOperants::tile(const Tensor& x, const IntArray& repeat_times) {
  return paddle::prim::tile<DescTensor>(x, repeat_times);
}

Tensor StaticTensorOperants::exp(const Tensor& x) {
  return paddle::prim::exp<DescTensor>(x);
}

Tensor StaticTensorOperants::floor(const Tensor& x) {
  return paddle::prim::floor<DescTensor>(x);
}

Tensor StaticTensorOperants::gather_nd(const Tensor& x, const Tensor& index) {
  return paddle::prim::gather_nd<DescTensor>(x, index);
}

Tensor StaticTensorOperants::log(const Tensor& x) {
  return paddle::prim::log<DescTensor>(x);
}

Tensor StaticTensorOperants::pow(const Tensor& x, const Scalar& y) {
  return paddle::prim::pow<DescTensor>(x, y);
}

Tensor StaticTensorOperants::roll(const Tensor& x, const IntArray& shifts, const std::vector<int64_t>& axis) {
  return paddle::prim::roll<DescTensor>(x, shifts, axis);
}

Tensor StaticTensorOperants::scale(const Tensor& x, const Scalar& scale, float bias, bool bias_after_scale) {
  return paddle::prim::scale<DescTensor>(x, scale, bias, bias_after_scale);
}

Tensor StaticTensorOperants::scatter(const Tensor& x, const Tensor& index, const Tensor& updates, bool overwrite) {
  return paddle::prim::scatter<DescTensor>(x, index, updates, overwrite);
}

Tensor StaticTensorOperants::scatter_nd_add(const Tensor& x, const Tensor& index, const Tensor& updates) {
  return paddle::prim::scatter_nd_add<DescTensor>(x, index, updates);
}

Tensor StaticTensorOperants::unsqueeze(const Tensor& x, const IntArray& axis) {
  return paddle::prim::unsqueeze<DescTensor>(x, axis);
}


}  // namespace prim
}  // namespace paddle


// Generated by paddle/fluid/prim/api/auto_code_generated/tensor_operants_gen.py

#include "paddle/fluid/prim/utils/eager/eager_tensor_operants.h"

#include "paddle/fluid/eager/api/generated/eager_generated/forwards/dygraph_functions.h"


namespace paddle {

namespace prim {

Tensor EagerTensorOperants::abs(const Tensor& x) {
  return ::abs_ad_func(x);
}

Tensor EagerTensorOperants::add(const Tensor& x, const Tensor& y) {
  return ::add_ad_func(x, y);
}

Tensor EagerTensorOperants::assign(const Tensor& x) {
  return ::assign_ad_func(x);
}

Tensor EagerTensorOperants::divide(const Tensor& x, const Tensor& y) {
  return ::divide_ad_func(x, y);
}

Tensor EagerTensorOperants::elementwise_pow(const Tensor& x, const Tensor& y) {
  return ::elementwise_pow_ad_func(x, y);
}

Tensor EagerTensorOperants::expand(const Tensor& x, const IntArray& shape) {
  return ::expand_ad_func(x, shape);
}

Tensor EagerTensorOperants::matmul(const Tensor& x, const Tensor& y, bool transpose_x, bool transpose_y) {
  return ::matmul_ad_func(x, y, transpose_x, transpose_y);
}

Tensor EagerTensorOperants::max(const Tensor& x, const IntArray& axis, bool keepdim) {
  return ::max_ad_func(x, axis, keepdim);
}

Tensor EagerTensorOperants::maximum(const Tensor& x, const Tensor& y) {
  return ::maximum_ad_func(x, y);
}

Tensor EagerTensorOperants::minimum(const Tensor& x, const Tensor& y) {
  return ::minimum_ad_func(x, y);
}

Tensor EagerTensorOperants::multiply(const Tensor& x, const Tensor& y) {
  return ::multiply_ad_func(x, y);
}

Tensor EagerTensorOperants::prod(const Tensor& x, const IntArray& dims, bool keep_dim, bool reduce_all) {
  return ::prod_ad_func(x, dims, keep_dim, reduce_all);
}

Tensor EagerTensorOperants::subtract(const Tensor& x, const Tensor& y) {
  return ::subtract_ad_func(x, y);
}

Tensor EagerTensorOperants::sum(const Tensor& x, const IntArray& axis, DataType dtype, bool keepdim) {
  return ::sum_ad_func(x, axis, dtype, keepdim);
}

Tensor EagerTensorOperants::tile(const Tensor& x, const IntArray& repeat_times) {
  return ::tile_ad_func(x, repeat_times);
}

Tensor EagerTensorOperants::exp(const Tensor& x) {
  return ::exp_ad_func(x);
}

Tensor EagerTensorOperants::floor(const Tensor& x) {
  return ::floor_ad_func(x);
}

Tensor EagerTensorOperants::gather_nd(const Tensor& x, const Tensor& index) {
  return ::gather_nd_ad_func(x, index);
}

Tensor EagerTensorOperants::log(const Tensor& x) {
  return ::log_ad_func(x);
}

Tensor EagerTensorOperants::pow(const Tensor& x, const Scalar& y) {
  return ::pow_ad_func(x, y);
}

Tensor EagerTensorOperants::roll(const Tensor& x, const IntArray& shifts, const std::vector<int64_t>& axis) {
  return ::roll_ad_func(x, shifts, axis);
}

Tensor EagerTensorOperants::scale(const Tensor& x, const Scalar& scale, float bias, bool bias_after_scale) {
  return ::scale_ad_func(x, scale, bias, bias_after_scale);
}

Tensor EagerTensorOperants::scatter(const Tensor& x, const Tensor& index, const Tensor& updates, bool overwrite) {
  return ::scatter_ad_func(x, index, updates, overwrite);
}

Tensor EagerTensorOperants::scatter_nd_add(const Tensor& x, const Tensor& index, const Tensor& updates) {
  return ::scatter_nd_add_ad_func(x, index, updates);
}

Tensor EagerTensorOperants::unsqueeze(const Tensor& x, const IntArray& axis) {
  return ::unsqueeze_ad_func(x, axis);
}


}  // namespace prim
}  // namespace paddle


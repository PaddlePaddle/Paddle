// Generated by paddle/phi/api/yaml/generator/tensor_operants_gen.py

#include "paddle/phi/api/include/tensor.h"

#include "paddle/phi/api/include/operants_manager.h"


namespace paddle {

Tensor Tensor::operator+(const Tensor &other) const {
  return add(other);
}

Tensor Tensor::operator-(const Tensor &other) const {
  return subtract(other);
}

Tensor Tensor::operator*(const Tensor &other) const {
  return multiply(other);
}

Tensor Tensor::operator/(const Tensor &other) const {
  return divide(other);
}

Tensor Tensor::operator+(const Scalar &other) const {
  return add(other);
}

Tensor Tensor::operator-(const Scalar &other) const {
  return subtract(other);
}

Tensor Tensor::operator*(const Scalar &other) const {
  return multiply(other);
}

Tensor Tensor::operator/(const Scalar &other) const {
  return divide(other);
}

Tensor Tensor::add(const Scalar& y) const {
  return paddle::OperantsManager::Instance().add(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::divide(const Scalar& y) const {
  return paddle::OperantsManager::Instance().divide(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::multiply(const Scalar& y) const {
  return paddle::OperantsManager::Instance().multiply(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::subtract(const Scalar& y) const {
  return paddle::OperantsManager::Instance().subtract(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::operator<(const Tensor &other) const {
  return less_than(other);
}

Tensor Tensor::operator<=(const Tensor &other) const {
  return less_equal(other);
}

Tensor Tensor::operator==(const Tensor &other) const {
  return equal(other);
}

Tensor Tensor::operator!=(const Tensor &other) const {
  return not_equal(other);
}

Tensor Tensor::operator>(const Tensor &other) const {
  return greater_than(other);
}

Tensor Tensor::operator>=(const Tensor &other) const {
  return greater_equal(other);
}

Tensor Tensor::operator-() const {
  return scale(-1.0, 0.0, true);
}

Tensor Tensor::operator~() const {
  return bitwise_not();
}

Tensor Tensor::operator&(const Tensor &other) const {
  return bitwise_and(other);
}

Tensor Tensor::operator|(const Tensor &other) const {
  return bitwise_or(other);
}

Tensor Tensor::operator^(const Tensor &other) const {
  return bitwise_xor(other);
}

Tensor Tensor::pow(const Tensor& y) const {
  return paddle::OperantsManager::Instance().pow(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::pow(const Scalar& y) const {
  return paddle::OperantsManager::Instance().pow(static_cast<const Tensor &>(*this), y);
}

PADDLE_API Tensor operator+(const Scalar& x, const Tensor& y) {
  return paddle::OperantsManager::Instance().add(x, y);
}

PADDLE_API Tensor operator-(const Scalar& x, const Tensor& y) {
  return paddle::OperantsManager::Instance().subtract(x, y);
}

PADDLE_API Tensor operator*(const Scalar& x, const Tensor& y) {
  return paddle::OperantsManager::Instance().multiply(x, y);
}

PADDLE_API Tensor operator/(const Scalar& x, const Tensor& y) {
  return paddle::OperantsManager::Instance().divide(x, y);
}

Tensor Tensor::abs() const {
  return paddle::OperantsManager::Instance().abs(static_cast<const Tensor &>(*this));
}

Tensor Tensor::bitwise_and(const Tensor& y) const {
  return paddle::OperantsManager::Instance().bitwise_and(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::bitwise_not() const {
  return paddle::OperantsManager::Instance().bitwise_not(static_cast<const Tensor &>(*this));
}

Tensor Tensor::bitwise_or(const Tensor& y) const {
  return paddle::OperantsManager::Instance().bitwise_or(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::bitwise_xor(const Tensor& y) const {
  return paddle::OperantsManager::Instance().bitwise_xor(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::exp() const {
  return paddle::OperantsManager::Instance().exp(static_cast<const Tensor &>(*this));
}

Tensor Tensor::expand(const IntArray& shape) const {
  return paddle::OperantsManager::Instance().expand(static_cast<const Tensor &>(*this), shape);
}

Tensor Tensor::floor() const {
  return paddle::OperantsManager::Instance().floor(static_cast<const Tensor &>(*this));
}

Tensor Tensor::gather_nd(const Tensor& index) const {
  return paddle::OperantsManager::Instance().gather_nd(static_cast<const Tensor &>(*this), index);
}

Tensor Tensor::log() const {
  return paddle::OperantsManager::Instance().log(static_cast<const Tensor &>(*this));
}

Tensor Tensor::roll(const IntArray& shifts, const std::vector<int64_t>& axis) const {
  return paddle::OperantsManager::Instance().roll(static_cast<const Tensor &>(*this), shifts, axis);
}

Tensor Tensor::scale(const Scalar& scale, const Scalar& bias, bool bias_after_scale) const {
  return paddle::OperantsManager::Instance().scale(static_cast<const Tensor &>(*this), scale, bias, bias_after_scale);
}

Tensor Tensor::scatter(const Tensor& index, const Tensor& updates, bool overwrite) const {
  return paddle::OperantsManager::Instance().scatter(static_cast<const Tensor &>(*this), index, updates, overwrite);
}

Tensor Tensor::scatter_nd_add(const Tensor& index, const Tensor& updates) const {
  return paddle::OperantsManager::Instance().scatter_nd_add(static_cast<const Tensor &>(*this), index, updates);
}

Tensor Tensor::add(const Tensor& y) const {
  return paddle::OperantsManager::Instance().add(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::assign() const {
  return paddle::OperantsManager::Instance().assign(static_cast<const Tensor &>(*this));
}

Tensor Tensor::divide(const Tensor& y) const {
  return paddle::OperantsManager::Instance().divide(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::elementwise_pow(const Tensor& y) const {
  return paddle::OperantsManager::Instance().elementwise_pow(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::equal(const Tensor& y) const {
  return paddle::OperantsManager::Instance().equal(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::greater_equal(const Tensor& y) const {
  return paddle::OperantsManager::Instance().greater_equal(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::greater_than(const Tensor& y) const {
  return paddle::OperantsManager::Instance().greater_than(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::less_equal(const Tensor& y) const {
  return paddle::OperantsManager::Instance().less_equal(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::less_than(const Tensor& y) const {
  return paddle::OperantsManager::Instance().less_than(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::matmul(const Tensor& y, bool transpose_x, bool transpose_y) const {
  return paddle::OperantsManager::Instance().matmul(static_cast<const Tensor &>(*this), y, transpose_x, transpose_y);
}

Tensor Tensor::max(const IntArray& axis, bool keepdim) const {
  return paddle::OperantsManager::Instance().max(static_cast<const Tensor &>(*this), axis, keepdim);
}

Tensor Tensor::maximum(const Tensor& y) const {
  return paddle::OperantsManager::Instance().maximum(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::minimum(const Tensor& y) const {
  return paddle::OperantsManager::Instance().minimum(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::multiply(const Tensor& y) const {
  return paddle::OperantsManager::Instance().multiply(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::not_equal(const Tensor& y) const {
  return paddle::OperantsManager::Instance().not_equal(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::subtract(const Tensor& y) const {
  return paddle::OperantsManager::Instance().subtract(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::sum(const IntArray& axis, DataType dtype, bool keepdim) const {
  return paddle::OperantsManager::Instance().sum(static_cast<const Tensor &>(*this), axis, dtype, keepdim);
}

Tensor Tensor::tile(const IntArray& repeat_times) const {
  return paddle::OperantsManager::Instance().tile(static_cast<const Tensor &>(*this), repeat_times);
}

}  // namespace paddle


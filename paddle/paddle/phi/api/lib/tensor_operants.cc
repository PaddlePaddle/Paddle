// Generated by paddle/phi/api/yaml/generator/tensor_operants_gen.py

#include "paddle/phi/api/include/tensor_operants.h"

#include "paddle/phi/api/include/api.h"


namespace paddle {

namespace operants {

Tensor PhiTensorOperants::add(const Tensor& x, const Scalar& y) {
  return paddle::experimental::add(x, paddle::experimental::full_like(x, y));
}

Tensor PhiTensorOperants::subtract(const Tensor& x, const Scalar& y) {
  return paddle::experimental::subtract(x, paddle::experimental::full_like(x, y));
}

Tensor PhiTensorOperants::multiply(const Tensor& x, const Scalar& y) {
  return paddle::experimental::scale(x, y, 0.0f, true);
}

Tensor PhiTensorOperants::divide(const Tensor& x, const Scalar& y) {
  return paddle::experimental::divide(x, paddle::experimental::full_like(x, y));
}

Tensor PhiTensorOperants::add(const Scalar& x, const Tensor& y) {
  return paddle::experimental::add(paddle::experimental::full_like(y, x), y);
}

Tensor PhiTensorOperants::subtract(const Scalar& x, const Tensor& y) {
  return paddle::experimental::subtract(paddle::experimental::full_like(y, x), y);
}

Tensor PhiTensorOperants::multiply(const Scalar& x, const Tensor& y) {
  return paddle::experimental::scale(y, x, 0.0f, true);
}

Tensor PhiTensorOperants::divide(const Scalar& x, const Tensor& y) {
  return paddle::experimental::divide(paddle::experimental::full_like(y, x), y);
}

Tensor PhiTensorOperants::pow(const Tensor& x, const Tensor& y) {
  return paddle::experimental::elementwise_pow(x, y);
}

Tensor PhiTensorOperants::pow(const Tensor& x, const Scalar& y) {
  return paddle::experimental::elementwise_pow(x, paddle::experimental::full_like(x, y));
}

Tensor PhiTensorOperants::abs(const Tensor& x) {
  return paddle::experimental::abs(x);
}

Tensor PhiTensorOperants::bitwise_and(const Tensor& x, const Tensor& y) {
  return paddle::experimental::bitwise_and(x, y);
}

Tensor PhiTensorOperants::bitwise_not(const Tensor& x) {
  return paddle::experimental::bitwise_not(x);
}

Tensor PhiTensorOperants::bitwise_or(const Tensor& x, const Tensor& y) {
  return paddle::experimental::bitwise_or(x, y);
}

Tensor PhiTensorOperants::bitwise_xor(const Tensor& x, const Tensor& y) {
  return paddle::experimental::bitwise_xor(x, y);
}

Tensor PhiTensorOperants::exp(const Tensor& x) {
  return paddle::experimental::exp(x);
}

Tensor PhiTensorOperants::expand(const Tensor& x, const IntArray& shape) {
  return paddle::experimental::expand(x, shape);
}

Tensor PhiTensorOperants::floor(const Tensor& x) {
  return paddle::experimental::floor(x);
}

Tensor PhiTensorOperants::gather_nd(const Tensor& x, const Tensor& index) {
  return paddle::experimental::gather_nd(x, index);
}

Tensor PhiTensorOperants::log(const Tensor& x) {
  return paddle::experimental::log(x);
}

Tensor PhiTensorOperants::roll(const Tensor& x, const IntArray& shifts, const std::vector<int64_t>& axis) {
  return paddle::experimental::roll(x, shifts, axis);
}

Tensor PhiTensorOperants::scale(const Tensor& x, const Scalar& scale, const Scalar& bias, bool bias_after_scale) {
  return paddle::experimental::scale(x, scale, bias, bias_after_scale);
}

Tensor PhiTensorOperants::scatter(const Tensor& x, const Tensor& index, const Tensor& updates, bool overwrite) {
  return paddle::experimental::scatter(x, index, updates, overwrite);
}

Tensor PhiTensorOperants::scatter_nd_add(const Tensor& x, const Tensor& index, const Tensor& updates) {
  return paddle::experimental::scatter_nd_add(x, index, updates);
}

Tensor PhiTensorOperants::add(const Tensor& x, const Tensor& y) {
  return paddle::experimental::add(x, y);
}

Tensor PhiTensorOperants::assign(const Tensor& x) {
  return paddle::experimental::assign(x);
}

Tensor PhiTensorOperants::divide(const Tensor& x, const Tensor& y) {
  return paddle::experimental::divide(x, y);
}

Tensor PhiTensorOperants::elementwise_pow(const Tensor& x, const Tensor& y) {
  return paddle::experimental::elementwise_pow(x, y);
}

Tensor PhiTensorOperants::equal(const Tensor& x, const Tensor& y) {
  return paddle::experimental::equal(x, y);
}

Tensor PhiTensorOperants::greater_equal(const Tensor& x, const Tensor& y) {
  return paddle::experimental::greater_equal(x, y);
}

Tensor PhiTensorOperants::greater_than(const Tensor& x, const Tensor& y) {
  return paddle::experimental::greater_than(x, y);
}

Tensor PhiTensorOperants::less_equal(const Tensor& x, const Tensor& y) {
  return paddle::experimental::less_equal(x, y);
}

Tensor PhiTensorOperants::less_than(const Tensor& x, const Tensor& y) {
  return paddle::experimental::less_than(x, y);
}

Tensor PhiTensorOperants::matmul(const Tensor& x, const Tensor& y, bool transpose_x, bool transpose_y) {
  return paddle::experimental::matmul(x, y, transpose_x, transpose_y);
}

Tensor PhiTensorOperants::max(const Tensor& x, const IntArray& axis, bool keepdim) {
  return paddle::experimental::max(x, axis, keepdim);
}

Tensor PhiTensorOperants::maximum(const Tensor& x, const Tensor& y) {
  return paddle::experimental::maximum(x, y);
}

Tensor PhiTensorOperants::minimum(const Tensor& x, const Tensor& y) {
  return paddle::experimental::minimum(x, y);
}

Tensor PhiTensorOperants::multiply(const Tensor& x, const Tensor& y) {
  return paddle::experimental::multiply(x, y);
}

Tensor PhiTensorOperants::not_equal(const Tensor& x, const Tensor& y) {
  return paddle::experimental::not_equal(x, y);
}

Tensor PhiTensorOperants::subtract(const Tensor& x, const Tensor& y) {
  return paddle::experimental::subtract(x, y);
}

Tensor PhiTensorOperants::sum(const Tensor& x, const IntArray& axis, DataType dtype, bool keepdim) {
  return paddle::experimental::sum(x, axis, dtype, keepdim);
}

Tensor PhiTensorOperants::tile(const Tensor& x, const IntArray& repeat_times) {
  return paddle::experimental::tile(x, repeat_times);
}

}  // namespace operants
}  // namespace paddle


// this file is generated by paddle/phi/api/yaml/generator/generate_op.py, do not edit.
#include <string>
#include "paddle/fluid/framework/infershape_utils.h"
#include "paddle/fluid/framework/op_registry.h"
#include "paddle/phi/core/infermeta_utils.h"
#include "paddle/phi/infermeta/backward.h"
#include "paddle/phi/infermeta/binary.h"
#include "paddle/phi/infermeta/multiary.h"
#include "paddle/phi/infermeta/sparse/backward.h"
#include "paddle/phi/infermeta/sparse/binary.h"
#include "paddle/phi/infermeta/sparse/multiary.h"
#include "paddle/phi/infermeta/sparse/unary.h"
#include "paddle/phi/infermeta/ternary.h"
#include "paddle/phi/infermeta/unary.h"

namespace paddle {
namespace operators {

using paddle::framework::GradVarName;


class SparseAbsOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_abs op.");
    AddOutput("out", "(Tensor), output 0 of sparse_abs op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_abs op.
)DOC");
  }
};


class SparseAbsOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_abs, SparseAbsInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseAcosOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_acos op.");
    AddOutput("out", "(Tensor), output 0 of sparse_acos op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_acos op.
)DOC");
  }
};


class SparseAcosOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_acos, SparseAcosInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseAcoshOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_acosh op.");
    AddOutput("out", "(Tensor), output 0 of sparse_acosh op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_acosh op.
)DOC");
  }
};


class SparseAcoshOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_acosh, SparseAcoshInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseAddOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_add op.");
    AddInput("y", "(Tensor), input 1 of sparse_add op.");
    AddOutput("out", "(Tensor), output 0 of sparse_add op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_add op.
)DOC");
  }
};


class SparseAddOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_add, SparseAddInferShapeFunctor,
                            PD_INFER_META(phi::ElementwiseInferMeta));



class SparseAsinOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_asin op.");
    AddOutput("out", "(Tensor), output 0 of sparse_asin op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_asin op.
)DOC");
  }
};


class SparseAsinOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_asin, SparseAsinInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseAsinhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_asinh op.");
    AddOutput("out", "(Tensor), output 0 of sparse_asinh op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_asinh op.
)DOC");
  }
};


class SparseAsinhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_asinh, SparseAsinhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseAtanOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_atan op.");
    AddOutput("out", "(Tensor), output 0 of sparse_atan op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_atan op.
)DOC");
  }
};


class SparseAtanOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_atan, SparseAtanInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseAtanhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_atanh op.");
    AddOutput("out", "(Tensor), output 0 of sparse_atanh op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_atanh op.
)DOC");
  }
};


class SparseAtanhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_atanh, SparseAtanhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseBatchNormOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_batch_norm op.");
    AddInput("mean", "(Tensor), input 1 of sparse_batch_norm op.");
    AddInput("variance", "(Tensor), input 2 of sparse_batch_norm op.");
    AddInput("scale", "(Tensor), input 3 of sparse_batch_norm op.");
    AddInput("bias", "(Tensor), input 4 of sparse_batch_norm op.");
    AddOutput("out", "(Tensor), output 0 of sparse_batch_norm op.");
    AddOutput("mean_out", "(Tensor), output 1 of sparse_batch_norm op.");
    AddOutput("variance_out", "(Tensor), output 2 of sparse_batch_norm op.");
    AddOutput("saved_mean", "(Tensor), output 3 of sparse_batch_norm op.");
    AddOutput("saved_variance", "(Tensor), output 4 of sparse_batch_norm op.");
    AddOutput("reserve_space", "(Tensor), output 5 of sparse_batch_norm op.");
    AddAttr<bool>("is_test", "(bool), attribute 0 for sparse_batch_norm op.")
    ;
    AddAttr<float>("momentum", "(float), attribute 1 for sparse_batch_norm op.")
    ;
    AddAttr<float>("epsilon", "(float), attribute 2 for sparse_batch_norm op.")
    ;
    AddAttr<std::string>("data_layout", "(std::string), attribute 3 for sparse_batch_norm op.")
    ;
    AddAttr<bool>("use_global_stats", "(bool), attribute 4 for sparse_batch_norm op.")
    ;
    AddAttr<bool>("trainable_statistics", "(bool), attribute 5 for sparse_batch_norm op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_batch_norm op.
)DOC");
  }
};


class SparseBatchNormOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "x");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_batch_norm, SparseBatchNormInferShapeFunctor,
                            PD_INFER_META(phi::BatchNormInferMeta));



class SparseCastOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_cast op.");
    AddOutput("out", "(Tensor), output 0 of sparse_cast op.");
    AddAttr<int>("index_dtype", "(int), attribute 0 for sparse_cast op.")
        .SetDefault(-1);
    AddAttr<int>("value_dtype", "(int), attribute 1 for sparse_cast op.")
        .SetDefault(-1);
    AddComment(R"DOC(
TODO: Documentation of sparse_cast op.
)DOC");
  }
};


class SparseCastOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "x");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_cast, SparseCastInferShapeFunctor,
                            PD_INFER_META(phi::sparse::CastInferMeta));



class SparseConv3dOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_conv3d op.");
    AddInput("kernel", "(Tensor), input 1 of sparse_conv3d op.");
    AddOutput("out", "(Tensor), output 0 of sparse_conv3d op.");
    AddOutput("rulebook", "(Tensor), output 1 of sparse_conv3d op.")
        .AsIntermediate();
    AddOutput("counter", "(Tensor), output 2 of sparse_conv3d op.")
        .AsIntermediate();
    AddAttr<std::vector<int>>("paddings", "(std::vector<int>), attribute 0 for sparse_conv3d op.")
    ;
    AddAttr<std::vector<int>>("dilations", "(std::vector<int>), attribute 1 for sparse_conv3d op.")
    ;
    AddAttr<std::vector<int>>("strides", "(std::vector<int>), attribute 2 for sparse_conv3d op.")
    ;
    AddAttr<int>("groups", "(int), attribute 3 for sparse_conv3d op.")
    ;
    AddAttr<bool>("subm", "(bool), attribute 4 for sparse_conv3d op.")
    ;
    AddAttr<std::string>("key", "(std::string), attribute 5 for sparse_conv3d op.")
        .SetDefault("");
    AddComment(R"DOC(
TODO: Documentation of sparse_conv3d op.
)DOC");
  }
};


class SparseConv3dOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_conv3d, SparseConv3dInferShapeFunctor,
                            PD_INFER_META(phi::sparse::Conv3dInferMeta));



class SparseDivideOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_divide op.");
    AddInput("y", "(Tensor), input 1 of sparse_divide op.");
    AddOutput("out", "(Tensor), output 0 of sparse_divide op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_divide op.
)DOC");
  }
};


class SparseDivideOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_divide, SparseDivideInferShapeFunctor,
                            PD_INFER_META(phi::ElementwiseInferMeta));



class SparseDivideScalarOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_divide_scalar op.");
    AddOutput("out", "(Tensor), output 0 of sparse_divide_scalar op.");
    AddAttr<float>("scalar", "(float), attribute 0 for sparse_divide_scalar op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_divide_scalar op.
)DOC");
  }
};


class SparseDivideScalarOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_divide_scalar, SparseDivideScalarInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseExpm1OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_expm1 op.");
    AddOutput("out", "(Tensor), output 0 of sparse_expm1 op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_expm1 op.
)DOC");
  }
};


class SparseExpm1Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_expm1, SparseExpm1InferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseIsnanOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_isnan op.");
    AddOutput("out", "(Tensor), output 0 of sparse_isnan op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_isnan op.
)DOC");
  }
};


class SparseIsnanOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_isnan, SparseIsnanInferShapeFunctor,
                            PD_INFER_META(phi::IsfiniteInferMeta));



class SparseLeakyReluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_leaky_relu op.");
    AddOutput("out", "(Tensor), output 0 of sparse_leaky_relu op.");
    AddAttr<float>("alpha", "(float), attribute 0 for sparse_leaky_relu op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_leaky_relu op.
)DOC");
  }
};


class SparseLeakyReluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_leaky_relu, SparseLeakyReluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseLog1pOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_log1p op.");
    AddOutput("out", "(Tensor), output 0 of sparse_log1p op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_log1p op.
)DOC");
  }
};


class SparseLog1pOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_log1p, SparseLog1pInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseMultiplyOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_multiply op.");
    AddInput("y", "(Tensor), input 1 of sparse_multiply op.");
    AddOutput("out", "(Tensor), output 0 of sparse_multiply op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_multiply op.
)DOC");
  }
};


class SparseMultiplyOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_multiply, SparseMultiplyInferShapeFunctor,
                            PD_INFER_META(phi::ElementwiseInferMeta));



class SparsePowOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_pow op.");
    AddOutput("out", "(Tensor), output 0 of sparse_pow op.");
    AddAttr<float>("factor", "(float), attribute 0 for sparse_pow op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_pow op.
)DOC");
  }
};


class SparsePowOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_pow, SparsePowInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseReluOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_relu op.");
    AddOutput("out", "(Tensor), output 0 of sparse_relu op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_relu op.
)DOC");
  }
};


class SparseReluOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_relu, SparseReluInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseRelu6OpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_relu6 op.");
    AddOutput("out", "(Tensor), output 0 of sparse_relu6 op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_relu6 op.
)DOC");
  }
};


class SparseRelu6Op : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_relu6, SparseRelu6InferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseReshapeOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_reshape op.");
    AddOutput("out", "(Tensor), output 0 of sparse_reshape op.");
    AddInput("ShapeTensor", "attribute 0 for sparse_reshape op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("ShapeTensorList", "attribute 0 for sparse_reshape op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
      AddAttr<std::vector<int64_t>>("shape", "(std::vector<int64_t>), attribute 0 for sparse_reshape op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_reshape op.
)DOC");
  }
};


class SparseReshapeOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_reshape, SparseReshapeInferShapeFunctor,
                            PD_INFER_META(phi::ReshapeInferMeta));



class SparseScaleOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_scale op.");
    AddOutput("out", "(Tensor), output 0 of sparse_scale op.");
    AddAttr<float>("scale", "(float), attribute 0 for sparse_scale op.")
    ;
    AddAttr<float>("bias", "(float), attribute 1 for sparse_scale op.")
    ;
    AddAttr<bool>("bias_after_scale", "(bool), attribute 2 for sparse_scale op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_scale op.
)DOC");
  }
};


class SparseScaleOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_scale, SparseScaleInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseSinOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_sin op.");
    AddOutput("out", "(Tensor), output 0 of sparse_sin op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_sin op.
)DOC");
  }
};


class SparseSinOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sin, SparseSinInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseSinhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_sinh op.");
    AddOutput("out", "(Tensor), output 0 of sparse_sinh op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_sinh op.
)DOC");
  }
};


class SparseSinhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sinh, SparseSinhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseSoftmaxOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_softmax op.");
    AddOutput("out", "(Tensor), output 0 of sparse_softmax op.");
    AddAttr<int>("axis", "(int), attribute 0 for sparse_softmax op.")
        .SetDefault(-1);
    AddComment(R"DOC(
TODO: Documentation of sparse_softmax op.
)DOC");
  }
};


class SparseSoftmaxOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_softmax, SparseSoftmaxInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseSparseCooTensorOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("values", "(Tensor), input 0 of sparse_sparse_coo_tensor op.");
    AddInput("indices", "(Tensor), input 1 of sparse_sparse_coo_tensor op.");
    AddOutput("out", "(Tensor), output 0 of sparse_sparse_coo_tensor op.");
    AddAttr<std::vector<int64_t>>("shape", "(std::vector<int64_t>), attribute 0 for sparse_sparse_coo_tensor op.")
        .SetDefault({});
    AddComment(R"DOC(
TODO: Documentation of sparse_sparse_coo_tensor op.
)DOC");
  }
};


class SparseSparseCooTensorOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "values");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sparse_coo_tensor, SparseSparseCooTensorInferShapeFunctor,
                            PD_INFER_META(phi::sparse::SparseCooTensorInferMeta));



class SparseSqrtOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_sqrt op.");
    AddOutput("out", "(Tensor), output 0 of sparse_sqrt op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_sqrt op.
)DOC");
  }
};


class SparseSqrtOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sqrt, SparseSqrtInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseSquareOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_square op.");
    AddOutput("out", "(Tensor), output 0 of sparse_square op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_square op.
)DOC");
  }
};


class SparseSquareOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_square, SparseSquareInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseSubtractOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_subtract op.");
    AddInput("y", "(Tensor), input 1 of sparse_subtract op.");
    AddOutput("out", "(Tensor), output 0 of sparse_subtract op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_subtract op.
)DOC");
  }
};


class SparseSubtractOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_subtract, SparseSubtractInferShapeFunctor,
                            PD_INFER_META(phi::ElementwiseInferMeta));



class SparseSumOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_sum op.");
    AddOutput("out", "(Tensor), output 0 of sparse_sum op.");
    AddInput("AxisTensor", "attribute 0 for sparse_sum op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("AxisTensorList", "attribute 0 for sparse_sum op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
      AddAttr<std::vector<int64_t>>("axis", "(std::vector<int64_t>), attribute 0 for sparse_sum op.")
        .SetDefault({});
    AddAttr<int>("dtype", "(int), attribute 1 for sparse_sum op.")
        .SetDefault(-1);
    AddAttr<bool>("keepdim", "(bool), attribute 2 for sparse_sum op.")
        .SetDefault(false);
    AddComment(R"DOC(
TODO: Documentation of sparse_sum op.
)DOC");
  }
};


class SparseSumOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "x");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sum, SparseSumInferShapeFunctor,
                            PD_INFER_META(phi::SumInferMeta));



class SparseSyncBatchNormOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_sync_batch_norm op.");
    AddInput("mean", "(Tensor), input 1 of sparse_sync_batch_norm op.");
    AddInput("variance", "(Tensor), input 2 of sparse_sync_batch_norm op.");
    AddInput("scale", "(Tensor), input 3 of sparse_sync_batch_norm op.");
    AddInput("bias", "(Tensor), input 4 of sparse_sync_batch_norm op.");
    AddOutput("out", "(Tensor), output 0 of sparse_sync_batch_norm op.");
    AddOutput("mean_out", "(Tensor), output 1 of sparse_sync_batch_norm op.");
    AddOutput("variance_out", "(Tensor), output 2 of sparse_sync_batch_norm op.");
    AddOutput("saved_mean", "(Tensor), output 3 of sparse_sync_batch_norm op.");
    AddOutput("saved_variance", "(Tensor), output 4 of sparse_sync_batch_norm op.");
    AddOutput("reserve_space", "(Tensor), output 5 of sparse_sync_batch_norm op.");
    AddAttr<bool>("is_test", "(bool), attribute 0 for sparse_sync_batch_norm op.")
    ;
    AddAttr<float>("momentum", "(float), attribute 1 for sparse_sync_batch_norm op.")
    ;
    AddAttr<float>("epsilon", "(float), attribute 2 for sparse_sync_batch_norm op.")
    ;
    AddAttr<std::string>("data_layout", "(std::string), attribute 3 for sparse_sync_batch_norm op.")
    ;
    AddAttr<bool>("use_global_stats", "(bool), attribute 4 for sparse_sync_batch_norm op.")
    ;
    AddAttr<bool>("trainable_statistics", "(bool), attribute 5 for sparse_sync_batch_norm op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_sync_batch_norm op.
)DOC");
  }
};


class SparseSyncBatchNormOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "x");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sync_batch_norm, SparseSyncBatchNormInferShapeFunctor,
                            PD_INFER_META(phi::BatchNormInferMeta));



class SparseTanOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_tan op.");
    AddOutput("out", "(Tensor), output 0 of sparse_tan op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_tan op.
)DOC");
  }
};


class SparseTanOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_tan, SparseTanInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseTanhOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_tanh op.");
    AddOutput("out", "(Tensor), output 0 of sparse_tanh op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_tanh op.
)DOC");
  }
};


class SparseTanhOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_tanh, SparseTanhInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseToDenseOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_to_dense op.");
    AddOutput("out", "(Tensor), output 0 of sparse_to_dense op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_to_dense op.
)DOC");
  }
};


class SparseToDenseOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_to_dense, SparseToDenseInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseToSparseCooOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_to_sparse_coo op.");
    AddOutput("out", "(Tensor), output 0 of sparse_to_sparse_coo op.");
    AddAttr<int64_t>("sparse_dim", "(int64_t), attribute 0 for sparse_to_sparse_coo op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_to_sparse_coo op.
)DOC");
  }
};


class SparseToSparseCooOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_to_sparse_coo, SparseToSparseCooInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseToSparseCsrOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_to_sparse_csr op.");
    AddOutput("out", "(Tensor), output 0 of sparse_to_sparse_csr op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_to_sparse_csr op.
)DOC");
  }
};


class SparseToSparseCsrOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_to_sparse_csr, SparseToSparseCsrInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseTransposeOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_transpose op.");
    AddOutput("out", "(Tensor), output 0 of sparse_transpose op.");
    AddAttr<std::vector<int>>("perm", "(std::vector<int>), attribute 0 for sparse_transpose op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_transpose op.
)DOC");
  }
};


class SparseTransposeOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_transpose, SparseTransposeInferShapeFunctor,
                            PD_INFER_META(phi::TransposeInferMeta));



class SparseValuesOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_values op.");
    AddOutput("out", "(Tensor), output 0 of sparse_values op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_values op.
)DOC");
  }
};


class SparseValuesOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_values, SparseValuesInferShapeFunctor,
                            PD_INFER_META(phi::sparse::ValuesInferMeta));



class SparseAddmmOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("input", "(Tensor), input 0 of sparse_addmm op.");
    AddInput("x", "(Tensor), input 1 of sparse_addmm op.");
    AddInput("y", "(Tensor), input 2 of sparse_addmm op.");
    AddOutput("out", "(Tensor), output 0 of sparse_addmm op.");
    AddAttr<float>("beta", "(float), attribute 0 for sparse_addmm op.")
        .SetDefault(1.0);
    AddAttr<float>("alpha", "(float), attribute 1 for sparse_addmm op.")
        .SetDefault(1.0);
    AddComment(R"DOC(
TODO: Documentation of sparse_addmm op.
)DOC");
  }
};


class SparseAddmmOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_addmm, SparseAddmmInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseCoalesceOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_coalesce op.");
    AddOutput("out", "(Tensor), output 0 of sparse_coalesce op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_coalesce op.
)DOC");
  }
};


class SparseCoalesceOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_coalesce, SparseCoalesceInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



class SparseFullLikeOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_full_like op.");
    AddOutput("out", "(Tensor), output 0 of sparse_full_like op.");
    AddInput("ValueTensor", "attribute 0 for sparse_full_like op from 0D Tensor.")
        .AsDispensable();
    AddAttr<float>("value", "(float), attribute 0 for sparse_full_like op.")
    ;
    AddAttr<int>("dtype", "(int), attribute 1 for sparse_full_like op.")
        .SetDefault(-1);
    AddComment(R"DOC(
TODO: Documentation of sparse_full_like op.
)DOC");
  }
};


class SparseFullLikeOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::proto::VarType::Type(ctx.Attr<int>("dtype"));
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_full_like, SparseFullLikeInferShapeFunctor,
                            PD_INFER_META(phi::CreateLikeInferMeta));



class SparseFusedAttentionOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("query", "(Tensor), input 0 of sparse_fused_attention op.");
    AddInput("key", "(Tensor), input 1 of sparse_fused_attention op.");
    AddInput("value", "(Tensor), input 2 of sparse_fused_attention op.");
    AddInput("sparse_mask", "(Tensor), input 3 of sparse_fused_attention op.");
    AddInput("key_padding_mask", "(Tensor), input 4 of sparse_fused_attention op.")
        .AsDispensable();
    AddInput("attn_mask", "(Tensor), input 5 of sparse_fused_attention op.")
        .AsDispensable();
    AddOutput("out", "(Tensor), output 0 of sparse_fused_attention op.");
    AddOutput("softmax", "(Tensor), output 1 of sparse_fused_attention op.")
        .AsIntermediate();
    AddComment(R"DOC(
TODO: Documentation of sparse_fused_attention op.
)DOC");
  }
};


class SparseFusedAttentionOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "query");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_fused_attention, SparseFusedAttentionInferShapeFunctor,
                            PD_INFER_META(phi::sparse::FusedAttentionInferMeta));



class SparseMaskedMatmulOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_masked_matmul op.");
    AddInput("y", "(Tensor), input 1 of sparse_masked_matmul op.");
    AddInput("mask", "(Tensor), input 2 of sparse_masked_matmul op.");
    AddOutput("out", "(Tensor), output 0 of sparse_masked_matmul op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_masked_matmul op.
)DOC");
  }
};


class SparseMaskedMatmulOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_masked_matmul, SparseMaskedMatmulInferShapeFunctor,
                            PD_INFER_META(phi::MatmulInferMeta));



class SparseMatmulOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_matmul op.");
    AddInput("y", "(Tensor), input 1 of sparse_matmul op.");
    AddOutput("out", "(Tensor), output 0 of sparse_matmul op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_matmul op.
)DOC");
  }
};


class SparseMatmulOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_matmul, SparseMatmulInferShapeFunctor,
                            PD_INFER_META(phi::MatmulInferMeta));



class SparseMaxpoolOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_maxpool op.");
    AddOutput("out", "(Tensor), output 0 of sparse_maxpool op.");
    AddOutput("rulebook", "(Tensor), output 1 of sparse_maxpool op.")
        .AsIntermediate();
    AddOutput("counter", "(Tensor), output 2 of sparse_maxpool op.")
        .AsIntermediate();
    AddAttr<std::vector<int>>("kernel_sizes", "(std::vector<int>), attribute 0 for sparse_maxpool op.")
    ;
    AddAttr<std::vector<int>>("paddings", "(std::vector<int>), attribute 1 for sparse_maxpool op.")
    ;
    AddAttr<std::vector<int>>("dilations", "(std::vector<int>), attribute 2 for sparse_maxpool op.")
    ;
    AddAttr<std::vector<int>>("strides", "(std::vector<int>), attribute 3 for sparse_maxpool op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_maxpool op.
)DOC");
  }
};


class SparseMaxpoolOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_maxpool, SparseMaxpoolInferShapeFunctor,
                            PD_INFER_META(phi::sparse::Pool3dInferMeta));



class SparseMvOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_mv op.");
    AddInput("vec", "(Tensor), input 1 of sparse_mv op.");
    AddOutput("out", "(Tensor), output 0 of sparse_mv op.");
    AddComment(R"DOC(
TODO: Documentation of sparse_mv op.
)DOC");
  }
};


class SparseMvOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_mv, SparseMvInferShapeFunctor,
                            PD_INFER_META(phi::MvInferMeta));



class SparseSliceOpMaker : public framework::OpProtoAndCheckerMaker {
 public:
  void Make() override {
    AddInput("x", "(Tensor), input 0 of sparse_slice op.");
    AddOutput("out", "(Tensor), output 0 of sparse_slice op.");
    AddInput("AxesTensor", "attribute 0 for sparse_slice op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("AxesTensorList", "attribute 0 for sparse_slice op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
      AddAttr<std::vector<int64_t>>("axes", "(std::vector<int64_t>), attribute 0 for sparse_slice op.")
    ;
    AddInput("StartsTensor", "attribute 1 for sparse_slice op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("StartsTensorList", "attribute 1 for sparse_slice op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
      AddAttr<std::vector<int64_t>>("starts", "(std::vector<int64_t>), attribute 1 for sparse_slice op.")
    ;
    AddInput("EndsTensor", "attribute 2 for sparse_slice op from 1D integer Tensor.")
        .AsDispensable();
    AddInput("EndsTensorList", "attribute 2 for sparse_slice op from list fo 0D integer Tensors.")
        .AsDuplicable()
        .AsDispensable();
      AddAttr<std::vector<int64_t>>("ends", "(std::vector<int64_t>), attribute 2 for sparse_slice op.")
    ;
    AddComment(R"DOC(
TODO: Documentation of sparse_slice op.
)DOC");
  }
};


class SparseSliceOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_slice, SparseSliceInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));




template <typename T>
class SparseAbsGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_abs_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAbsGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_abs_grad, SparseAbsGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseAcosGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_acos_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAcosGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_acos_grad, SparseAcosGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseAcoshGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_acosh_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAcoshGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_acosh_grad, SparseAcoshGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseAddGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_add_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAddGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_add_grad, SparseAddGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparseAddmmGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_addmm_grad");

    grad_op->SetInput("input", this->Input("input"));
    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("input"), this->InputGrad("input", false));
    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAddmmGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_addmm_grad, SparseAddmmGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));



template <typename T>
class SparseAsinGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_asin_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAsinGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_asin_grad, SparseAsinGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseAsinhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_asinh_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAsinhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_asinh_grad, SparseAsinhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseAtanGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_atan_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAtanGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_atan_grad, SparseAtanGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseAtanhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_atanh_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseAtanhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_atanh_grad, SparseAtanhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseBatchNormGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_batch_norm_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("scale", this->Input("scale"));
    grad_op->SetInput("bias", this->Input("bias"));
    if (this->HasOutput("mean_out")) {
      grad_op->SetInput("mean_out", this->Output("mean_out"));
    }
    if (this->HasOutput("variance_out")) {
      grad_op->SetInput("variance_out", this->Output("variance_out"));
    }
    grad_op->SetInput("saved_mean", this->Output("saved_mean"));
    grad_op->SetInput("saved_variance", this->Output("saved_variance"));
    if (this->HasOutput("reserve_space")) {
      grad_op->SetInput("reserve_space", this->Output("reserve_space"));
    }
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("scale"), this->InputGrad("scale", false));
    grad_op->SetOutput(GradVarName("bias"), this->InputGrad("bias", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseBatchNormGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, GradVarName("out"));
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_batch_norm_grad, SparseBatchNormGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));



template <typename T>
class SparseCastGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_cast_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseCastGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, GradVarName("out"));
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_cast_grad, SparseCastGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseConv3dGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_conv3d_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("kernel", this->Input("kernel"));
    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput("rulebook", this->Output("rulebook"));
    grad_op->SetInput("counter", this->Output("counter"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("kernel"), this->InputGrad("kernel", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseConv3dGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_conv3d_grad, SparseConv3dGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparseDivideGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_divide_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseDivideGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_divide_grad, SparseDivideGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));


template <typename T>
class SparseDivideScalarGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_divide_scalar");

    grad_op->SetInput("x", this->OutputGrad("out"));

    grad_op->SetOutput("out", this->InputGrad("x"));


    grad_op->SetAttr("scalar", this->GetAttr("scalar"));
  }
};


template <typename T>
class SparseExpm1GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_expm1_grad");

    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseExpm1GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_expm1_grad, SparseExpm1GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseLeakyReluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_leaky_relu_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseLeakyReluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_leaky_relu_grad, SparseLeakyReluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseLog1pGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_log1p_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseLog1pGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_log1p_grad, SparseLog1pGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseMaskedMatmulGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_masked_matmul_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseMaskedMatmulGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_masked_matmul_grad, SparseMaskedMatmulGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparseMatmulGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_matmul_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseMatmulGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_matmul_grad, SparseMatmulGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparseMaxpoolGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_maxpool_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("rulebook", this->Output("rulebook"));
    grad_op->SetInput("counter", this->Output("counter"));
    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseMaxpoolGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_maxpool_grad, SparseMaxpoolGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseMultiplyGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_multiply_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseMultiplyGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_multiply_grad, SparseMultiplyGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparseMvGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_mv_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("vec", this->Input("vec"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("vec"), this->InputGrad("vec", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseMvGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_mv_grad, SparseMvGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparsePowGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_pow_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparsePowGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_pow_grad, SparsePowGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseRelu6GradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_relu6_grad");

    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseRelu6GradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_relu6_grad, SparseRelu6GradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseReluGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_relu_grad");

    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseReluGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_relu_grad, SparseReluGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseReshapeGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_reshape_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseReshapeGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_reshape_grad, SparseReshapeGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));


template <typename T>
class SparseScaleGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_scale");

    grad_op->SetInput("x", this->OutputGrad("out"));

    grad_op->SetOutput("out", this->InputGrad("x"));


    grad_op->SetAttr("scale", this->GetAttr("scale"));
    grad_op->SetAttr("bias", 0.0);
    grad_op->SetAttr("bias_after_scale", true);
  }
};


template <typename T>
class SparseSinGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_sin_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSinGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sin_grad, SparseSinGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSinhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_sinh_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSinhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sinh_grad, SparseSinhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSoftmaxGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_softmax_grad");

    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSoftmaxGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_softmax_grad, SparseSoftmaxGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSparseCooTensorGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_sparse_coo_tensor_grad");

    grad_op->SetInput("indices", this->Input("indices"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("values"), this->InputGrad("values", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSparseCooTensorGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sparse_coo_tensor_grad, SparseSparseCooTensorGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSqrtGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_sqrt_grad");

    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSqrtGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sqrt_grad, SparseSqrtGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSquareGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_square_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSquareGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_square_grad, SparseSquareGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSubtractGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_subtract_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("y", this->Input("y"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("y"), this->InputGrad("y", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSubtractGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_subtract_grad, SparseSubtractGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralBinaryGradInferMeta));



template <typename T>
class SparseSumGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_sum_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
    if (this->HasInput("AxisTensor")) {
      grad_op->SetInput("AxisTensor", this->Input("AxisTensor"));
    }
    if (this->HasInput("AxisTensorList")) {
      grad_op->SetInput("AxisTensorList", this->Input("AxisTensorList"));
    }
  }
};


class SparseSumGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sum_grad, SparseSumGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseSyncBatchNormGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_sync_batch_norm_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput("scale", this->Input("scale"));
    grad_op->SetInput("bias", this->Input("bias"));
    grad_op->SetInput("saved_mean", this->Output("saved_mean"));
    grad_op->SetInput("saved_variance", this->Output("saved_variance"));
    if (this->HasOutput("reserve_space")) {
      grad_op->SetInput("reserve_space", this->Output("reserve_space"));
    }
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));
    grad_op->SetOutput(GradVarName("scale"), this->InputGrad("scale", false));
    grad_op->SetOutput(GradVarName("bias"), this->InputGrad("bias", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseSyncBatchNormGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, GradVarName("out"));
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_sync_batch_norm_grad, SparseSyncBatchNormGradInferShapeFunctor,
                            PD_INFER_META(phi::GeneralTernaryGradInferMeta));



template <typename T>
class SparseTanGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_tan_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseTanGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_tan_grad, SparseTanGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseTanhGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_tanh_grad");

    grad_op->SetInput("out", this->Output("out"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseTanhGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_tanh_grad, SparseTanhGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseToDenseGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_to_dense_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseToDenseGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_to_dense_grad, SparseToDenseGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseToSparseCooGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_to_sparse_coo_grad");

    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseToSparseCooGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_to_sparse_coo_grad, SparseToSparseCooGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseTransposeGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_transpose_grad");

    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseTransposeGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_transpose_grad, SparseTransposeGradInferShapeFunctor,
                            PD_INFER_META(phi::TransposeGradInferMeta));



template <typename T>
class SparseValuesGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_values_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseValuesGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_values_grad, SparseValuesGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));



template <typename T>
class SparseFusedAttentionGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_fused_attention_grad");

    grad_op->SetInput("query", this->Input("query"));
    grad_op->SetInput("key", this->Input("key"));
    grad_op->SetInput("value", this->Input("value"));
    grad_op->SetInput("softmax", this->Output("softmax"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("query"), this->InputGrad("query", false));
    grad_op->SetOutput(GradVarName("key"), this->InputGrad("key", false));
    grad_op->SetOutput(GradVarName("value"), this->InputGrad("value", false));

    grad_op->SetAttrMap(this->Attrs());
  }
};


class SparseFusedAttentionGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
  phi::KernelKey GetExpectedKernelType(
      const framework::ExecutionContext& ctx) const override {
      phi::KernelKey kt;
    auto data_type = framework::OperatorWithKernel::IndicateVarDataType(ctx, "query");
    kt = phi::KernelKey(data_type, ctx.GetPlace());
    return kt;
  }

};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_fused_attention_grad, SparseFusedAttentionGradInferShapeFunctor,
                            PD_INFER_META(phi::sparse::FusedAttentionGradInferMeta));



template <typename T>
class SparseSliceGradOpMaker : public framework::SingleGradOpMaker<T> {
 public:
  using framework::SingleGradOpMaker<T>::SingleGradOpMaker;

 protected:
  void Apply(GradOpPtr<T> grad_op) const override {
    grad_op->SetType("sparse_slice_grad");

    grad_op->SetInput("x", this->Input("x"));
    grad_op->SetInput(GradVarName("out"), this->OutputGrad("out"));

    grad_op->SetOutput(GradVarName("x"), this->InputGrad("x", false));

    grad_op->SetAttrMap(this->Attrs());
    if (this->HasInput("AxesTensor")) {
      grad_op->SetInput("AxesTensor", this->Input("AxesTensor"));
    }
    if (this->HasInput("AxesTensorList")) {
      grad_op->SetInput("AxesTensorList", this->Input("AxesTensorList"));
    }
    if (this->HasInput("StartsTensor")) {
      grad_op->SetInput("StartsTensor", this->Input("StartsTensor"));
    }
    if (this->HasInput("StartsTensorList")) {
      grad_op->SetInput("StartsTensorList", this->Input("StartsTensorList"));
    }
    if (this->HasInput("EndsTensor")) {
      grad_op->SetInput("EndsTensor", this->Input("EndsTensor"));
    }
    if (this->HasInput("EndsTensorList")) {
      grad_op->SetInput("EndsTensorList", this->Input("EndsTensorList"));
    }
  }
};


class SparseSliceGradOp : public framework::OperatorWithKernel {
 public:
  using framework::OperatorWithKernel::OperatorWithKernel;
 protected:
};


DECLARE_INFER_SHAPE_FUNCTOR(sparse_slice_grad, SparseSliceGradInferShapeFunctor,
                            PD_INFER_META(phi::UnchangedInferMeta));


}  // namespace operators
}  // namespace paddle

namespace ops = paddle::operators;
REGISTER_OPERATOR(sparse_abs, ops::SparseAbsOp,
                  ops::SparseAbsOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAbsInferShapeFunctor);

REGISTER_OPERATOR(sparse_acos, ops::SparseAcosOp,
                  ops::SparseAcosOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAcosInferShapeFunctor);

REGISTER_OPERATOR(sparse_acosh, ops::SparseAcoshOp,
                  ops::SparseAcoshOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAcoshInferShapeFunctor);

REGISTER_OPERATOR(sparse_add, ops::SparseAddOp,
                  ops::SparseAddOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAddInferShapeFunctor);

REGISTER_OPERATOR(sparse_asin, ops::SparseAsinOp,
                  ops::SparseAsinOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAsinInferShapeFunctor);

REGISTER_OPERATOR(sparse_asinh, ops::SparseAsinhOp,
                  ops::SparseAsinhOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAsinhInferShapeFunctor);

REGISTER_OPERATOR(sparse_atan, ops::SparseAtanOp,
                  ops::SparseAtanOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAtanInferShapeFunctor);

REGISTER_OPERATOR(sparse_atanh, ops::SparseAtanhOp,
                  ops::SparseAtanhOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAtanhInferShapeFunctor);

REGISTER_OPERATOR(sparse_batch_norm, ops::SparseBatchNormOp,
                  ops::SparseBatchNormOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseBatchNormInferShapeFunctor);

REGISTER_OPERATOR(sparse_cast, ops::SparseCastOp,
                  ops::SparseCastOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseCastInferShapeFunctor);

REGISTER_OPERATOR(sparse_conv3d, ops::SparseConv3dOp,
                  ops::SparseConv3dOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseConv3dInferShapeFunctor);

REGISTER_OPERATOR(sparse_divide, ops::SparseDivideOp,
                  ops::SparseDivideOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseDivideInferShapeFunctor);

REGISTER_OPERATOR(sparse_divide_scalar, ops::SparseDivideScalarOp,
                  ops::SparseDivideScalarOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseDivideScalarInferShapeFunctor);

REGISTER_OPERATOR(sparse_expm1, ops::SparseExpm1Op,
                  ops::SparseExpm1OpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseExpm1InferShapeFunctor);

REGISTER_OPERATOR(sparse_isnan, ops::SparseIsnanOp,
                  ops::SparseIsnanOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseIsnanInferShapeFunctor);

REGISTER_OPERATOR(sparse_leaky_relu, ops::SparseLeakyReluOp,
                  ops::SparseLeakyReluOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseLeakyReluInferShapeFunctor);

REGISTER_OPERATOR(sparse_log1p, ops::SparseLog1pOp,
                  ops::SparseLog1pOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseLog1pInferShapeFunctor);

REGISTER_OPERATOR(sparse_multiply, ops::SparseMultiplyOp,
                  ops::SparseMultiplyOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseMultiplyInferShapeFunctor);

REGISTER_OPERATOR(sparse_pow, ops::SparsePowOp,
                  ops::SparsePowOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparsePowInferShapeFunctor);

REGISTER_OPERATOR(sparse_relu, ops::SparseReluOp,
                  ops::SparseReluOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseReluInferShapeFunctor);

REGISTER_OPERATOR(sparse_relu6, ops::SparseRelu6Op,
                  ops::SparseRelu6OpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseRelu6InferShapeFunctor);

REGISTER_OPERATOR(sparse_reshape, ops::SparseReshapeOp,
                  ops::SparseReshapeOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseReshapeInferShapeFunctor);

REGISTER_OPERATOR(sparse_scale, ops::SparseScaleOp,
                  ops::SparseScaleOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseScaleInferShapeFunctor);

REGISTER_OPERATOR(sparse_sin, ops::SparseSinOp,
                  ops::SparseSinOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSinInferShapeFunctor);

REGISTER_OPERATOR(sparse_sinh, ops::SparseSinhOp,
                  ops::SparseSinhOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSinhInferShapeFunctor);

REGISTER_OPERATOR(sparse_softmax, ops::SparseSoftmaxOp,
                  ops::SparseSoftmaxOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSoftmaxInferShapeFunctor);

REGISTER_OPERATOR(sparse_sparse_coo_tensor, ops::SparseSparseCooTensorOp,
                  ops::SparseSparseCooTensorOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSparseCooTensorInferShapeFunctor);

REGISTER_OPERATOR(sparse_sqrt, ops::SparseSqrtOp,
                  ops::SparseSqrtOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSqrtInferShapeFunctor);

REGISTER_OPERATOR(sparse_square, ops::SparseSquareOp,
                  ops::SparseSquareOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSquareInferShapeFunctor);

REGISTER_OPERATOR(sparse_subtract, ops::SparseSubtractOp,
                  ops::SparseSubtractOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSubtractInferShapeFunctor);

REGISTER_OPERATOR(sparse_sum, ops::SparseSumOp,
                  ops::SparseSumOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSumInferShapeFunctor);

REGISTER_OPERATOR(sparse_sync_batch_norm, ops::SparseSyncBatchNormOp,
                  ops::SparseSyncBatchNormOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSyncBatchNormInferShapeFunctor);

REGISTER_OPERATOR(sparse_tan, ops::SparseTanOp,
                  ops::SparseTanOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseTanInferShapeFunctor);

REGISTER_OPERATOR(sparse_tanh, ops::SparseTanhOp,
                  ops::SparseTanhOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseTanhInferShapeFunctor);

REGISTER_OPERATOR(sparse_to_dense, ops::SparseToDenseOp,
                  ops::SparseToDenseOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseToDenseInferShapeFunctor);

REGISTER_OPERATOR(sparse_to_sparse_coo, ops::SparseToSparseCooOp,
                  ops::SparseToSparseCooOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseToSparseCooInferShapeFunctor);

REGISTER_OPERATOR(sparse_to_sparse_csr, ops::SparseToSparseCsrOp,
                  ops::SparseToSparseCsrOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseToSparseCsrInferShapeFunctor);

REGISTER_OPERATOR(sparse_transpose, ops::SparseTransposeOp,
                  ops::SparseTransposeOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseTransposeInferShapeFunctor);

REGISTER_OPERATOR(sparse_values, ops::SparseValuesOp,
                  ops::SparseValuesOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseValuesInferShapeFunctor);

REGISTER_OPERATOR(sparse_addmm, ops::SparseAddmmOp,
                  ops::SparseAddmmOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseAddmmInferShapeFunctor);

REGISTER_OPERATOR(sparse_coalesce, ops::SparseCoalesceOp,
                  ops::SparseCoalesceOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseCoalesceInferShapeFunctor);

REGISTER_OPERATOR(sparse_full_like, ops::SparseFullLikeOp,
                  ops::SparseFullLikeOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseFullLikeInferShapeFunctor);

REGISTER_OPERATOR(sparse_fused_attention, ops::SparseFusedAttentionOp,
                  ops::SparseFusedAttentionOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseFusedAttentionInferShapeFunctor);

REGISTER_OPERATOR(sparse_masked_matmul, ops::SparseMaskedMatmulOp,
                  ops::SparseMaskedMatmulOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseMaskedMatmulInferShapeFunctor);

REGISTER_OPERATOR(sparse_matmul, ops::SparseMatmulOp,
                  ops::SparseMatmulOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseMatmulInferShapeFunctor);

REGISTER_OPERATOR(sparse_maxpool, ops::SparseMaxpoolOp,
                  ops::SparseMaxpoolOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseMaxpoolInferShapeFunctor);

REGISTER_OPERATOR(sparse_mv, ops::SparseMvOp,
                  ops::SparseMvOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseMvInferShapeFunctor);

REGISTER_OPERATOR(sparse_slice, ops::SparseSliceOp,
                  ops::SparseSliceOpMaker,
                  paddle::framework::EmptyGradOpMaker<paddle::framework::OpDesc>,
                  paddle::framework::EmptyGradOpMaker<paddle::imperative::OpBase>,
                  ops::SparseSliceInferShapeFunctor);

REGISTER_OPERATOR(sparse_abs_grad, ops::SparseAbsGradOp,
                  ops::SparseAbsGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_acos_grad, ops::SparseAcosGradOp,
                  ops::SparseAcosGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_acosh_grad, ops::SparseAcoshGradOp,
                  ops::SparseAcoshGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_add_grad, ops::SparseAddGradOp,
                  ops::SparseAddGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_addmm_grad, ops::SparseAddmmGradOp,
                  ops::SparseAddmmGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_asin_grad, ops::SparseAsinGradOp,
                  ops::SparseAsinGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_asinh_grad, ops::SparseAsinhGradOp,
                  ops::SparseAsinhGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_atan_grad, ops::SparseAtanGradOp,
                  ops::SparseAtanGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_atanh_grad, ops::SparseAtanhGradOp,
                  ops::SparseAtanhGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_batch_norm_grad, ops::SparseBatchNormGradOp,
                  ops::SparseBatchNormGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_cast_grad, ops::SparseCastGradOp,
                  ops::SparseCastGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_conv3d_grad, ops::SparseConv3dGradOp,
                  ops::SparseConv3dGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_divide_grad, ops::SparseDivideGradOp,
                  ops::SparseDivideGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_expm1_grad, ops::SparseExpm1GradOp,
                  ops::SparseExpm1GradInferShapeFunctor);

REGISTER_OPERATOR(sparse_leaky_relu_grad, ops::SparseLeakyReluGradOp,
                  ops::SparseLeakyReluGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_log1p_grad, ops::SparseLog1pGradOp,
                  ops::SparseLog1pGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_masked_matmul_grad, ops::SparseMaskedMatmulGradOp,
                  ops::SparseMaskedMatmulGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_matmul_grad, ops::SparseMatmulGradOp,
                  ops::SparseMatmulGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_maxpool_grad, ops::SparseMaxpoolGradOp,
                  ops::SparseMaxpoolGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_multiply_grad, ops::SparseMultiplyGradOp,
                  ops::SparseMultiplyGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_mv_grad, ops::SparseMvGradOp,
                  ops::SparseMvGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_pow_grad, ops::SparsePowGradOp,
                  ops::SparsePowGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_relu6_grad, ops::SparseRelu6GradOp,
                  ops::SparseRelu6GradInferShapeFunctor);

REGISTER_OPERATOR(sparse_relu_grad, ops::SparseReluGradOp,
                  ops::SparseReluGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_reshape_grad, ops::SparseReshapeGradOp,
                  ops::SparseReshapeGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_sin_grad, ops::SparseSinGradOp,
                  ops::SparseSinGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_sinh_grad, ops::SparseSinhGradOp,
                  ops::SparseSinhGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_softmax_grad, ops::SparseSoftmaxGradOp,
                  ops::SparseSoftmaxGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_sparse_coo_tensor_grad, ops::SparseSparseCooTensorGradOp,
                  ops::SparseSparseCooTensorGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_sqrt_grad, ops::SparseSqrtGradOp,
                  ops::SparseSqrtGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_square_grad, ops::SparseSquareGradOp,
                  ops::SparseSquareGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_subtract_grad, ops::SparseSubtractGradOp,
                  ops::SparseSubtractGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_sum_grad, ops::SparseSumGradOp,
                  ops::SparseSumGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_sync_batch_norm_grad, ops::SparseSyncBatchNormGradOp,
                  ops::SparseSyncBatchNormGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_tan_grad, ops::SparseTanGradOp,
                  ops::SparseTanGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_tanh_grad, ops::SparseTanhGradOp,
                  ops::SparseTanhGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_to_dense_grad, ops::SparseToDenseGradOp,
                  ops::SparseToDenseGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_to_sparse_coo_grad, ops::SparseToSparseCooGradOp,
                  ops::SparseToSparseCooGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_transpose_grad, ops::SparseTransposeGradOp,
                  ops::SparseTransposeGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_values_grad, ops::SparseValuesGradOp,
                  ops::SparseValuesGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_fused_attention_grad, ops::SparseFusedAttentionGradOp,
                  ops::SparseFusedAttentionGradInferShapeFunctor);

REGISTER_OPERATOR(sparse_slice_grad, ops::SparseSliceGradOp,
                  ops::SparseSliceGradInferShapeFunctor);


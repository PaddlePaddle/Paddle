- backward_op : abs_double_grad
  forward : abs_grad (Tensor x, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_x_grad)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : abs_double_grad

- backward_op : abs_grad
  forward : abs (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : abs_grad
  composite : abs_grad(x, out_grad, x_grad)
  backward : abs_double_grad

- backward_op : add_double_grad
  forward : add_grad (Tensor x, Tensor y, Tensor grad_out, int axis = -1) -> Tensor(grad_x), Tensor(grad_y)
  args : (Tensor y, Tensor grad_out, Tensor grad_x_grad, Tensor grad_y_grad, int axis = -1)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [grad_out]
  kernel :
    func : add_double_grad
  optional : grad_x_grad, grad_y_grad
  backward : add_triple_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : add_grad
  forward : add (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis = -1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : add_grad
  no_need_buffer : x, y
  composite : add_grad(x, y, out_grad, axis, x_grad, y_grad)
  backward : add_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : add_triple_grad
  forward : add_double_grad (Tensor y, Tensor grad_out, Tensor grad_grad_x, Tensor grad_grad_y, int axis = -1) -> Tensor(grad_grad_out)
  args : (Tensor grad_grad_x, Tensor grad_grad_y, Tensor grad_grad_out_grad, int axis = -1)
  output : Tensor(grad_grad_x_grad), Tensor(grad_grad_y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [grad_grad_x, grad_grad_y]
  kernel :
    func : add_triple_grad
  inplace : (grad_grad_out_grad -> grad_grad_x_grad)

- backward_op : affine_grid_grad
  forward : affine_grid (Tensor input, IntArray outputShape, bool align_corners=true) -> Tensor(output)
  args : (Tensor input, Tensor output_grad, IntArray outputShape, bool align_corners=true)
  output : Tensor(input_grad)
  infer_meta :
    func : AffineGridGradInferMeta
    param : [output_grad, outputShape, align_corners]
  kernel :
    func : affine_grid_grad
    param : [output_grad, outputShape, align_corners]
  no_need_buffer : input

- backward_op : amax_grad
  forward: amax (Tensor x,  int64_t[] axis={},  bool keepdim=false) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int64_t[] axis={},  bool keepdim=false, bool reduce_all=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : amax_grad

- backward_op : amin_grad
  forward: amin (Tensor x,  int64_t[] axis={},  bool keepdim=false) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int64_t[] axis={},  bool keepdim=false, bool reduce_all=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : amin_grad

- backward_op : assign_grad
  forward : assign (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  composite: assign_grad(out_grad, x_grad)
  invoke : assign(out_grad)

- backward_op : assign_out__grad
  forward : assign_out_ (Tensor x, Tensor output) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : assign
  inplace : (out_grad -> x_grad)

- backward_op : batch_norm_double_grad
  forward : batch_norm_grad (Tensor x, Tensor scale, Tensor bias, Tensor out_mean, Tensor out_variance, Tensor saved_mean, Tensor saved_variance, Tensor reserve_space, Tensor grad_out, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics) -> Tensor(grad_x), Tensor(grad_scale), Tensor(grad_bias)
  args : (Tensor x, Tensor scale, Tensor out_mean, Tensor out_variance, Tensor saved_mean, Tensor saved_variance, Tensor grad_out,  Tensor grad_x_grad, Tensor grad_scale_grad, Tensor grad_bias_grad, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics)
  output : Tensor(x_grad), Tensor(scale_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, scale, x]
  kernel :
    func : batch_norm_grad_grad
    data_type : x
  optional : out_mean, out_variance, grad_x_grad, grad_scale_grad, grad_bias_grad
  inplace : (grad_out -> grad_out_grad)

- backward_op : batch_norm_grad
  forward : batch_norm (Tensor x, Tensor mean, Tensor variance, Tensor scale, Tensor bias, bool is_test, float momentum, float epsilon, str data_layout, bool use_global_stats, bool trainable_statistics) -> Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean), Tensor(saved_variance), Tensor(reserve_space)
  args : (Tensor x, Tensor scale, Tensor bias, Tensor mean_out, Tensor variance_out, Tensor saved_mean, Tensor saved_variance, Tensor reserve_space, Tensor out_grad, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics)
  output : Tensor(x_grad), Tensor(scale_grad), Tensor(bias_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, scale, bias]
  kernel :
    func : batch_norm_grad
    data_type : out_grad
  optional : mean_out, variance_out, reserve_space
  composite: batch_norm_grad(x, scale, bias, mean_out, variance_out, saved_mean, saved_variance, reserve_space, out_grad, momentum, epsilon, data_layout, is_test, use_global_stats, trainable_statistics)
  backward : batch_norm_double_grad

- backward_op : bce_loss_grad
  forward : bce_loss (Tensor input, Tensor label) -> Tensor(out)
  args : (Tensor input, Tensor label, Tensor out_grad)
  output : Tensor(input_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [input]
  kernel :
    func : bce_loss_grad
  inplace : (out_grad -> input_grad)

- backward_op : bilinear_tensor_product_grad
  forward : bilinear_tensor_product (Tensor x, Tensor y, Tensor weight, Tensor bias) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor weight, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad), Tensor(weight_grad), Tensor(bias_grad)
  infer_meta :
    func : BilinearTensorProductGradInferMeta
  kernel :
    func : bilinear_tensor_product_grad

- backward_op : cast_grad
  forward : cast (Tensor x, DataType dtype) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  invoke : cast (out_grad, x.dtype())
  composite: cast_grad(x, out_grad, x_grad)
  no_need_buffer : x

- backward_op : channel_shuffle_grad
  forward : channel_shuffle (Tensor x, int groups, str data_format="NCHW") -> Tensor(out)
  args : (Tensor out_grad, int groups, str data_format="NCHW")
  output : Tensor(x_grad)
  infer_meta :
    func : ChannelShuffleGradInferMeta
  kernel :
    func : channel_shuffle_grad

- backward_op : concat_double_grad
  forward : concat_grad (Tensor[] x, Tensor grad_out, Scalar axis) -> Tensor[](grad_x)
  args : (Tensor[] grad_x_grad, Scalar axis = 0)
  output : Tensor(grad_out_grad)
  invoke : concat(grad_x_grad, axis)

- backward_op : concat_grad
  forward : concat (Tensor[] x, Scalar axis) -> Tensor(out)
  args : (Tensor[] x, Tensor out_grad, Scalar axis = 0)
  output : Tensor[](x_grad){x.size()}
  infer_meta :
    func : UnchangedMultiInferMeta
    param : [x]
  kernel :
    func : concat_grad
  composite : concat_grad(x, out_grad, axis, x_grad)
  no_need_buffer : x
  backward : concat_double_grad

- backward_op : conv2d_grad
  forward : conv2d (Tensor input, Tensor filter, int[] strides, int[] paddings, str padding_algorithm, int[] dilations, int groups, str data_format) -> Tensor(out)
  args : (Tensor input, Tensor filter, Tensor out_grad,  int[] strides, int[] paddings, str padding_algorithm, int[] dilations, int groups, str data_format)
  output : Tensor(input_grad), Tensor(filter_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [input, filter]
  kernel :
    func : conv2d_grad
  backward : conv2d_grad_grad

- backward_op : conv2d_grad_grad
  forward : conv2d_grad (Tensor input, Tensor filter, Tensor grad_out,  int[] strides, int[] paddings, str padding_algorithm, int[] dilations, int groups, str data_format) -> Tensor(grad_input), Tensor(grad_filter)
  args : (Tensor input, Tensor filter, Tensor grad_out, Tensor grad_input_grad, Tensor grad_filter_grad, int[] strides, int[] paddings, str padding_algorithm, int[] dilations, int groups, str data_format)
  output : Tensor(input_grad), Tensor(filter_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param: [input, filter, grad_out]
  kernel :
    func : conv2d_double_grad
  optional : grad_input_grad, grad_filter_grad

- backward_op : conv2d_transpose_double_grad
  forward : conv2d_transpose_grad(Tensor x, Tensor filter, Tensor grad_out, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(grad_x), Tensor(grad_filter)
  args : (Tensor x, Tensor filter, Tensor grad_out, Tensor grad_x_grad, Tensor grad_filter_grad, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(x_grad), Tensor(filter_grad), Tensor(grad_out_grad)
  infer_meta :
    func : Conv2dTransposeDoubleGradInferMeta
  kernel :
    func : conv2d_transpose_grad_grad

- backward_op : conv2d_transpose_grad
  forward : conv2d_transpose(Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(out)
  args : (Tensor x, Tensor filter, Tensor out_grad, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(x_grad), Tensor(filter_grad)
  infer_meta :
    func : Conv2dTransposeGradInferMeta
  kernel :
    func : conv2d_transpose_grad
  backward : conv2d_transpose_double_grad

- backward_op : conv3d_double_grad
  forward : conv3d_grad (Tensor input, Tensor filter, Tensor grad_out,  int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(grad_input), Tensor(grad_filter)
  args : (Tensor input, Tensor filter, Tensor grad_out, Tensor grad_input_grad, Tensor grad_filter_grad, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(input_grad), Tensor(filter_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param: [input, filter, grad_out]
  kernel :
    func : conv3d_double_grad
  optional : grad_input_grad, grad_filter_grad

- backward_op : conv3d_grad
  forward : conv3d (Tensor input, Tensor filter, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(out)
  args : (Tensor input, Tensor filter, Tensor out_grad,  int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(input_grad), Tensor(filter_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [input, filter]
  kernel :
    func : conv3d_grad
  backward : conv3d_double_grad

- backward_op : conv3d_transpose_grad
  forward : conv3d_transpose(Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, int[] output_size, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(out)
  args : (Tensor x, Tensor filter, Tensor out_grad, int[] strides, int[] paddings, int[] output_padding, int[] output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(x_grad), Tensor(filter_grad)
  infer_meta :
    func : ConvTransposeGradInferMeta
  kernel :
    func : conv3d_transpose_grad

- backward_op : cross_entropy_with_softmax_grad
  forward : cross_entropy_with_softmax (Tensor input, Tensor label, bool soft_label, bool use_softmax, bool numeric_stable_mode, int ignore_index, int axis) -> Tensor(softmax), Tensor(loss)
  args : (Tensor label, Tensor softmax, Tensor loss_grad, bool soft_label, bool use_softmax, bool numeric_stable_mode, int ignore_index, int axis)
  output : Tensor(input_grad)
  infer_meta :
    func : CrossEntropyWithSoftmaxGradInferMeta
  kernel :
    func : cross_entropy_with_softmax_grad
    data_type : softmax
  inplace : (softmax -> input_grad)

- backward_op : cumsum_grad
  forward : cumsum(Tensor x, Scalar axis, bool flatten, bool exclusive, bool reverse) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, Scalar axis, bool flatten, bool exclusive, bool reverse)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : cumsum_grad
    data_type: x
  composite: cumsum_grad(x, out_grad, axis, flatten, exclusive, reverse, x_grad)

- backward_op : deformable_conv_grad
  forward : deformable_conv(Tensor x, Tensor offset, Tensor filter, Tensor mask, int[] strides, int[] paddings, int[] dilations, int deformable_groups, int groups, int im2col_step) -> Tensor(out)
  args : (Tensor x, Tensor offset, Tensor filter, Tensor mask, Tensor out_grad, int[] strides, int[] paddings, int[] dilations, int deformable_groups, int groups, int im2col_step)
  output : Tensor(x_grad), Tensor(offset_grad), Tensor(filter_grad), Tensor(mask_grad)
  infer_meta :
    func : DeformableConvGradInferMeta
  kernel :
    func : deformable_conv_grad
    data_type : x
  optional : mask

- backward_op : depthwise_conv2d_double_grad
  forward : depthwise_conv2d_grad (Tensor input, Tensor filter, Tensor grad_out, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(grad_input), Tensor(grad_filter)
  args : (Tensor input, Tensor filter, Tensor grad_out, Tensor grad_input_grad, Tensor grad_filter_grad, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(input_grad), Tensor(filter_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param: [input, filter, grad_out]
  kernel :
    func : depthwise_conv2d_double_grad
  optional : grad_input_grad, grad_filter_grad

- backward_op : depthwise_conv2d_grad
  forward : depthwise_conv2d (Tensor input, Tensor filter, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(out)
  args : (Tensor input, Tensor filter, Tensor out_grad, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(input_grad), Tensor(filter_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [input, filter]
  kernel :
    func : depthwise_conv2d_grad
    param : [input, filter, out_grad, strides, paddings, padding_algorithm, groups, dilations, data_format]
  backward : depthwise_conv2d_double_grad

- backward_op : depthwise_conv2d_transpose_grad
  forward : depthwise_conv2d_transpose(Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format) -> Tensor(out)
  args : (Tensor x, Tensor filter, Tensor out_grad, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(x_grad), Tensor(filter_grad)
  infer_meta :
    func : Conv2dTransposeGradInferMeta
  kernel :
    func : depthwise_conv2d_transpose_grad

- backward_op : divide_double_grad
  forward : divide_grad (Tensor x, Tensor y, Tensor out, Tensor grad_out, int axis = -1) -> Tensor(grad_x), Tensor(grad_y)
  args : (Tensor y, Tensor out, Tensor grad_x, Tensor grad_x_grad, Tensor grad_y_grad, int axis = -1)
  output : Tensor(y_grad), Tensor(out_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [y, grad_x, grad_x]
  kernel :
    func : divide_double_grad
    data_type : out
  optional : grad_x_grad, grad_y_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : divide_grad
  forward : divide (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out, Tensor out_grad, int axis = -1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : divide_grad
  composite : divide_grad(x, y, out, out_grad, axis, x_grad, y_grad)
  backward : divide_double_grad

- backward_op : dropout_grad
  forward : dropout (Tensor x, Tensor seed_tensor, Scalar p, bool is_test, str mode, int seed, bool fix_seed) -> Tensor(out), Tensor(mask)
  args : (Tensor mask, Tensor out_grad, Scalar p, bool is_test, str mode)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : dropout_grad

- backward_op : eigvalsh_grad
  forward : eigvalsh (Tensor x, str uplo, bool is_test) -> Tensor(eigenvalues), Tensor(eigenvectors)
  args : (Tensor eigenvectors, Tensor eigenvalues_grad, str uplo, bool is_test)
  output : Tensor(x_grad)
  infer_meta :
    func : EigvalshGradInferMeta
  kernel :
    func : eigvalsh_grad
    data_type : eigenvectors
  data_transform :
    skip_transform : eigenvalues_grad

- backward_op : einsum_grad
  forward : einsum (Tensor[] x, str equation) -> Tensor(out), Tensor[](inner_cache), Tensor[](x_shape)
  args : (Tensor[] x_shape, Tensor[] inner_cache, Tensor out_grad, str equation)
  output : Tensor[](x_grad){x.size()}
  infer_meta :
    func : UnchangedMultiInferMeta
    param : [x_shape]
  kernel :
    func : einsum_grad

- backward_op : elementwise_pow_grad
  forward : elementwise_pow(Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis=-1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param: [x, y]
  composite : elementwise_pow_grad(x, y, out_grad, axis, x_grad, y_grad)
  kernel :
    func : elementwise_pow_grad

- backward_op : embedding_grad
  forward : embedding (Tensor x, Tensor weight, int64_t padding_idx=-1, bool sparse=false) -> Tensor(out)
  args : (Tensor x, Tensor weight, Tensor out_grad, int64_t padding_idx=-1, bool sparse=false)
  output : Tensor(weight_grad)
  invoke : embedding_grad_impl(x, weight, out_grad, padding_idx, sparse, weight_grad)
  no_need_buffer : weight

- backward_op : expand_as_grad
  forward : expand_as (Tensor x, Tensor y, int[] target_shape) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int[] target_shape)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : expand_as_grad
  no_need_buffer : x

- backward_op : expand_double_grad
  forward : expand_grad (Tensor x, Tensor grad_out, IntArray shape) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray shape)
  output : Tensor(grad_out_grad)
  invoke : expand(grad_x_grad, shape)

- backward_op : expand_grad
  forward : expand (Tensor x, IntArray shape) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray shape)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : expand_grad
  no_need_buffer : x
  backward : expand_double_grad
  composite: expand_grad(x, out_grad, shape, x_grad)

- backward_op : exponential__grad
  forward : exponential_ (Tensor x, float lam) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
  invoke : zeros_like(out_grad)

- backward_op : fill_grad
  forward : fill (Tensor x, Scalar value) -> Tensor(out)
  args : (Tensor out_grad, Scalar value)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : fill_grad
  inplace : (out_grad -> x_grad)

- backward_op : fmax_grad
  forward : fmax(Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param: [x, y]
  kernel :
    func : fmax_grad

- backward_op : fmin_grad
  forward : fmin(Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param: [x, y]
  kernel :
    func : fmin_grad

- backward_op : frobenius_norm_grad
  forward : frobenius_norm(Tensor x, int64_t[] axis,  bool keep_dim,  bool reduce_all) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int64_t[] axis,  bool keep_dim,  bool reduce_all)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : frobenius_norm_grad

- backward_op : gather_grad
  forward : gather(Tensor x, Tensor index, Scalar axis=0) -> Tensor(out)
  args : (Tensor x, Tensor index, Tensor out_grad, Scalar axis=0, bool overwrite=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    data_type: x
    func : gather_grad
  composite : gather_grad(x, index, out_grad, axis, overwrite, x_grad)
  no_need_buffer : x

- backward_op : group_norm_grad
  forward : group_norm (Tensor x, Tensor scale, Tensor bias, float epsilon, int groups, str data_layout) -> Tensor(y), Tensor(mean), Tensor(variance)
  args : (Tensor x, Tensor scale, Tensor bias, Tensor y, Tensor mean, Tensor variance, Tensor y_grad, float epsilon, int groups, str data_layout)
  output : Tensor(x_grad), Tensor(scale_grad), Tensor(bias_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [y, scale, bias]
  kernel :
    func : group_norm_grad
    data_type : y_grad
  optional: scale, bias
  inplace : (y_grad -> x_grad)

- backward_op : hardswish_grad
  forward : hardswish (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hardswish_grad
  inplace : (out_grad -> x_grad)

- backward_op : heaviside_grad
  forward : heaviside (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : heaviside_grad

- backward_op : hsigmoid_loss_grad
  forward : hsigmoid_loss (Tensor x, Tensor label, Tensor w, Tensor bias, Tensor path, Tensor code, int num_classes, bool remote_prefetch, bool is_sparse) -> Tensor(out), Tensor(pre_out), Tensor(w_out)
  args : (Tensor x, Tensor w, Tensor label, Tensor path, Tensor code, Tensor bias, Tensor pre_out, Tensor out_grad, int num_classes, bool remote_prefetch, bool is_sparse)
  output : Tensor(x_grad), Tensor(w_grad), Tensor(bias_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x ,w, bias]
  optional: path, code, bias
  kernel :
    func : hsigmoid_loss_grad

- backward_op : instance_norm_double_grad
  forward : instance_norm_grad(Tensor x, Tensor fwd_scale, Tensor saved_mean, Tensor saved_variance, Tensor grad_y, float epsilon) -> Tensor(grad_x), Tensor(grad_scale), Tensor(grad_bias)
  args : (Tensor x, Tensor fwd_scale, Tensor saved_mean, Tensor saved_variance, Tensor grad_y, Tensor grad_x_grad, Tensor grad_scale_grad, Tensor grad_bias_grad, float epsilon)
  output : Tensor(x_grad), Tensor(fwd_scale_grad), Tensor(grad_y_grad)
  infer_meta :
    func : InstanceNormDoubleGradInferMeta
  kernel :
    func : instance_norm_double_grad
    data_type : x
  optional : fwd_scale, grad_x_grad, grad_scale_grad, grad_bias_grad

- backward_op : instance_norm_grad
  forward : instance_norm(Tensor x, Tensor scale, Tensor bias, float epsilon) -> Tensor(y), Tensor(saved_mean), Tensor(saved_variance)
  args : (Tensor x, Tensor scale, Tensor saved_mean, Tensor saved_variance, Tensor y_grad, float epsilon)
  output : Tensor(x_grad), Tensor(scale_grad), Tensor(bias_grad)
  infer_meta :
    func : InstanceNormGradInferMeta
  kernel :
    func : instance_norm_grad
    data_type : x
  optional : scale
  backward : instance_norm_double_grad

- backward_op : layer_norm_grad
  forward : layer_norm (Tensor x, Tensor scale, Tensor bias, float epsilon, int begin_norm_axis) -> Tensor(out), Tensor(mean), Tensor(variance)
  args : (Tensor x,  Tensor scale, Tensor bias, Tensor mean, Tensor variance, Tensor out_grad, float epsilon, int begin_norm_axis)
  output : Tensor(x_grad), Tensor(scale_grad), Tensor(bias_grad)
  infer_meta :
    func : LayerNormGradInferMeta
    param : [x, scale, bias]
  kernel :
    func : layer_norm_grad
    data_type : out_grad
  composite : layer_norm_grad(x, scale, bias, mean,varience, out_grad, epsilon, begin_norm_axis, x_grad, scale_grad, bias_grad)
  no_need_buffer : bias
  optional : scale, bias

- backward_op : logcumsumexp_grad
  forward : logcumsumexp(Tensor x, int axis, bool flatten, bool exclusive, bool reverse) -> Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  args : (Tensor x, Tensor out, Tensor out_grad, int axis, bool flatten, bool exclusive, bool reverse)
  output : Tensor(x_grad)
  kernel :
    func : logcumsumexp_grad

- backward_op : logsumexp_grad
  forward : logsumexp(Tensor x, int64_t[] axis,  bool keepdim,  bool reduce_all) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int64_t[] axis,  bool keepdim,  bool reduce_all)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : logsumexp_grad

- backward_op : lu_grad
  forward : lu (Tensor x, bool pivot) -> Tensor(out), Tensor(pivots), Tensor(infos)
  args : (Tensor x, Tensor out, Tensor pivots, Tensor out_grad, bool pivot)
  output : Tensor(x_grad)
  infer_meta :
    func : LUGradInferMeta
  kernel :
    func : lu_grad

- backward_op : matmul_double_grad
  forward : matmul_grad (Tensor x, Tensor y, Tensor grad_out, bool transpose_x=false, bool transpose_y=false) -> Tensor(grad_x), Tensor(grad_y)
  args : (Tensor x, Tensor y, Tensor grad_out, Tensor grad_x_grad, Tensor grad_y_grad, bool transpose_x=false, bool transpose_y=false)
  output : Tensor(x_grad), Tensor(y_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, y, grad_out]
  kernel :
    func : matmul_double_grad
  composite : matmul_double_grad(x, y, grad_out, grad_x_grad, grad_y_grad, transpose_x=false, transpose_y=false)
  optional : grad_x_grad, grad_y_grad

- backward_op : matmul_grad
  forward : matmul (Tensor x, Tensor y, bool transpose_x=false, bool transpose_y=false) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, bool transpose_x=false, bool transpose_y=false)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : matmul_grad
  backward : matmul_double_grad

- backward_op : max_grad
  forward: max (Tensor x,  IntArray axis={},  bool keepdim=false) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, IntArray axis={}, bool keepdim=false, bool reduce_all=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : max_grad
  composite : max_grad(x, out, out_grad, axis, keepdim, reduce_all, x_grad)

- backward_op : max_pool2d_with_index_grad
  forward : max_pool2d_with_index(Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive) -> Tensor(out), Tensor(mask)
  args : (Tensor x, Tensor mask, Tensor out_grad, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive)
  output : Tensor(x_grad)
  infer_meta :
    func : MaxPoolWithIndexGradInferMeta
  kernel :
    func : max_pool2d_with_index_grad

- backward_op : max_pool3d_with_index_grad
  forward : max_pool3d_with_index(Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive) -> Tensor(out), Tensor(mask)
  args : (Tensor x, Tensor mask, Tensor out_grad, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive)
  output : Tensor(x_grad)
  infer_meta :
    func : MaxPoolWithIndexGradInferMeta
  kernel :
    func : max_pool3d_with_index_grad

- backward_op : maximum_grad
  forward : maximum(Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis=-1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param: [x, y]
  kernel :
    func : maximum_grad
  composite : maximum_grad(x, y, out_grad, axis, x_grad, y_grad)

- backward_op : mean_all_grad
  forward : mean_all(Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : mean_all_grad

- backward_op : mean_double_grad
  forward: mean_grad (Tensor x, Tensor grad_out, IntArray axis={},  bool keepdim=false, bool reduce_all = false) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray axis={},  bool keepdim=false)
  output : Tensor(grad_out_grad)
  invoke : mean(grad_x_grad, axis, keepdim)

- backward_op : mean_grad
  forward: mean (Tensor x,  IntArray axis={},  bool keepdim=false) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray axis={},  bool keepdim=false, bool reduce_all=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : mean_grad
  backward : mean_double_grad
  no_need_buffer : x

- backward_op : min_grad
  forward: min (Tensor x,  IntArray axis={},  bool keepdim=false) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, IntArray axis={}, bool keepdim=false, bool reduce_all=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : min_grad

- backward_op : minimum_grad
  forward : minimum(Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis=-1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param: [x, y]
  kernel :
    func : minimum_grad

- backward_op : mish_grad
  forward : mish (Tensor x, float threshold) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float threshold)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : mish_grad
  inplace : (out_grad -> x_grad)

- backward_op : multiply_double_grad
  forward : multiply_grad (Tensor x, Tensor y, Tensor grad_out, int axis = -1) -> Tensor(grad_x), Tensor(grad_y)
  args : (Tensor x, Tensor y, Tensor grad_out, Tensor grad_x_grad, Tensor grad_y_grad, int axis = -1)
  output : Tensor(x_grad), Tensor(y_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, y, grad_out]
  kernel :
    func : multiply_double_grad
  optional : grad_x_grad, grad_y_grad
  backward : multiply_triple_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : multiply_grad
  forward : multiply (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis = -1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : multiply_grad
  composite: multiply_grad(x, y, out_grad, axis, x_grad, y_grad)
  backward : multiply_double_grad

- backward_op : multiply_triple_grad
  forward : multiply_double_grad (Tensor x, Tensor y, Tensor fwd_grad_out, Tensor fwd_grad_grad_x, Tensor fwd_grad_grad_y, int aixs = -1) -> Tensor(grad_x), Tensor(grad_y), Tensor(grad_grad_out)
  args : (Tensor x, Tensor y, Tensor fwd_grad_out, Tensor fwd_grad_grad_x, Tensor fwd_grad_grad_y, Tensor grad_x_grad, Tensor grad_y_grad, Tensor grad_grad_out_grad, int axis = -1)
  output : Tensor(x_grad), Tensor(y_grad), Tensor(fwd_grad_out_grad), Tensor(fwd_grad_grad_x_grad), Tensor(fwd_grad_grad_y_grad)
  infer_meta :
    func : GeneralQuinaryGradInferMeta
    param : [x, y, fwd_grad_out, fwd_grad_grad_x, fwd_grad_grad_y]
  kernel :
    func : multiply_triple_grad
  optional : fwd_grad_grad_x, fwd_grad_grad_y, grad_x_grad, grad_y_grad, grad_grad_out_grad

- backward_op : norm_grad
  forward : norm (Tensor x, int axis, float epsilon, bool is_test) -> Tensor(out), Tensor(norm)
  args : (Tensor x, Tensor norm, Tensor out_grad, int axis, float epsilon, bool is_test)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : norm_grad

- backward_op : pad3d_double_grad
  forward : pad3d_grad(Tensor x, Tensor grad_out, IntArray paddings, str mode, float pad_value, str data_format) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray paddings, str mode, float pad_value, str data_format)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : Pad3dInferMeta
  kernel :
    func : pad3d

- backward_op : pad3d_grad
  forward : pad3d(Tensor x, IntArray paddings, str mode,  float pad_value, str data_format) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray paddings, str mode,  float pad_value, str data_format)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pad3d_grad
  no_need_buffer : x
  backward : pad3d_double_grad

- backward_op : pad_double_grad
  forward : pad_grad(Tensor x, Tensor grad_out, int[] paddings, Scalar pad_value) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, int[] paddings, Scalar pad_value)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : PadInferMeta
  kernel :
    func : pad

- backward_op : pad_grad
  forward : pad(Tensor x, int[] paddings, Scalar pad_value) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int[] paddings, Scalar pad_value)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pad_grad
    param: [out_grad, paddings, pad_value]
  no_need_buffer : x
  backward : pad_double_grad

- backward_op : pool2d_double_grad
  forward : pool2d_grad(Tensor x, Tensor out, Tensor grad_out, IntArray kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_x_grad, IntArray kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : Pool2DInferMeta
    param : [grad_x_grad, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
  kernel :
    func : pool2d_double_grad
    param : [grad_x_grad, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
  no_need_buffer : x

- backward_op : pool2d_grad
  forward : pool2d(Tensor x, IntArray kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, IntArray kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pool2d_grad
    param : [x, out, out_grad, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
  backward : pool2d_double_grad

- backward_op : pool3d_grad
  forward : pool3d(Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int[] kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pool3d_grad
    param : [x, out, out_grad, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]

- backward_op : prod_grad
  forward : prod (Tensor x, IntArray dims, bool keep_dim, bool reduce_all) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, IntArray dims,  bool keep_dim, bool reduce_all)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : prod_grad
  composite: prod_grad(x, out, out_grad, dims, keep_dim, reduce_all, x_grad)

- backward_op : psroi_pool_grad
  forward : psroi_pool (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, int output_channels, float spatial_scale) -> Tensor(out)
  args : (Tensor x, Tensor boxes, Tensor boxes_num, Tensor out_grad, int pooled_height, int pooled_width, int output_channels, float spatial_scale)
  output : Tensor(x_grad)
  infer_meta :
    func : GeneralUnaryGradInferMeta
    param : [x]
  kernel :
    func : psroi_pool_grad
    data_type : x
  optional : boxes_num

- backward_op : relu6_grad
  forward : relu6 (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad, float threshold = 6)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : relu6_grad
  inplace : (out_grad -> x_grad)

- backward_op : repeat_interleave_grad
  forward : repeat_interleave(Tensor x, int repeats, int axis) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int repeats, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : repeat_interleave_grad

- backward_op : repeat_interleave_with_tensor_index_grad
  forward : repeat_interleave_with_tensor_index(Tensor x, Tensor repeats, int axis) -> Tensor(out)
  args : (Tensor x, Tensor repeats, Tensor out_grad, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : repeat_interleave_with_tensor_index_grad
    data_type : x

- backward_op : reshape_double_grad
  forward : reshape_grad (Tensor xshape, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor grad_out, Tensor grad_x_grad)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [grad_out]
  kernel :
    func : reshape_double_grad
  no_need_buffer : grad_out
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : reshape_grad
  forward : reshape (Tensor x, IntArray shape) -> Tensor(out), Tensor(xshape)
  args : (Tensor xshape, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : KernelWithXShapeInferMeta
    param : [xshape]
  kernel :
    func : reshape_grad
    param : [out_grad]
    data_type: out_grad
    backend: out_grad
    layout: out_grad
  backward : reshape_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : reverse_grad
  forward : reverse (Tensor x, IntArray axis) -> Tensor(out)
  args : (Tensor out_grad, IntArray axis)
  output : Tensor(x_grad)
  invoke : reverse(out_grad, axis)

- backward_op : rnn_grad
  forward : rnn (Tensor x, Tensor[] pre_state, Tensor[] weight_list, Tensor sequence_length, Tensor dropout_state_in, float dropout_prob, bool is_bidirec, int input_size, int hidden_size, int num_layers, str mode, int seed, bool is_test) -> Tensor(out), Tensor(dropout_state_out), Tensor[](state), Tensor(reserve)
  args : (Tensor x, Tensor[] pre_state, Tensor[] weight_list, Tensor sequence_length, Tensor out, Tensor dropout_state_out, Tensor reserve, Tensor out_grad, Tensor[] state_grad, float dropout_prob, bool is_bidirec, int input_size, int hidden_size, int num_layers, str mode, int seed, bool is_test)
  output : Tensor(x_grad), Tensor[](pre_state_grad){pre_state.size()}, Tensor[](weight_list_grad){weight_list.size()}
  infer_meta :
    func : RnnGradInferMeta
    param : [x, pre_state, weight_list]
  kernel :
    func : rnn_grad
    data_type: out_grad
  optional : sequence_length

- backward_op : roi_align_grad
  forward : roi_align (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, float spatial_scale, int sampling_ratio, bool aligned) -> Tensor(out)
  args : (Tensor x, Tensor boxes, Tensor boxes_num, Tensor out_grad, int pooled_height, int pooled_width, float spatial_scale, int sampling_ratio, bool aligned)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : roi_align_grad
    data_type : boxes
  no_need_buffer : x
  optional : boxes_num

- backward_op : roi_pool_grad
  forward : roi_pool (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, float spatial_scale) -> Tensor(out), Tensor(arg_max)
  args : (Tensor x, Tensor boxes, Tensor boxes_num, Tensor arg_max, Tensor out_grad, int pooled_height, int pooled_width, float spatial_scale)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : roi_pool_grad
    data_type : x
  optional : boxes_num

- backward_op : rrelu_grad
  forward : rrelu (Tensor x, float lower, float upper, bool is_test) -> Tensor(out), Tensor(noise)
  args : (Tensor x, Tensor noise, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : RReluGradInferMeta
    param : [out_grad, noise]
  kernel :
    func : rrelu_grad
    data_type : x

- backward_op : segment_pool_grad
  forward : segment_pool (Tensor x, Tensor segment_ids, str pooltype) -> Tensor(out), Tensor(summed_ids)
  args : (Tensor x, Tensor segment_ids, Tensor out, Tensor summed_ids, Tensor out_grad, str pooltype)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : segment_pool_grad
    data_type : x
  optional : summed_ids

- backward_op : slice_double_grad
  forward : slice_grad (Tensor input, Tensor grad_out, int64_t[] axes, IntArray starts, IntArray ends, int64_t[] infer_flags, int64_t[] decrease_axis) -> Tensor(grad_input)
  args : (Tensor grad_input_grad, int64_t[] axes, IntArray starts, IntArray ends, int64_t[] infer_flags, int64_t[] decrease_axis)
  output : Tensor(grad_out_grad)
  invoke : slice(grad_input_grad, axes, starts, ends, infer_flags, decrease_axis)

- backward_op : slice_grad
  forward : slice (Tensor input, int64_t[] axes, IntArray starts, IntArray ends, int64_t[] infer_flags, int64_t[] decrease_axis) -> Tensor(out)
  args : (Tensor input, Tensor out_grad, int64_t[] axes, IntArray starts, IntArray ends, int64_t[] infer_flags, int64_t[] decrease_axis)
  output : Tensor(input_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [input]
  kernel :
    func : slice_grad
  composite: slice_grad(input, out_grad, axes, starts, ends, infer_flags, decrease_axis, input_grad)
  backward : slice_double_grad
  no_need_buffer : input

- backward_op : softmax_grad
  forward : softmax (Tensor x, int axis) -> Tensor(out)
  args : (Tensor out, Tensor out_grad, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : softmax_grad
  composite : softmax_grad(out, out_grad, axis, x_grad)

- backward_op : split_grad
  forward : split (Tensor x, IntArray num_or_sections, Scalar axis) -> Tensor[](out)
  args : (Tensor[] out_grad, Scalar axis = -1)
  output : Tensor(x_grad)
  invoke : concat( out_grad, axis)
  composite : split_grad(out_grad, axis, x_grad)

- backward_op : split_with_num_grad
  forward : split_with_num (Tensor x, int num, Scalar axis) -> Tensor[](out)
  args : (Tensor[] out_grad, Scalar axis = -1)
  output : Tensor(x_grad)
  invoke : concat( out_grad, axis)
  composite : split_grad(out_grad, axis, x_grad)

- backward_op : squared_l2_norm_grad
  forward : squared_l2_norm(Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : squared_l2_norm_grad

- backward_op : strided_slice_grad
  forward : strided_slice (Tensor x, int[] axes, IntArray starts, IntArray ends, IntArray strides) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int[] axes, IntArray starts, IntArray ends, IntArray strides)
  output : Tensor(x_grad)
  infer_meta :
    func : GeneralUnaryGradInferMeta
    param : [x]
  kernel :
    func : strided_slice_grad
  no_need_buffer : x

- backward_op : subtract_double_grad
  forward : subtract_grad (Tensor x, Tensor y, Tensor grad_out, int axis = -1) -> Tensor(grad_x), Tensor(grad_y)
  args : (Tensor y, Tensor grad_out, Tensor grad_x_grad, Tensor grad_y_grad, int axis = -1)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [grad_out]
  kernel :
    func : subtract_double_grad
  optional : grad_x_grad, grad_y_grad
  no_need_buffer : y, grad_out
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : subtract_grad
  forward : subtract (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis = -1)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : subtract_grad
  no_need_buffer : x, y
  composite : subtract_grad(x, y, out_grad, axis, x_grad, y_grad)
  backward : subtract_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : sum_double_grad
  forward : sum_grad (Tensor x, Tensor grad_out, IntArray axis, bool keepdim, bool reduce_all=false) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray axis={}, bool keepdim=false)
  output : Tensor(grad_out_grad)
  invoke : sum(grad_x_grad, axis, grad_x_grad.dtype(), keepdim)

- backward_op : sum_grad
  forward : sum (Tensor x, IntArray axis={}, DataType dtype=DataType::UNDEFINED, bool keepdim=false) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray axis, bool keepdim, bool reduce_all=false)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : sum_grad
  composite : sum_grad(x, out_grad, axis, keepdim, reduce_all, x_grad)
  no_need_buffer : x
  backward : sum_double_grad

- backward_op : swish_grad
  forward : swish (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float bete=1.0)
  output : Tensor(x_grad)
  infer_meta :
    func : GeneralUnaryGradInferMeta
    param : [x]
  kernel :
    func : swish_grad
  inplace : (out_grad -> x_grad)

- backward_op : sync_batch_norm_grad
  forward : sync_batch_norm_ (Tensor x, Tensor mean, Tensor variance, Tensor scale, Tensor bias, bool is_test, float momentum, float epsilon, str data_layout, bool use_global_stats, bool trainable_statistics) -> Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean), Tensor(saved_variance), Tensor(reserve_space)
  args : (Tensor x, Tensor scale, Tensor bias, Tensor saved_mean, Tensor saved_variance, Tensor reserve_space, Tensor out_grad, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics)
  output : Tensor(x_grad), Tensor(scale_grad), Tensor(bias_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, scale, bias]
  kernel :
    func : sync_batch_norm_grad
    data_type : out_grad
  optional : reserve_space

- backward_op : temporal_shift_grad
  forward : temporal_shift(Tensor x, int seg_num, float shift_ratio, str data_format_str) -> Tensor(out)
  args : (Tensor out_grad, int seg_num, float shift_ratio, str data_format_str)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : temporal_shift_grad

- backward_op : tile_double_grad
  forward : tile_grad (Tensor x, Tensor grad_out, IntArray repeat_times) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray repeat_times)
  output : Tensor(grad_out_grad)
  invoke : tile(grad_x_grad, repeat_times)

- backward_op : tile_grad
  forward : tile (Tensor x, IntArray repeat_times) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray repeat_times)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : tile_grad
  no_need_buffer : x
  backward : tile_double_grad

- backward_op : transpose_double_grad
  forward : transpose_grad (Tensor grad_out, int[] perm) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, int[] perm)
  output : Tensor(grad_out_grad)
  invoke : transpose(grad_x_grad, perm)

- backward_op : transpose_grad
  forward : transpose (Tensor x, int[] perm) -> Tensor(out)
  args : (Tensor out_grad, int[] perm)
  output : Tensor(x_grad)
  infer_meta :
    func : TransposeGradInferMeta
    param : [out_grad, perm]
  kernel :
    func : transpose_grad
  backward : transpose_double_grad
  composite: transpose_grad(out_grad, perm, x_grad)

- backward_op : triangular_solve_grad
  forward : triangular_solve (Tensor x, Tensor y, bool upper, bool tranpose, bool unitriangular) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out, Tensor out_grad, bool upper, bool tranpose, bool unitriangular)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : triangular_solve_grad

- backward_op : tril_grad
  forward : tril(Tensor x,  int diagonal) -> Tensor(out)
  args : (Tensor out_grad,  int diagonal)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : tril_grad

- backward_op : triu_grad
  forward : triu(Tensor x,  int diagonal) -> Tensor(out)
  args : (Tensor out_grad,  int diagonal)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : triu_grad

- backward_op : uniform_inplace_grad
  forward : uniform_inplace(Tensor x, float min, float max, int seed, int diag_num, int diag_step, float diag_val) -> Tensor(out)
  args : (Tensor out_grad, float min, float max, int seed, int diag_num, int diag_step, float diag_val)
  output : Tensor(x_grad)
  infer_meta :
    func : UniformRandomInplaceGradInferMeta
  kernel :
    func : uniform_inplace_grad
  inplace : (out_grad -> x_grad)

- backward_op : warpctc_grad
  forward : warpctc (Tensor logits, Tensor label, Tensor logits_length, Tensor labels_length, int blank, bool norm_by_times) -> Tensor(loss), Tensor(warpctcgrad)
  args : (Tensor logits, Tensor logits_length, Tensor warpctcgrad, Tensor loss_grad, int blank, bool norm_by_times)
  output : Tensor(logits_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [logits]
  kernel :
    func : warpctc_grad
  optional : logits_length
  no_need_buffer : logits

- backward_op : yolo_loss_grad
  forward : yolo_loss(Tensor x, Tensor gt_box, Tensor gt_label, Tensor gt_score, int[] anchors, int[] anchor_mask, int class_num, float ignore_thresh, int downsample_ratio, bool use_label_smooth=true, float scale_x_y=1.0) -> Tensor(loss), Tensor(objectness_mask), Tensor(gt_match_mask)
  args : (Tensor x, Tensor gt_box, Tensor gt_label, Tensor gt_score, Tensor objectness_mask, Tensor gt_match_mask, Tensor loss_grad, int[] anchors, int[] anchor_mask, int class_num, float ignore_thresh, int downsample_ratio, bool use_label_smooth=true, float scale_x_y=1.0)
  output : Tensor(x_grad), Tensor(gt_box_grad), Tensor(gt_label_grad), Tensor(gt_score_grad)
  infer_meta :
    func : YoloLossGradInferMeta
  kernel :
    func : yolo_loss_grad
  optional : gt_score

- backward_op: unpool3d_grad
  forward: unpool3d (Tensor x, Tensor indices, int[] ksize, int[] strides, int[] padding, int[] output_size, str data_format) -> Tensor(out)
  args: (Tensor x, Tensor indices, Tensor out, Tensor out_grad, int[] ksize, int[] strides, int[] padding, int[] output_size, str data_format)
  output: Tensor(x_grad)
  infer_meta:
    func: UnchangedInferMeta
    param : [x]
  kernel:
    func: unpool3d_grad
    data_type: x

- backward_op: unpool_grad
  forward: unpool (Tensor x, Tensor indices, int[] ksize, int[] strides, int[] padding,  IntArray output_size, str data_format) -> Tensor(out)
  args: (Tensor x, Tensor indices, Tensor out, Tensor out_grad, int[] ksize, int[] strides, int[] padding, IntArray output_size, str data_format)
  output: Tensor(x_grad)
  infer_meta:
    func: UnchangedInferMeta
    param : [x]
  kernel:
    func: unpool_grad
    data_type: x

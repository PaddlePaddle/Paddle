# The apis in this file are unstandardized that may caused by a variety of reasons,
# we are trying to fix these apis and will move standardized apis into ops.yaml.

- op : abs
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : abs
  backward : abs_grad

- op : accuracy
  args : (Tensor x, Tensor indices, Tensor label)
  output : Tensor(accuracy), Tensor(correct), Tensor(total)
  infer_meta :
    func : AccuracyInferMeta
  kernel :
    func : accuracy
    dtype : x

- op : acos
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : acos
  backward : acos_grad

- op : acosh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : acosh
  backward : acosh_grad

- op : adadelta_
  args : (Tensor param, Tensor grad, Tensor avg_squared_grad, Tensor avg_squared_update, float rho, float epsilon)
  output : Tensor(param_out), Tensor(moment_out), Tensor(inf_norm_out)
  infer_meta :
    func : AdadeltaInferMeta
  kernel :
    func : adadelta
  inplace : (param -> param_out), (avg_squared_grad -> moment_out), (avg_squared_update -> inf_norm_out)

- op : adagrad_
  args : (Tensor param, Tensor grad, Tensor moment, Tensor learning_rate, float epsilon)
  output : Tensor(param_out), Tensor(moment_out)
  infer_meta :
    func : AdagradInferMeta
  kernel :
    func : adagrad {dense, dense, dense, dense -> dense, dense}
           adagrad_dense_param_sparse_grad {dense, selected_rows, dense, dense -> dense, dense}
    data_type : param
  inplace : (param -> param_out), (moment -> moment_out)

- op : adam_
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment1, Tensor moment2, Tensor beta1_pow, Tensor beta2_pow, Tensor master_param, Tensor skip_update, Scalar beta1, Scalar beta2, Scalar epsilon, bool lazy_mode, int64_t min_row_size_to_use_multithread, bool multi_precision, bool use_global_beta_pow)
  output : Tensor(param_out), Tensor(moment1_out), Tensor(moment2_out), Tensor(beta1_pow_out), Tensor(beta2_pow_out), Tensor(master_param_outs)
  infer_meta :
    func : AdamInferMeta
  kernel :
    func : adam {dense, dense, dense, dense, dense, dense, dense, dense, dense -> dense, dense, dense, dense, dense, dense},
           adam_dense_param_sparse_grad {dense, selected_rows, dense, dense, dense, dense, dense, dense, dense -> dense, dense, dense, dense, dense, dense}
    data_type : param
  optional : master_param, skip_update
  inplace : (param -> param_out), (moment1 -> moment1_out), (moment2 -> moment2_out), (beta1_pow -> beta1_pow_out), (beta2_pow -> beta2_pow_out), (master_param -> master_param_outs)

- op : adamax_
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment, Tensor inf_norm, Tensor beta1_pow, float beta1, float beta2, float epsilon)
  output : Tensor(param_out), Tensor(avg_squared_grad_out), Tensor(avg_squared_update_out)
  infer_meta :
    func : AdamaxInferMeta
  kernel :
    func : adamax
  inplace : (param -> param_out), (moment -> avg_squared_grad_out), (inf_norm -> avg_squared_update_out)

- op : adamw_
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment1, Tensor moment2, Tensor beta1_pow, Tensor beta2_pow, Tensor master_param, Tensor skip_update, Scalar beta1, Scalar beta2, Scalar epsilon, float lr_ratio, float coeff, bool with_decay, bool lazy_mode, int64_t min_row_size_to_use_multithread, bool multi_precision, bool use_global_beta_pow)
  output : Tensor(param_out), Tensor(moment1_out), Tensor(moment2_out), Tensor(beta1_pow_out), Tensor(beta2_pow_out), Tensor(master_param_outs)
  infer_meta :
    func : AdamwInferMeta
  kernel :
    func : adamw
    data_type : param
  optional : master_param, skip_update
  inplace : (param -> param_out), (moment1 -> moment1_out), (moment2 -> moment2_out), (beta1_pow -> beta1_pow_out), (beta2_pow -> beta2_pow_out), (master_param -> master_param_outs)

- op : add
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : add
  inplace : (x -> out)
  backward : add_grad

- op : add_n
  args : (Tensor[] x)
  output : Tensor
  invoke : add_n_impl(x)
  backward : add_n_grad

- op : addmm
  args : (Tensor input, Tensor x, Tensor y, float alpha, float beta)
  output : Tensor
  infer_meta :
    func : AddmmInferMeta
  kernel :
    func : addmm
  backward : addmm_grad

- op : affine_grid
  args : (Tensor input, IntArray outputShape, bool use_cudnn=true, bool align_corners=true)
  output : Tensor
  infer_meta :
    func : AffineGridInferMeta
    param : [input, outputShape, align_corners]
  kernel :
    func : affine_grid
    param : [input, outputShape, align_corners]
    data_type : input
    use_gpudnn: use_cudnn
  backward : affine_grid_grad

- op : all
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : all

- op : allclose
  args : (Tensor x, Tensor y, Scalar rtol, Scalar atol, bool equal_nan)
  output : Tensor(out)
  infer_meta :
    func : AllValueCompareInferMeta
    param: [x, y]
  kernel :
    func : allclose

- op : amax
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : amax
  backward : amax_grad

- op : amin
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : amin
  backward : amin_grad

- op : angle
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : angle
  backward : angle_grad

- op : any
  args : (Tensor x, int64_t[] dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMeta
  kernel :
    func : any

- op : arange
  args : (Tensor start, Tensor end, Tensor step, DataType dtype, Place place={})
  output : Tensor(out)
  infer_meta :
    func : ArangeInferMeta
    param : [start, end, step]
  kernel :
    func : arange
    param : [start, end, step]
    data_type : dtype
    backend : place
  data_transform :
    support_trans_dtype : start, end, step

- op : argmax
  args : (Tensor x, Scalar axis, bool keepdims, bool flatten, int dtype)
  output : Tensor(out)
  infer_meta :
    func : ArgMinMaxInferMeta
  kernel :
    func : arg_max

- op : argmin
  args : (Tensor x, Scalar axis, bool keepdims, bool flatten, int dtype)
  output : Tensor(out)
  infer_meta :
    func : ArgMinMaxInferMeta
  kernel :
    func : arg_min

- op : argsort
  args : (Tensor x, int axis=-1, bool descending=false)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : ArgsortInferMeta
  kernel :
    func : argsort
  backward : argsort_grad

- op : as_complex
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : AsComplexInferMeta
  kernel :
    func : as_complex
  backward : as_complex_grad

- op : as_real
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : AsRealInferMeta
  kernel :
    func : as_real
  backward : as_real_grad

- op : asin
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : asin
  backward : asin_grad

- op : asinh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : asinh
  backward : asinh_grad

- op : assign
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : assign
  backward : assign_grad

- op : assign_out_
  args : (Tensor x, Tensor output)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : assign
    param : [x]
  inplace : (output -> out)
  backward : assign_out__grad

- op : assign_value_
  args : (Tensor output, int[] shape, DataType dtype, Scalar[] values, Place place = {})
  output : Tensor(out)
  inplace: (output -> out)
  infer_meta :
    func : AssignValueInferMeta
    param : [shape, dtype]
  kernel :
    func : assign_value
    param : [shape, dtype, values]
    data_type : dtype
    backend : place > output

- op : atan
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : atan
  backward : atan_grad

- op : atanh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : atanh
  backward : atanh_grad

- op : auc
  args : (Tensor x, Tensor label, Tensor stat_pos, Tensor stat_neg, Tensor ins_tag_weight, str curve, int num_thresholds, int slide_steps)
  output : Tensor(auc), Tensor(stat_pos_out), Tensor(stat_neg_out)
  infer_meta :
    func : AucInferMeta
  kernel :
    func : auc
  optional : ins_tag_weight

- op : average_accumulates_
  args : (Tensor param, Tensor in_sum_1, Tensor in_sum_2, Tensor in_sum_3, Tensor in_num_accumulates, Tensor in_old_num_accumulates, Tensor in_num_updates, float average_window, int64_t max_average_window, int64_t min_average_window)
  output : Tensor(out_sum_1), Tensor(out_sum_2), Tensor(out_sum_3), Tensor(out_num_accumulates), Tensor(out_old_num_accumulates), Tensor(out_num_updates)
  infer_meta:
    func : AverageAccumulatesInferMeta
  kernel :
    func : average_accumulates {dense, dense, dense, dense, dense ,dense, dense -> dense, dense, dense, dense, dense, dense}
    data_type : param
  inplace : (in_sum_1 -> out_sum_1), (in_sum_2 -> out_sum_2), (in_sum_3 -> out_sum_3), (in_num_accumulates -> out_num_accumulates), (in_old_num_accumulates -> out_old_num_accumulates), (in_num_updates -> out_num_updates)

- op : batch_norm
  args : (Tensor x, Tensor scale, Tensor bias, Tensor mean, Tensor variance, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics, bool fuse_with_relu)
  output : Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean), Tensor(saved_variance), Tensor(reserve_space)
  invoke : batch_norm_impl(x, scale, bias, mean, variance, momentum, epsilon, data_layout, is_test, use_global_stats, trainable_statistics, fuse_with_relu)
  backward : batch_norm_grad

- op : bce_loss
  args : (Tensor input, Tensor label)
  output : Tensor
  infer_meta :
    func : BCELossInferMeta
  kernel :
    func : bce_loss
  backward : bce_loss_grad

- op : bicubic_interp
  args : (Tensor x, Tensor out_size, Tensor[] size_tensor, Tensor scale_tensor, str data_layout, int out_d, int out_h, int out_w, float[] scale, str interp_method, bool align_corners, int align_mode)
  output : Tensor(output)
  infer_meta :
    func : InterpolateInferMeta
  optional: out_size, size_tensor, scale_tensor
  kernel :
    func : bicubic_interp
    data_type : x
  backward : bicubic_interp_grad

- op : bilinear_interp
  args : (Tensor x, Tensor out_size, Tensor[] size_tensor, Tensor scale_tensor, str data_layout, int out_d, int out_h, int out_w, float[] scale, str interp_method, bool align_corners, int align_mode)
  output : Tensor(output)
  infer_meta :
    func : InterpolateInferMeta
  optional: out_size, size_tensor, scale_tensor
  kernel :
    func : bilinear_interp
    data_type : x
  backward : bilinear_interp_grad

- op : bilinear_tensor_product
  args : (Tensor x, Tensor y, Tensor weight, Tensor bias)
  output : Tensor
  infer_meta :
    func : BilinearTensorProductInferMeta
  kernel :
    func : bilinear_tensor_product
  optional : bias
  backward : bilinear_tensor_product_grad

- op : bitwise_and
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : bitwise_and

- op : bitwise_not
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : bitwise_not

- op : bitwise_or
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : bitwise_or

- op : bitwise_xor
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : bitwise_xor

- op : bmm
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : BmmInferMeta
  kernel :
    func : bmm
  backward : bmm_grad

- op : box_coder
  args : (Tensor prior_box, Tensor prior_box_var, Tensor target_box, str code_type, bool box_normalized, int axis, float[] variance)
  output : Tensor(output_box)
  infer_meta :
    func : BoxCoderInferMeta
  kernel :
    func : box_coder
  optional : prior_box_var

- op : brelu
  args : (Tensor x, float t_min, float t_max)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : brelu
  backward : brelu_grad

- op : cast
  args : (Tensor x, DataType out_dtype)
  output : Tensor
  infer_meta :
    func : CastInferMeta
  kernel :
    func : cast
    param : [x, out_dtype]
    data_type : x
  backward : cast_grad

- op : ceil
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : ceil
  inplace : (x -> out)
  backward : ceil_grad

- op : celu
  args : (Tensor x, float alpha)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : celu
  backward : celu_grad

- op : check_finite_and_unscale_
  args : (Tensor[] x, Tensor scale, Tensor input_found_infinite)
  output : Tensor[](out){x.size()}, Tensor(output_found_infinite)
  infer_meta :
    func : CheckFiniteAndUnscaleInferMeta
    param : [x, scale]
  kernel :
    func : check_finite_and_unscale
    param : [x, scale]
    data_type : x
  inplace : (x -> out), (input_found_infinite -> output_found_infinite)

- op : class_center_sample
  args : (Tensor label, int num_classes, int num_samples, int ring_id, int rank, int nranks, bool fix_seed, int seed)
  output : Tensor(remapped_label), Tensor(sampled_local_class_center)
  infer_meta :
    func : ClassCenterSampleInferMeta
  kernel :
    func : class_center_sample

- op : clip
  args : (Tensor x, Scalar(float) min, Scalar(float) max)
  output : Tensor(out)
  inplace : (x -> out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : clip
  backward : clip_grad

- op : clip_by_norm
  args : (Tensor x, float max_norm)
  output : Tensor(out)
  infer_meta :
    func : ClipByNormInferMeta
  kernel :
    func : clip_by_norm

- op : coalesce_tensor
  args : (Tensor[] input, DataType dtype, bool copy_data = false, bool set_constant = false, bool persist_output = false, float constant = 0.0, bool use_align = true, int align_size = -1, int size_of_dtype = -1, int64_t[] concated_shapes = {}, int64_t[] concated_ranks = {})
  output : Tensor[](output){input.size()}, Tensor(fused_output)
  infer_meta :
    func : CoalesceTensorInferMeta
  kernel :
    func : coalesce_tensor
    data_type : dtype

- op : complex
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ComplexInferMeta
  kernel :
    func : complex
  backward : complex_grad

- op : concat
  args : (Tensor[] x, Scalar(int64_t) axis)
  output : Tensor
  infer_meta :
    func : ConcatInferMeta
    param : [x, axis]
  kernel :
    func : concat
  backward : concat_grad

- op : conj
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : conj
  backward : conj_grad

- op : conv2d
  args : (Tensor input, Tensor filter, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format, bool use_addto, int workspace_size_MB, bool exhaustive_search)
  output : Tensor
  infer_meta :
    func : ConvInferMeta
  kernel :
    func : conv2d
    use_gpudnn : true
  backward : conv2d_grad

- op : conv2d_transpose
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(out)
  infer_meta :
    func : Conv2dTransposeInferMeta
  kernel :
    func : conv2d_transpose
    use_gpudnn : true
  backward : conv2d_transpose_grad

- op : conv3d
  args : (Tensor input, Tensor filter, int[] strides, int[] paddings, str paddding_algorithm, int groups, int[] dilations, str data_format, bool use_addto, int workspace_size_MB, bool exhaustive_search)
  output : Tensor
  infer_meta :
    func : ConvInferMeta
  kernel :
    func : conv3d
    use_gpudnn : true
  backward : conv3d_grad

- op : conv3d_transpose
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, int[] output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(out)
  infer_meta :
    func : ConvTransposeInferMeta
  kernel :
    func : conv3d_transpose
    use_gpudnn : true
  backward : conv3d_transpose_grad

- op : copy_to
  args : (Tensor x, Place place, bool blocking)
  output : Tensor(out)
  invoke : copy_to_impl(x, place, blocking)

- op : cos
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : cos
  backward : cos_grad

- op : cosh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : cosh
  backward : cosh_grad

- op : crop_tensor
  args : (Tensor x, IntArray shape, IntArray offsets)
  output : Tensor(out)
  infer_meta :
    func : CropTensorInferMeta
  kernel :
    func : crop_tensor
    data_type : x
  backward : crop_tensor_grad

# Part of python API paddle.nn.functional.cross_entropy
- op : cross_entropy_with_softmax
  args : (Tensor input, Tensor label, bool soft_label, bool use_softmax, bool numeric_stable_mode, int ignore_index, int axis)
  output : Tensor(softmax), Tensor(loss)
  infer_meta :
    func : CrossEntropyWithSoftmaxInferMeta
  kernel :
    func : cross_entropy_with_softmax
    data_type : input
  backward : cross_entropy_with_softmax_grad

- op : cumprod
  args : (Tensor x,  int dim)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : cumprod
  backward : cumprod_grad

- op : cumsum
  args : (Tensor x, Scalar axis, bool flatten, bool exclusive, bool reverse)
  output : Tensor(out)
  infer_meta :
    func : CumScalarAxisInferMeta
  kernel :
    func : cumsum
  backward : cumsum_grad

- op : decode_jpeg
  args : (Tensor x, str mode)
  output : Tensor(out)
  infer_meta :
    func : DecodeJpegInferMeta
  kernel :
    func : decode_jpeg

- op : deformable_conv
  args : (Tensor x, Tensor offset, Tensor filter, Tensor mask, int[] strides, int[] paddings, int[] dilations, int deformable_groups, int groups, int im2col_step)
  output : Tensor(out)
  infer_meta :
    func : DeformableConvInferMeta
  kernel :
    func : deformable_conv
    data_type : x
  optional : mask
  backward : deformable_conv_grad

- op : depthwise_conv2d
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, str padding_algorithm, int groups, int[] dilations, str data_format, bool use_addto, int workspace_size_MB, bool exhaustive_search, bool fuse_relu, bool use_gpudnn)
  output : Tensor(out)
  infer_meta :
    func : ConvInferMeta
    param : [x, filter, strides, paddings, padding_algorithm, groups, dilations, data_format, use_addto, workspace_size_MB, exhaustive_search]
  kernel :
    func : depthwise_conv2d
    param : [x, filter, strides, paddings, padding_algorithm, groups, dilations, data_format, use_addto, workspace_size_MB, exhaustive_search, fuse_relu]
    use_gpudnn : use_gpudnn
  backward : depthwise_conv2d_grad

- op : depthwise_conv2d_transpose
  args : (Tensor x, Tensor filter, int[] strides, int[] paddings, int[] output_padding, IntArray output_size, str padding_algorithm, int groups, int[] dilations, str data_format)
  output : Tensor(out)
  infer_meta :
    func : Conv2dTransposeInferMeta
  kernel :
    func : depthwise_conv2d_transpose
  backward : depthwise_conv2d_transpose_grad

- op : det
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : determinant
  backward : det_grad

- op : diag_embed
  args : (Tensor x, int offset, int dim1, int dim2)
  output : Tensor(out)
  infer_meta :
    func : DiagEmbedInferMeta
  kernel :
    func : diag_embed

- op : distribute_fpn_proposals
  args : (Tensor fpn_rois, Tensor rois_num, int min_level, int max_level, int refer_level, int refer_scale, bool pixel_offset)
  output : Tensor[](multi_fpn_rois){max_level - min_level + 1}, Tensor[](multi_level_rois_num){max_level - min_level + 1}, Tensor(restore_index)
  infer_meta :
    func : DistributeFpnProposalsInferMeta
  kernel :
    func : distribute_fpn_proposals
    data_type : fpn_rois
  optional : rois_num

- op : divide
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : divide
  backward : divide_grad

- op : dropout
  args : (Tensor x, Tensor seed_tensor, Scalar p, bool is_test, str mode, int seed, bool fix_seed)
  output : Tensor(out), Tensor(mask)
  infer_meta :
    func : DropoutInferMeta
  kernel :
    func : dropout
    data_type : x
  optional : seed_tensor
  backward : dropout_grad

- op : edit_distance
  args : (Tensor hyps, Tensor refs, Tensor hypslength, Tensor refslength, bool normalized = false)
  output : Tensor(sequencenum), Tensor(out)
  infer_meta :
    func : EditDistanceInferMeta
  kernel :
    func : edit_distance
    data_type: DataType::FLOAT32
  optional : hypslength, refslength

- op : eigh
  args : (Tensor x, str uplo)
  output : Tensor(out_w), Tensor(out_v)
  infer_meta :
    func : EighInferMeta
  kernel :
    func : eigh
  backward : eigh_grad

- op : eigvals
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : EigvalsInferMeta
  kernel :
    func : eigvals

- op : eigvalsh
  args : (Tensor x, str uplo, bool is_test)
  output : Tensor(eigenvalues), Tensor(eigenvectors)
  infer_meta :
    func : EigvalshInferMeta
  kernel :
    func : eigvalsh
  backward : eigvalsh_grad

- op : einsum
  args : (Tensor[] x, str equation)
  output : Tensor, Tensor[]{x.size()}, Tensor[]{x.size()}
  infer_meta :
    func : EinsumRawInferMeta
    param : [x, equation]
  kernel :
    func : einsum_raw
  backward : einsum_grad

- op : elementwise_pow
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : elementwise_pow
  backward : elementwise_pow_grad

- op : elu
  args : (Tensor x, float alpha)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : elu
  inplace : (x -> out)
  backward : elu_grad

- op : embedding
  args : (Tensor x, Tensor weight, int64_t padding_idx=-1, bool sparse=false)
  output : Tensor
  invoke : embedding_impl(x, weight, padding_idx, sparse)
  backward : embedding_grad

- op : empty
  args : (IntArray shape, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output: Tensor(out)
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : empty
    param : [shape, dtype]
    data_type : dtype
    backend : place

- op : empty_like
  args : (Tensor x, DataType dtype = DataType::UNDEFINED, Place place = {})
  output: Tensor(out)
  infer_meta :
    func : CreateLikeInferMeta
    param : [x, dtype]
  kernel :
    func : empty_like
    param : [x, dtype]
    data_type : dtype > x
    backend : place > x

- op : equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor(out)
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : equal

- op : equal_all
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : CompareAllInferMeta
  kernel :
    func : equal_all

- op : exp
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : exp
  inplace : (x -> out)
  backward : exp_grad

- op : expand
  args : (Tensor x, IntArray shape)
  output : Tensor
  infer_meta :
    func : ExpandInferMeta
  kernel :
    func : expand
  backward : expand_grad

- op : expand_as
  args : (Tensor x, Tensor y, int[] target_shape)
  output : Tensor
  infer_meta :
    func : ExpandAsInferMeta
  kernel :
    func : expand_as
  optional : y
  backward : expand_as_grad

- op : expm1
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : expm1
  backward : expm1_grad

- op : exponential_
  args : (Tensor x, float lambda)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : exponential
  inplace : (x -> out)
  backward : exponential__grad

- op : eye
  args : (Scalar num_rows, Scalar num_columns, DataType dtype=DataType::FLOAT32, Place place={})
  output : Tensor(out)
  infer_meta :
    func : EyeInferMeta
    param : [num_rows, num_columns, dtype]
  kernel :
    func : eye
    param : [num_rows, num_columns, dtype]
    data_type : dtype
    backend : place

- op : fill
  args : (Tensor x, Scalar value)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : fill
  inplace : (x -> out)
  backward: fill_grad

- op : fill_diagonal
  args : (Tensor x, float value, int offset, bool wrap)
  output : Tensor(out)
  infer_meta :
    func : FillDiagonalInferMeta
  kernel :
    func : fill_diagonal
  inplace : (x -> out)
  backward : fill_diagonal_grad

- op : fill_diagonal_tensor
  args : (Tensor x, Tensor y, int64_t offset, int dim1, int dim2)
  output : Tensor(out)
  infer_meta :
    func : FillDiagonalTensorInferMeta
  kernel :
    func : fill_diagonal_tensor
  inplace : (x -> out)
  backward : fill_diagonal_tensor_grad

- op : flatten
  args : (Tensor x, int start_axis, int stop_axis)
  output : Tensor(out), Tensor(xshape)
  infer_meta :
    func : FlattenWithXShapeInferMeta
  kernel :
    func : flatten_with_xshape
    backend : x
  inplace : (x -> out)
  view : (x -> out)
  intermediate : xshape
  backward : flatten_grad

- op : flip
  args : (Tensor x, int[] axis)
  output : Tensor
  infer_meta :
    func : FlipInferMeta
  kernel :
    func : flip
  backward : flip_grad

- op : floor
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : floor
  inplace : (x -> out)
  backward : floor_grad

- op : floor_divide
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : floor_divide

- op : fmax
  args : (Tensor x, Tensor y,  int axis)
  output : Tensor(out)
  infer_meta :
    param: [x, y]
    func : ElementwiseInferMeta
  kernel :
    func : fmax
  backward : fmax_grad

- op : fmin
  args : (Tensor x, Tensor y,  int axis)
  output : Tensor(out)
  infer_meta :
    param: [x, y]
    func : ElementwiseInferMeta
  kernel :
    func : fmin
  backward : fmin_grad

- op : frame
  args : (Tensor x, int frame_length, int hop_length, int axis)
  output : Tensor(out)
  infer_meta :
    func : FrameInferMeta
  kernel :
    func : frame
  backward : frame_grad

- op : frobenius_norm
  args : (Tensor x, int64_t[] axis,  bool keep_dim,  bool reduce_all)
  output : Tensor(out)
  infer_meta :
    func : ReduceInferMetaBase
  kernel :
    func : frobenius_norm
  backward : frobenius_norm_grad

- op : full
  args : (IntArray shape, Scalar value, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output: Tensor(out)
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : full
    param : [shape, value, dtype]
    data_type : dtype
    backend : place

- op : full_
  args : (Tensor output, IntArray shape, Scalar value, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output : Tensor(out)
  inplace : (output -> out)
  infer_meta :
    func : CreateInferMeta
    param : [shape, dtype]
  kernel :
    func : full
    param : [shape, value, dtype]
    data_type : dtype
    backend : place

- op : full_batch_size_like
  args : (Tensor input, int[] shape, DataType dtype, Scalar value, int input_dim_idx, int output_dim_idx, Place place=CPUPlace())
  output: Tensor(out)
  infer_meta :
    func : FullBatchSizeLikeInferMeta
    param : [input, shape, value, dtype, input_dim_idx, output_dim_idx]
  kernel :
    func : full_batch_size_like
    param : [input, shape, value, dtype, input_dim_idx, output_dim_idx]
    data_type : dtype
    backend : place

- op : full_like
  args : (Tensor x, Scalar value, DataType dtype = DataType::UNDEFINED, Place place = {})
  output: Tensor(out)
  infer_meta :
    func : CreateLikeInferMeta
    param : [x, dtype]
  kernel :
    func : full_like
    param : [x, value, dtype]
    data_type : dtype > x
    backend : place > x
  data_transform :
    skip_transform : x

- op : gather
  args : (Tensor x, Tensor index, Scalar(int) axis=0)
  output : Tensor(out)
  infer_meta :
    func : GatherInferMeta
  kernel :
    func : gather
    data_type: x
  backward : gather_grad

- op : gather_nd
  args : (Tensor x, Tensor index)
  output : Tensor
  infer_meta :
    func : GatherNdInferMeta
  kernel :
    func : gather_nd
    data_type : x
  backward : gather_nd_grad

- op : gather_tree
  args : (Tensor ids, Tensor parents)
  output : Tensor(out)
  infer_meta :
    func : GatherTreeMeta
  kernel :
    func : gather_tree

- op : gaussian_random
  args : (IntArray shape, float mean, float std, int seed, DataType dtype, Place place={})
  output: Tensor(out)
  infer_meta :
    func : GaussianRandomInferMeta
    param : [shape, mean, std, seed, dtype]
  kernel :
    func : gaussian_random
    param : [shape, mean, std, seed, dtype]
    data_type : dtype
    backend : place

- op : gelu
  args : (Tensor x,  bool approximate)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : gelu
  backward : gelu_grad

- op : generate_proposals_v2
  args : (Tensor scores, Tensor bbox_deltas, Tensor im_shape, Tensor anchors, Tensor variances, int pre_nms_top_n, int post_nms_top_n, float nms_thresh, float min_size, float eta, bool pixel_offset=true)
  output : Tensor(rpn_rois), Tensor(rpn_roi_probs), Tensor(rpn_rois_num)
  infer_meta :
    func : GenerateProposalsV2InferMeta
  kernel :
    func : generate_proposals_v2

- op : graph_send_recv
  args : (Tensor x, Tensor src_index, Tensor dst_index, str reduce_op = "SUM", IntArray out_size = {0})
  output : Tensor(out), Tensor(dst_count)
  infer_meta :
    func : GraphSendRecvInferMeta
  kernel :
    func : graph_send_recv
    data_type : x
  intermediate : dst_count
  backward : graph_send_recv_grad

- op : graph_send_ue_recv
  args : (Tensor x, Tensor y, Tensor src_index, Tensor dst_index, str message_op, str reduce_op, IntArray out_size)
  output : Tensor(out), Tensor(dst_count)
  infer_meta :
    func : GraphSendUERecvInferMeta
  kernel :
    func : graph_send_ue_recv
    data_type : x
  intermediate : dst_count
  backward : graph_send_ue_recv_grad

- op : greater_equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor(out)
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : greater_equal

- op : greater_than
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor(out)
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : greater_than

- op : grid_sample
  args : (Tensor x, Tensor grid, str mode, str padding_mode, bool align_corners)
  output : Tensor(out)
  infer_meta :
    func : GridSampleBaseInferMeta
    param : [x, grid]
  kernel:
    func : grid_sample
    data_type : x
  backward : grid_sample_grad

- op : group_norm
  args : (Tensor x, Tensor scale, Tensor bias, float epsilon, int groups, str data_layout)
  output : Tensor(y), Tensor(mean), Tensor(variance)
  infer_meta :
    func : GroupNormInferMeta
  kernel :
    func : group_norm
  optional : scale, bias
  intermediate : mean, variance
  backward : group_norm_grad

- op : gumbel_softmax
  args : (Tensor x, float temperature, bool hard, int axis)
  output : Tensor
  infer_meta :
    func : GumbelSoftmaxInferMeta
  kernel :
    func : gumbel_softmax
  backward : gumbel_softmax_grad

- op : hard_shrink
  args : (Tensor x, float threshold)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_shrink
  backward : hard_shrink_grad

- op : hard_sigmoid
  args : (Tensor x, float slope, float offset)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_sigmoid
  backward : hard_sigmoid_grad

- op : hard_swish
  args : (Tensor x, float threshold = 6.0, float scale = 6.0, float offset = 3.0)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_swish
  backward : hard_swish_grad

- op : hierarchical_sigmoid
  args : (Tensor x, Tensor w, Tensor label, Tensor path, Tensor code, Tensor bias, int num_classes, bool remote_prefetch, int trainer_id, int64_t[] height_sections, str[] epmap, str[] table_names, bool is_sparse)
  output : Tensor(out), Tensor(pre_out), Tensor(w_out)
  infer_meta :
    func : HierarchicalSigmoidInferMeta
  optional: path, code, bias
  kernel :
    func : hierarchical_sigmoid
    data_type : x
  backward : hierarchical_sigmoid_grad

- op : histogram
  args : (Tensor x, int64_t bins, int min, int max)
  output : Tensor(out)
  infer_meta :
    func : HistogramInferMeta
  kernel :
    func : histogram

- op : huber_loss
  args : (Tensor input, Tensor label, float delta)
  output : Tensor(out), Tensor(residual)
  infer_meta :
    func : HuberLossInferMeta
  kernel :
    func : huber_loss
  backward : huber_loss_grad

- op : imag
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : imag
  backward : imag_grad

- op : increment
  args : (Tensor x, float value)
  output : Tensor(out)
  infer_meta :
    func : IncrementInferMeta
  kernel :
    func : increment
  inplace : (x -> out)

- op : index_add
  args : (Tensor x, Tensor index,  Tensor add_value, int axis)
  output : Tensor(out)
  infer_meta :
    func : IndexAddInferMeta
  kernel :
    func : index_add
    data_type : x
  inplace : (x -> out)
  backward : index_add_grad

- op : index_sample
  args : (Tensor x, Tensor index)
  output : Tensor
  infer_meta :
    func : IndexSampleInferMeta
  kernel :
    func : index_sample
    data_type : x
  backward : index_sample_grad

- op : index_select
  args : (Tensor x, Tensor index,  int dim)
  output : Tensor(out)
  infer_meta :
    func : IndexSelectInferMeta
  kernel :
    func : index_select
    data_type : x
  backward : index_select_grad

- op : instance_norm
  args : (Tensor x, Tensor scale, Tensor bias, float epsilon)
  output : Tensor(y), Tensor(saved_mean), Tensor(saved_variance)
  infer_meta :
    func : InstanceNormInferMeta
  kernel :
    func : instance_norm
    data_type : x
  optional : scale, bias
  intermediate : saved_mean, saved_variance
  backward : instance_norm_grad

- op : inverse
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : InverseInferMeta
  kernel :
    func : inverse
  backward : inverse_grad

- op : is_empty
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : IsEmptyInferMeta
  kernel :
    func : is_empty

- op : isclose
  args : (Tensor x, Tensor y, Scalar rtol, Scalar atol,  bool equal_nan)
  output : Tensor(out)
  infer_meta :
    func : ValueCompareInferMeta
    param: [x, y]
  kernel :
    func : isclose

- op : isfinite
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : IsfiniteInferMeta
  kernel :
    func : isfinite {dense -> dense},
           infinite_sr {selected_rows -> selected_rows}

- op : isinf
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : IsfiniteInferMeta
  kernel :
    func : isinf {dense -> dense},
           isinf_sr {selected_rows -> selected_rows}

- op : isnan
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : IsfiniteInferMeta
  kernel :
    func : isnan {dense -> dense},
           isnan_sr {selected_rows -> selected_rows}

- op : kldiv_loss
  args : (Tensor x, Tensor label, str reduction)
  output : Tensor(out)
  infer_meta :
    func : KLDivInferMeta
  kernel :
    func : kldiv_loss
    data_type : x
  backward : kldiv_loss_grad

- op : kron
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : KronInferMeta
  kernel :
    func : kron
  backward : kron_grad

- op : kthvalue
  args : (Tensor x, int k, int axis, bool keepdim)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : KthvalueInferMeta
  kernel :
    func : kthvalue
  backward : kthvalue_grad

- op : label_smooth
  args : (Tensor label, Tensor prior_dist, float epsilon)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [label]
  kernel :
    func : label_smooth
    data_type : label
  optional : prior_dist
  backward : label_smooth_grad

- op : lamb_
  args : (Tensor param, Tensor grad, Tensor learning_rate, Tensor moment1, Tensor moment2, Tensor beta1_pow, Tensor beta2_pow, Tensor master_param, Tensor skip_update, float weight_decay, float beta1, float beta2, float epsilon, bool multi_precision)
  output : Tensor(param_out), Tensor(moment1_out), Tensor(moment2_out), Tensor(beta1_pow_out), Tensor(beta2_pow_out), Tensor(master_param_outs)
  infer_meta :
    func : LambInferMeta
  kernel :
    func : lamb {dense, dense, dense, dense, dense, dense, dense, dense, dense -> dense, dense, dense, dense, dense, dense},
           lamb_sr {dense, selected_rows, dense, dense, dense, dense, dense, dense, dense -> dense, dense, dense, dense, dense, dense}
    data_type : param
  optional : master_param, skip_update
  inplace : (param -> param_out), (moment1 -> moment1_out), (moment2 -> moment2_out), (beta1_pow -> beta1_pow_out), (beta2_pow -> beta2_pow_out), (master_param -> master_param_outs)

- op : layer_norm
  args : (Tensor x, Tensor scale, Tensor bias, float epsilon, int begin_norm_axis, bool is_test)
  output : Tensor(out), Tensor(mean), Tensor(variance)
  infer_meta :
    func : LayerNormInferMeta
  kernel :
    func : layer_norm
    data_type : x
  backward : layer_norm_grad
  optional : scale, bias

- op : leaky_relu
  args : (Tensor x, float alpha)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : leaky_relu
  backward : leaky_relu_grad

- op : lerp
  args : (Tensor x, Tensor y, Tensor weight)
  output : Tensor(out)
  infer_meta :
    func : LerpInferMeta
  kernel :
    func : lerp
  inplace : (x -> out)
  backward : lerp_grad

- op : less_equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor(out)
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : less_equal

- op : less_than
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor(out)
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : less_than

- op : linear_interp
  args : (Tensor x, Tensor out_size, Tensor[] size_tensor, Tensor scale_tensor, str data_layout, int out_d, int out_h, int out_w, float[] scale, str interp_method, bool align_corners, int align_mode)
  output : Tensor(output)
  infer_meta :
    func : InterpolateInferMeta
  optional: out_size, size_tensor, scale_tensor
  kernel :
    func : linear_interp
    data_type : x
  backward : linear_interp_grad

- op : linspace
  args : (Tensor start, Tensor stop, Tensor number, DataType dtype, Place place)
  output : Tensor(out)
  infer_meta :
    func : LinspaceInferMeta
    param: [start, stop, number, dtype]
  kernel :
    func : linspace
    param: [start, stop, number, dtype]
    data_type : dtype
    backend : place

- op : log
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log
  backward: log_grad

- op : log10
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log10
  backward: log10_grad

- op : log1p
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log1p
  backward: log1p_grad

- op : log2
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : log2
  backward: log2_grad

- op : log_loss
  args : (Tensor input, Tensor label, float epsilon)
  output : Tensor
  infer_meta :
    func : LogLossInferMeta
  kernel :
    func : log_loss
  backward : log_loss_grad

- op : log_softmax
  args : (Tensor x,  int axis)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMetaCheckAxis
  kernel :
    func : log_softmax
  backward : log_softmax_grad

- op : logcumsumexp
  args : (Tensor x, int axis, bool flatten, bool exclusive, bool reverse)
  output : Tensor(out)
  infer_meta :
    func : CumInferMeta
  kernel :
    func : logcumsumexp
  backward : logcumsumexp_grad

- op : logical_and
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : logical_and

- op : logical_not
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : logical_not

- op : logical_or
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : logical_or

- op : logical_xor
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : logical_xor

- op : logit
  args : (Tensor x, float eps = 1e-6f)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : logit
  backward : logit_grad

- op : logsigmoid
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : logsigmoid
  backward : logsigmoid_grad

- op : logsumexp
  args : (Tensor x, int64_t[] axis,  bool keepdim,  bool reduce_all)
  output : Tensor(out)
  infer_meta :
    func : LogsumexpInferMeta
  kernel :
    func : logsumexp
  backward : logsumexp_grad

- op : lstsq
  args : (Tensor x, Tensor y, Scalar rcond, str driver)
  output : Tensor(solution), Tensor(residuals), Tensor(rank), Tensor(singular_values)
  infer_meta :
    func : LstsqInferMeta
    dtype : x
  kernel :
    func : lstsq

- op : lu
  args : (Tensor x, bool pivot)
  output : Tensor(out), Tensor(pivots), Tensor(infos)
  infer_meta :
    func : LUInferMeta
  kernel :
    func : lu
  backward : lu_grad

- op : lu_unpack
  args : (Tensor x, Tensor pivots, bool unpack_ludata, bool unpack_pivots)
  output : Tensor(pmat), Tensor(l), Tensor(u)
  infer_meta :
    func : LUUnpackInferMeta
  kernel :
    func : lu_unpack
    data_type : x
  backward : lu_unpack_grad

- op : margin_cross_entropy
  args : (Tensor logits, Tensor label, bool return_softmax, int ring_id, int rank, int nranks, float margin1, float margin2, float margin3, float scale)
  output : Tensor(softmax), Tensor(loss)
  infer_meta :
    func : MarginCrossEntropyInferMeta
  kernel :
    func : margin_cross_entropy
    data_type : logits
  backward : margin_cross_entropy_grad

- op : masked_select
  args : (Tensor x, Tensor mask)
  output : Tensor
  infer_meta :
    func : MaskedSelectInferMeta
  kernel :
    func : masked_select
    data_type : x
  backward : masked_select_grad

- op : matmul
  args : (Tensor x, Tensor y, bool transpose_x = false, bool transpose_y = false)
  output : Tensor
  infer_meta :
    func : MatmulInferMeta
  kernel :
    func : matmul
  backward : matmul_grad

- op : matrix_nms
  args : (Tensor bboxes, Tensor scores, float score_threshold, int nms_top_k, int keep_top_k, float post_threshold=0., bool use_gaussian = false, float gaussian_sigma = 2.0, int background_label = 0, bool normalized = true)
  output : Tensor(out), Tensor(index), Tensor(roisnum)
  infer_meta :
    func : MatrixNMSInferMeta
  kernel :
    func : matrix_nms

- op : matrix_power
  args : (Tensor x, int n)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : matrix_power
  backward : matrix_power_grad

- op : matrix_rank
  args : (Tensor x, float tol, bool use_default_tol=true, bool hermitian=false)
  output : Tensor(out)
  infer_meta :
    func : MatrixRankInferMeta
    param : [x, use_default_tol, hermitian]
  kernel :
    func : matrix_rank

- op : matrix_rank_tol
  args : (Tensor x, Tensor atol_tensor, bool use_default_tol=true, bool hermitian=false)
  output : Tensor(out)
  infer_meta :
    func : MatrixRankTolInferMeta
  kernel :
    func : matrix_rank_tol

- op : max
  args : (Tensor x, IntArray dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceIntArrayAxisInferMeta
  kernel :
    func : max
  backward : max_grad

- op : max_pool2d_with_index
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive)
  output : Tensor(out), Tensor(mask)
  infer_meta :
    func : MaxPoolWithIndexInferMeta
  kernel :
    func : max_pool2d_with_index
  backward : max_pool2d_with_index_grad

- op : max_pool3d_with_index
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool global_pooling, bool adaptive)
  output : Tensor(out), Tensor(mask)
  infer_meta :
    func : MaxPoolWithIndexInferMeta
  kernel :
    func : max_pool3d_with_index
  backward : max_pool3d_with_index_grad

- op : maximum
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : maximum
  backward : maximum_grad

- op : maxout
  args : (Tensor x, int groups, int axis)
  output : Tensor(out)
  infer_meta :
    func : MaxOutInferMeta
  kernel :
    func : maxout
  backward : maxout_grad

- op : mean
  args : (Tensor x, IntArray dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceIntArrayAxisInferMeta
  kernel :
    func : mean
  backward : mean_grad

- op : mean_all
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : MeanAllInferMeta
  kernel :
    func : mean_all
  backward : mean_all_grad

- op : merged_adam_
  args : (Tensor[] param, Tensor[] grad, Tensor[] learning_rate, Tensor[] moment1, Tensor[] moment2, Tensor[] beta1_pow, Tensor[] beta2_pow, Tensor[] master_param, Scalar beta1, Scalar beta2, Scalar epsilon, bool multi_precision, bool use_global_beta_pow)
  output : Tensor[](param_out){param.size()}, Tensor[](moment1_out){param.size()}, Tensor[](moment2_out){param.size()}, Tensor[](beta1_pow_out){param.size()}, Tensor[](beta2_pow_out){param.size()}, Tensor[](master_param_out){param.size()}
  infer_meta :
    func : MergedAdamInferMeta
  optional: master_param
  kernel :
    func : merged_adam
    data_type : param
  inplace : (param -> param_out), (moment1 -> moment1_out), (moment2 -> moment2_out), (beta1_pow -> beta1_pow_out), (beta2_pow -> beta2_pow_out), (master_param -> master_param_out)

- op : merged_momentum_
  args : (Tensor[] param, Tensor[] grad, Tensor[] velocity, Tensor[] learning_rate, Tensor[] master_param, float mu, bool use_nesterov = false, str[] regularization_method = {}, float[] regularization_coeff = {}, bool multi_precision = false, float rescale_grad = 1.0f)
  output : Tensor[](param_out){param.size()}, Tensor[](velocity_out){param.size()}, Tensor[](master_param_out){param.size()}
  infer_meta :
    func : MergedMomentumInferMeta
  optional: master_param
  kernel :
    func : merged_momentum
    data_type : param
  inplace : (param -> param_out), (velocity -> velocity_out), (master_param -> master_param_out)

- op : meshgrid
  args : (Tensor[] inputs)
  output : Tensor[]{inputs.size()}
  infer_meta :
    func : MeshgridInferMeta
  kernel :
    func : meshgrid
  backward : meshgrid_grad

- op : min
  args : (Tensor x, IntArray dims={}, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : ReduceIntArrayAxisInferMeta
  kernel :
    func : min
  backward : min_grad

- op : minimum
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : minimum
  backward : minimum_grad

- op : mish
  args : (Tensor x, float lambda)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : mish
  backward : mish_grad

- op : mode
  args : (Tensor x,  int axis,  bool keepdim)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : ModeInferMeta
  kernel :
    func : mode
  backward : mode_grad

- op : momentum_
  args : (Tensor param, Tensor grad, Tensor velocity, Tensor learning_rate, Tensor master_param, float mu, bool use_nesterov = false, str regularization_method = "", float regularization_coeff = 0.0, bool multi_precision = false, float rescale_grad = 1.0f)
  output : Tensor(param_out), Tensor(velocity_out), Tensor(master_param_out)
  infer_meta:
    func : MomentumInferMeta
  kernel :
    func : momentum
    data_type : param
  optional : master_param
  inplace : (param -> param_out), (velocity -> velocity_out), (master_param -> master_param_out)

- op : multi_dot
  args : (Tensor[] x)
  output : Tensor
  infer_meta :
    func : MultiDotInferMeta
  kernel :
    func : multi_dot
  backward : multi_dot_grad

- op : multiclass_nms3
  args : (Tensor bboxes, Tensor scores, Tensor rois_num, float score_threshold, int nms_top_k, int keep_top_k, float nms_threshold=0.3, bool normalized=true, float nms_eta=1.0, int background_label=0)
  output : Tensor(out), Tensor(index), Tensor(nms_rois_num)
  infer_meta :
    func : MultiClassNMSInferMeta
  kernel :
    func : multiclass_nms3
  optional : rois_num

- op : multinomial
  args : (Tensor x, Scalar num_samples, bool replacement)
  output : Tensor(out)
  infer_meta :
    func : MultinomialInferMeta
  kernel :
    func : multinomial

- op : multiplex
  args : (Tensor[] ins, Tensor ids)
  output : Tensor
  infer_meta :
    func : MultiplexInferMeta
  kernel :
    func : multiplex
    data_type : ins
  backward : multiplex_grad

- op : multiply
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : multiply {dense, dense -> dense},
           multiply_sr {selected_rows, dense -> selected_rows}
  backward : multiply_grad

- op : nearest_interp
  args : (Tensor x, Tensor out_size, Tensor[] size_tensor, Tensor scale_tensor, str data_layout, int out_d, int out_h, int out_w, float[] scale, str interp_method, bool align_corners, int align_mode)
  output : Tensor(output)
  infer_meta :
    func : InterpolateInferMeta
  optional: out_size, size_tensor, scale_tensor
  kernel :
    func : nearest_interp
    data_type : x
  backward : nearest_interp_grad

- op : nll_loss
  args : (Tensor input, Tensor label, Tensor weight, int64_t ignore_index, str reduction)
  output : Tensor(out), Tensor(total_weight)
  infer_meta :
    func : NllLossRawInferMeta
  kernel :
    func : nll_loss
    data_type : input
  optional : weight
  backward : nll_loss_grad

- op : nms
  args : (Tensor x, float threshold)
  output : Tensor(out)
  infer_meta :
    func : NMSInferMeta
  kernel :
    func : nms
    data_type : x

- op : norm
  args : (Tensor x, int axis, float epsilon, bool is_test)
  output : Tensor(out), Tensor(norm)
  infer_meta :
    func : NormInferMeta
  kernel :
    func : norm
  backward : norm_grad

- op : not_equal
  args : (Tensor x, Tensor y, int axis = -1)
  output : Tensor(out)
  infer_meta :
    func : CompareInferMeta
  kernel :
    func : not_equal

- op : one_hot
  args : (Tensor x, Scalar(int) num_classes)
  output : Tensor(out)
  infer_meta :
    func : OneHotInferMeta
  kernel :
    func : one_hot

- op : ones
  args : (IntArray shape, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output : Tensor(out)
  invoke : full(shape, 1, dtype, place)

- op : ones_like
  args : (Tensor x, DataType dtype=DataType::UNDEFINED, Place place={})
  output : Tensor(out)
  invoke : full_like(x, 1, dtype, place)

- op : p_norm
  args : (Tensor x,  float porder,  int axis,  float epsilon,  bool keepdim,  bool asvector=false)
  output : Tensor(out)
  infer_meta :
    func : PNormInferMeta
  kernel :
    func : p_norm
  backward : p_norm_grad

- op : pad
  args : (Tensor x, int[] paddings, Scalar pad_value)
  output : Tensor
  infer_meta :
    func : PadInferMeta
  kernel :
    func : pad
  backward : pad_grad

- op : pad3d
  args : (Tensor x, IntArray paddings, str mode,  float pad_value, str data_format)
  output : Tensor(out)
  infer_meta :
    func : Pad3dInferMeta
  kernel :
    func : pad3d
  backward : pad3d_grad

- op : pixel_shuffle
  args : (Tensor x, int upscale_factor, str data_format)
  output : Tensor
  infer_meta :
    func : PixelShuffleInferMeta
  kernel :
    func : pixel_shuffle
  backward : pixel_shuffle_grad

- op : pool2d
  args : (Tensor x, IntArray kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm, bool use_gpudnn)
  output : Tensor(out)
  infer_meta :
    func : Pool2DInferMeta
    param : [x, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
  kernel :
    func : pool2d
    param : [x, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
    use_gpudnn : use_gpudnn
  backward : pool2d_grad

- op : pool3d
  args : (Tensor x, int[] kernel_size, int[] strides, int[] paddings, bool ceil_mode, bool exclusive, str data_format, str pooling_type, bool global_pooling, bool adaptive, str padding_algorithm, bool use_gpudnn)
  output : Tensor(out)
  infer_meta :
    func : PoolInferMeta
    param : [x, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
  kernel :
    func : pool3d
    param : [x, kernel_size, strides, paddings, ceil_mode, exclusive, data_format, pooling_type, global_pooling, adaptive, padding_algorithm]
    use_gpudnn : use_gpudnn
  backward : pool3d_grad

- op : pow
  args : (Tensor x, Scalar s)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pow
  backward : pow_grad

- op : prelu
  args : (Tensor x, Tensor alpha, str data_format, str mode)
  output : Tensor(out)
  infer_meta :
    func : PReluInferMeta
  kernel :
    func : prelu
  backward : prelu_grad

- op : prior_box
  args : (Tensor input, Tensor image, float[] min_sizes, float[] aspect_ratios, float[] variances, float[] max_sizes = {}, bool flip=true, bool clip=true, float step_w=0.0, float step_h=0.0, float offset=0.5, bool min_max_aspect_ratios_order=false)
  output : Tensor(out), Tensor(var)
  infer_meta :
    func : PriorBoxInferMeta
  kernel :
    func : prior_box

- op : psroi_pool
  args : (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, int output_channels, float spatial_scale)
  output : Tensor
  infer_meta :
    func : PsroiPoolInferMeta
  kernel :
    func : psroi_pool
    data_type : x
  optional : boxes_num
  backward : psroi_pool_grad

- op : put_along_axis
  args : (Tensor x, Tensor index, Tensor value, int axis, str reduce)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : put_along_axis
    data_type : x
  inplace : (x -> out)
  backward : put_along_axis_grad

- op : qr
  args : (Tensor x, str mode)
  output : Tensor(q), Tensor(r)
  infer_meta :
    func : QrInferMeta
  kernel :
    func : qr
  backward : qr_grad

- op : randint
  args : (int low, int high, IntArray shape, DataType dtype=DataType::INT64, Place place={})
  output : Tensor(out)
  infer_meta :
    func : RandintInferMeta
    param : [low, high, shape, dtype]
  kernel :
    func : randint
    param : [low, high, shape, dtype]
    data_type : dtype
    backend : place

- op : randperm
  args : (int n, DataType dtype, Place place={})
  output : Tensor(out)
  infer_meta :
    func : RandpermInferMeta
    param : [n, dtype]
  kernel :
    func : randperm
    param : [n, dtype]
    data_type : dtype
    backend : place

- op : real
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : RealAndImagInferMeta
  kernel :
    func : real
  backward : real_grad

- op : reciprocal
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : reciprocal
  inplace : (x -> out)
  backward : reciprocal_grad

- op : reduce_prod
  args : (Tensor x, IntArray dims, bool keep_dim, bool reduce_all)
  output : Tensor
  infer_meta :
    func : ReduceIntArrayAxisInferMetaBase
  kernel :
    func : prod_raw
  backward : reduce_prod_grad

- op : relu
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : relu
  inplace : (x -> out)
  backward : relu_grad

- op : relu6
  args : (Tensor x, float threshold)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : relu6
  backward : relu6_grad

- op : remainder
  args : (Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : remainder
  inplace : (x -> out)

- op : renorm
  args : (Tensor x, float p, int axis, float max_norm)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : renorm
  backward : renorm_grad

- op : repeat_interleave
  args : (Tensor x, int repeats, int dim)
  output : Tensor(out)
  infer_meta :
    func : RepeatInterleaveInferMeta
    param : [x,repeats, dim]
  kernel :
    func : repeat_interleave
  backward: repeat_interleave_grad

- op : repeat_interleave_with_tensor_index
  args : (Tensor x, Tensor repeats, int dim)
  output : Tensor(out)
  infer_meta :
    func : RepeatInterleaveWithTensorIndexInferMeta
    param : [x,repeats, dim]
  kernel :
    func : repeat_interleave_with_tensor_index
    data_type : x
  backward: repeat_interleave_with_tensor_index_grad

- op : reshape
  args : (Tensor x, IntArray shape)
  output : Tensor(out), Tensor(xshape)
  infer_meta :
    func : ReshapeWithXShapeInferMeta
  kernel :
    func : reshape_with_xshape
  inplace : (x -> out)
  view: (x -> out)
  intermediate : xshape
  backward: reshape_grad

- op : reverse
  args : (Tensor x, IntArray axis)
  output : Tensor
  infer_meta :
    func : ReverseInferMeta
  kernel :
    func : reverse
  backward : reverse_grad

- op : rmsprop_
  args : (Tensor param, Tensor mean_square, Tensor grad, Tensor moment, Tensor learning_rate, Tensor mean_grad, float epsilon, float decay, float momentum, bool centered)
  output : Tensor(param_out), Tensor(moment_out), Tensor(mean_square_out), Tensor(mean_grad_out)
  infer_meta :
    func : RmspropInferMeta
  kernel :
    func : rmsprop {dense, dense, dense, dense, dense, dense -> dense, dense, dense, dense}
           rmsprop_dense_param_sparse_grad {dense, dense, selected_rows, dense, dense, dense -> dense, dense, dense, dense}
    optional : mean_grad
  inplace : (param -> param_out), (moment -> moment_out), (mean_square -> mean_square_out), (mean_grad -> mean_grad_out)

- op : roi_align
  args : (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, float spatial_scale, int sampling_ratio, bool aligned)
  output : Tensor
  infer_meta :
    func : RoiAlignInferMeta
  kernel :
    func : roi_align
    data_type : x
  optional : boxes_num
  backward : roi_align_grad

- op : roi_pool
  args : (Tensor x, Tensor boxes, Tensor boxes_num, int pooled_height, int pooled_width, float spatial_scale)
  output : Tensor(out), Tensor(arg_max)
  infer_meta :
    func : RoiPoolInferMeta
  kernel :
    func : roi_pool
    data_type : x
  optional : boxes_num
  intermediate : arg_max
  backward : roi_pool_grad

- op : roll
  args : (Tensor x, IntArray shifts, int64_t[] axis)
  output : Tensor(out)
  infer_meta :
    func : RollInferMeta
  kernel :
    func : roll
  backward : roll_grad

- op : round
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : round
  inplace : (x -> out)
  backward : round_grad

- op : rsqrt
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : rsqrt
  inplace : (x -> out)
  backward : rsqrt_grad

- op : scale
  args : (Tensor x, Scalar scale, float bias, bool bias_after_scale)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : scale {dense -> dense},
           scale_sr {selected_rows -> selected_rows}
  inplace : (x -> out)
  backward : scale_grad

- op : scatter
  args : (Tensor x, Tensor index, Tensor updates, bool overwrite)
  output : Tensor(out)
  infer_meta :
    func : ScatterInferMeta
    dtype : x
  kernel :
    func : scatter
  inplace : (x -> out)
  backward : scatter_grad

- op : scatter_nd_add
  args : (Tensor x, Tensor index, Tensor updates)
  output : Tensor
  infer_meta :
    func : ScatterNdAddInferMeta
    dtype : x
  kernel :
    func : scatter_nd_add
  backward : scatter_nd_add_grad

- op : searchsorted
  args : (Tensor sorted_sequence, Tensor value, bool out_int32, bool right)
  output : Tensor(out)
  infer_meta :
    func : SearchsortedInferMeta
  kernel :
    func : searchsorted
    data_type : sorted_sequence

- op : segment_pool
  args : (Tensor x, Tensor segment_ids, str pooltype)
  output : Tensor(out), Tensor(summed_ids)
  infer_meta :
    func : SegmentPoolInferMeta
  kernel :
    func : segment_pool
    data_type : x
  backward : segment_pool_grad

- op : selu
  args : (Tensor x, float scale, float alpha)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : selu
  backward : selu_grad

- op : sgd_
  args : (Tensor param, Tensor learning_rate, Tensor grad, Tensor master_param, bool multi_precision)
  output : Tensor(param_out), Tensor(master_param_out)
  infer_meta :
    func : SgdInferMeta
  kernel :
    func : sgd {dense, dense, dense, dense -> dense, dense},
           sgd_dense_param_sparse_grad {dense, dense, selected_rows, dense -> dense, dense},
           sgd_sparse_param_sparse_grad {selected_rows, dense, selected_rows, selected_rows -> selected_rows, selected_rows}
    data_type : param
  data_transform :
    support_trans_dtype : learning_rate
  optional : master_param
  inplace : (param -> param_out), (master_param -> master_param_out)

- op : shape
  args : (Tensor input)
  output : Tensor(out)
  infer_meta :
    func : ShapeInferMeta
  kernel :
    func : shape {dense -> dense},
           shape_sr {selected_rows -> selected_rows}
  data_transform:
    skip_transform : input

- op : shard_index
  args : (Tensor in, int index_num, int nshards, int shard_id, int ignore_value)
  output : Tensor(out)
  infer_meta :
    func : ShardIndexInferMeta
  kernel :
    func : shard_index

- op : sigmoid
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sigmoid
  backward : sigmoid_grad

- op : sigmoid_cross_entropy_with_logits
  args : (Tensor x, Tensor label, bool normalize, int ignore_index)
  output : Tensor
  infer_meta :
    func : SigmoidCrossEntropyWithLogitsInferMeta
  kernel :
    func : sigmoid_cross_entropy_with_logits
  backward : sigmoid_cross_entropy_with_logits_grad

- op : sign
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sign
  backward : sign_grad

- op : silu
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : silu
  backward : silu_grad

- op : sin
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sin
  backward : sin_grad

- op : sinh
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sinh
  backward : sinh_grad

- op : size
  args : (Tensor x)
  output : Tensor(size)
  infer_meta :
    func : SizeInferMeta
  kernel :
    func : size
  data_transform:
    skip_transform : x

- op : slice
  args : (Tensor input, int64_t[] axes, IntArray starts, IntArray ends, int64_t[] infer_flags, int64_t[] decrease_axis)
  output : Tensor
  infer_meta :
    func : SliceRawInferMeta
  kernel :
    func : slice
  backward : slice_grad

- op : slogdet
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : slogdeterminant
  backward : slogdet_grad

- op : soft_shrink
  args : (Tensor x, float lambda)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : soft_shrink
  backward : soft_shrink_grad

- op : softmax
  args : (Tensor x, int axis)
  output : Tensor(out)
  infer_meta :
    func : SoftmaxInferMeta
  kernel :
    func : softmax
    use_gpudnn : true
  inplace : (x -> out)
  backward : softmax_grad

- op : softplus
  args : (Tensor x, float beta, float threshold)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : softplus
  backward : softplus_grad

- op : softsign
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : softsign
  backward : softsign_grad

- op : spectral_norm
  args : (Tensor weight, Tensor u, Tensor v, int dim, int power_iters, float eps)
  output : Tensor
  infer_meta :
    func : SpectralNormInferMeta
  kernel :
    func : spectral_norm
    data_type : weight
  backward : spectral_norm_grad

- op : split
  args : (Tensor x, IntArray sections, Scalar(int) axis)
  output : Tensor[]{sections.size()}
  infer_meta :
    func : SplitInferMeta
  kernel :
    func : split
  backward : split_grad

- op : split_with_num
  args : (Tensor x, int num, Scalar(int) axis)
  output : Tensor[]{num}
  infer_meta :
    func : SplitWithNumInferMeta
  kernel :
    func : split_with_num
  backward : split_with_num_grad

- op : sqrt
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : sqrt
  inplace : (x -> out)
  backward : sqrt_grad

- op : square
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : square
  backward : square_grad

- op : squared_l2_norm
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : SquaredL2NormInferMeta
  kernel :
    func : squared_l2_norm
  backward : squared_l2_norm_grad

- op : squeeze
  args : (Tensor x, IntArray axes)
  output : Tensor(out), Tensor(xshape)
  infer_meta :
    func : SqueezeWithXShapeInferMeta
  kernel :
    func : squeeze_with_xshape
  inplace : (x -> out)
  view: (x -> out)
  intermediate : xshape
  backward : squeeze_grad

- op : stack
  args : (Tensor[] x, int axis)
  output : Tensor
  infer_meta :
    func : StackInferMeta
  kernel :
    func : stack
  backward : stack_grad

- op : strided_slice
  args : (Tensor x, int[] axes, IntArray starts, IntArray ends, IntArray strides)
  output : Tensor
  infer_meta :
    func : StridedSliceInferMeta
  kernel :
    func : strided_slice
  backward : strided_slice_grad

- op : subtract
  args : (Tensor x, Tensor y)
  output : Tensor(out)
  infer_meta :
    func : ElementwiseInferMeta
  kernel :
    func : subtract
  inplace : (x -> out)
  backward : subtract_grad

- op : sum
  args : (Tensor x, IntArray dims={}, DataType out_dtype=DataType::UNDEFINED, bool keep_dim=false)
  output : Tensor(out)
  infer_meta :
    func : SumInferMeta
  kernel :
    func : sum
    data_type : x
  backward : sum_grad

- op : svd
  args : (Tensor x, bool full_metrices)
  output : Tensor(u), Tensor(s), Tensor(vh)
  infer_meta :
    func : SvdInferMeta
  kernel :
    func : svd
  backward : svd_grad

# The python API paddle.nn.functional.swish has no `bete` argument, it may be removed later
- op : swish
  args : (Tensor x, float beta=1.0)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : swish
  backward : swish_grad

- op : sync_batch_norm_
  args : (Tensor x, Tensor scale, Tensor bias, Tensor mean, Tensor variance, float momentum, float epsilon, str data_layout, bool is_test, bool use_global_stats, bool trainable_statistics, bool fuse_with_relu)
  output : Tensor(out), Tensor(mean_out), Tensor(variance_out), Tensor(saved_mean), Tensor(saved_variance), Tensor(reserve_space)
  infer_meta :
    func : BatchNormInferMeta
  kernel :
    func : sync_batch_norm
    data_type : x
  backward : sync_batch_norm_grad
  inplace : (mean -> mean_out), (variance -> variance_out)

- op : take_along_axis
  args : (Tensor x, Tensor index, int axis)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [index]
  kernel :
    func : take_along_axis
    data_type : x
  backward : take_along_axis_grad

- op : tan
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tan
  backward : tan_grad

- op : tanh
  args : (Tensor x)
  output : Tensor(out)
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tanh
  inplace : (x -> out)
  backward : tanh_grad

- op : tanh_shrink
  args : (Tensor x)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
  kernel :
    func : tanh_shrink
  backward : tanh_shrink_grad

- op : temporal_shift
  args : (Tensor x, int seg_num, float shift_ratio, str data_format_str)
  output : Tensor
  infer_meta :
    func : TemporalShiftInferMeta
  kernel :
    func : temporal_shift
  backward : temporal_shift_grad

- op : thresholded_relu
  args : (Tensor x, float threshold)
  output : Tensor
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : thresholded_relu
  backward : thresholded_relu_grad

- op : tile
  args : (Tensor x, IntArray repeat_times)
  output : Tensor
  infer_meta :
    func : TileInferMeta
  kernel :
    func : tile
  backward : tile_grad

- op : top_k
  args : (Tensor x, Scalar k, int axis = -1, bool largest = true, bool sorted = true)
  output : Tensor(out), Tensor(indices)
  infer_meta :
    func : TopKInferMeta
  kernel :
    func : top_k
  backward : top_k_grad

- op : transpose
  args : (Tensor x, int[] axis)
  output : Tensor
  infer_meta :
    func : TransposeInferMeta
  kernel :
    func : transpose
  backward : transpose_grad

- op : triangular_solve
  args : (Tensor x, Tensor y, bool upper, bool transpose, bool unitriangular)
  output : Tensor
  infer_meta :
    func : TriangularSolveInferMeta
  kernel :
    func : triangular_solve
  backward : triangular_solve_grad

- op : tril_indices
  args : (int rows, int cols, int offset, DataType dtype, Place place={})
  output : Tensor(out)
  infer_meta :
    func : TrilIndicesInferMeta
    param : [rows, cols, offset, dtype]
  kernel :
    func : tril_indices
    param : [rows, cols, offset, dtype]
    data_type : dtype
    backend : place

- op : tril_triu
  args : (Tensor x,  int diagonal,  bool lower)
  output : Tensor(out)
  infer_meta :
    func : TrilTriuInferMeta
  kernel :
    func : tril_triu
  backward : tril_triu_grad

- op : trilinear_interp
  args : (Tensor x, Tensor out_size, Tensor[] size_tensor, Tensor scale_tensor, str data_layout, int out_d, int out_h, int out_w, float[] scale, str interp_method, bool align_corners, int align_mode)
  output : Tensor(output)
  infer_meta :
    func : InterpolateInferMeta
  optional: out_size, size_tensor, scale_tensor
  kernel :
    func : trilinear_interp
    data_type : x
  backward : trilinear_interp_grad

- op : triu_indices
  args : (int row, int col, int offset, DataType dtype, Place place={})
  output : Tensor(out)
  infer_meta :
    func : TriuIndicesInferMeta
    param : [row, col, offset, dtype]
  kernel :
    func : triu_indices
    param : [row, col, offset, dtype]
    data_type : dtype
    backend : place

# python API: paddle.nn.initializer.TruncatedNormal
- op : truncated_gaussian_random
  args : (int[] shape, float mean, float std, int seed, DataType dtype=DataType::FLOAT32, Place place={})
  output : Tensor(out)
  infer_meta :
    func : TruncatedGaussianRandomInferMeta
    param : [shape, mean, std, seed, dtype]
  kernel :
    func : truncated_gaussian_random
    param : [shape, mean, std, seed, dtype]
    backend : place
    data_type : dtype

- op : update_loss_scaling_
  args : (Tensor[] x, Tensor found_infinite, Tensor prev_loss_scaling, Tensor in_good_steps, Tensor in_bad_steps, int incr_every_n_steps, int decr_every_n_nan_or_inf, float incr_ratio, float decr_ratio, Scalar stop_update)
  output : Tensor[](out){x.size()}, Tensor(loss_scaling), Tensor(out_good_steps), Tensor(out_bad_steps)
  infer_meta :
    func : UpdateLossScalingInferMeta
    param : [x, found_infinite, prev_loss_scaling, in_good_steps, in_bad_steps]
  kernel :
    func : update_loss_scaling
    data_type : x
  inplace : (x -> out), (prev_loss_scaling -> loss_scaling), (in_good_steps -> out_good_steps), (in_bad_steps -> out_bad_steps)

- op : unbind
  args : (Tensor input, int axis)
  output : Tensor[] {axis<0 ? input.dims()[input.dims().size()+axis]:input.dims()[axis]}
  infer_meta :
    func : UnbindInferMeta
  kernel :
    func : unbind
  backward : unbind_grad

- op : unfold
  args : (Tensor x, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations)
  output : Tensor
  infer_meta :
    func : UnfoldInferMeta
  kernel :
    func : unfold
  backward : unfold_grad

- op : uniform_random
  args : (IntArray shape,  DataType dtype,  Scalar min,  Scalar max,  int seed, Place place={})
  output : Tensor(out)
  infer_meta :
    func : UniformRandomInferMeta
    param: [shape, dtype]
  kernel :
    func : uniform_random
    param: [shape, dtype, min, max, seed]
    data_type : dtype
    backend : place

# The `axis` argument of Python API paddle.unique is not vector
- op : unique
  args : (Tensor x, bool return_index, bool return_inverse, bool return_counts, int[] axis, DataType dtype=DataType::INT64)
  output : Tensor(out), Tensor(indices), Tensor(inverse), Tensor(counts)
  infer_meta :
    func : UniqueInferMeta
  kernel :
    func : unique
    data_type : x

- op : unique_consecutive
  args : (Tensor x, bool return_inverse, bool return_counts, int[] axis, int dtype)
  output : Tensor(out), Tensor(index), Tensor(counts)
  infer_meta :
      func : UniqueConsecutiveInferMeta
  kernel :
    func : unique_consecutive
    data_type : x

- op : unsqueeze
  args : (Tensor x, IntArray axis)
  output : Tensor(out), Tensor(xshape)
  infer_meta :
    func : UnsqueezeWithXShapeInferMeta
  kernel :
    func : unsqueeze_with_xshape
  inplace : (x -> out)
  view: (x -> out)
  intermediate : xshape
  backward : unsqueeze_grad

- op : unstack
  args : (Tensor x, int axis, int num)
  output : Tensor[]{num}
  infer_meta :
    func : UnStackInferMeta
  kernel :
    func : unstack
  backward : unstack_grad

- op : viterbi_decode
  args : (Tensor input, Tensor transition, Tensor length, bool include_bos_eos_tag)
  output : Tensor(scores), Tensor(path)
  infer_meta :
    func : ViterbiDecodeInferMeta
  kernel :
    func : viterbi_decode
    data_type : input

- op : warpctc
  args : (Tensor logits, Tensor label, Tensor logits_length, Tensor labels_length, int blank, bool norm_by_times)
  output :  Tensor(loss), Tensor(warpctcgrad)
  infer_meta :
    func : WarpctcInferMeta
  kernel :
    func : warpctc
    data_type: logits
  optional: logits_length, labels_length
  intermediate: warpctcgrad
  backward : warpctc_grad

- op : where
  args : (Tensor condition, Tensor x, Tensor y)
  output : Tensor
  infer_meta :
    func : WhereInferMeta
  kernel :
    func : where
  backward : where_grad

- op : where_index
  args : (Tensor condition)
  output : Tensor(out)
  infer_meta :
    func : WhereIndexInferMeta
  kernel :
    func : where_index

- op : yolo_box
  args : (Tensor x, Tensor img_size, int[] anchors, int class_num, float conf_thresh, int downsample_ratio, bool clip_bbox, float scale_x_y=1.0, bool iou_aware=false, float iou_aware_factor=0.5)
  output : Tensor(boxes), Tensor(scores)
  infer_meta :
    func : YoloBoxInferMeta
  kernel :
    func : yolo_box
    data_type : x

- op : yolov3_loss
  args : (Tensor x, Tensor gt_box, Tensor gt_label, Tensor gt_score, int[] anchors, int[] anchor_mask, int class_num, float ignore_thresh, int downsample_ratio, bool use_label_smooth=true, float scale_x_y=1.0)
  output : Tensor(loss), Tensor(objectness_mask), Tensor(gt_match_mask)
  infer_meta :
    func : Yolov3LossInferMeta
  kernel :
    func : yolov3_loss
    data_type : x
  optional : gt_score
  backward : yolov3_loss_grad

- op : zeros
  args : (IntArray shape, DataType dtype=DataType::FLOAT32, Place place=CPUPlace())
  output : Tensor(out)
  invoke : full(shape, 0, dtype, place)

- op : zeros_like
  args : (Tensor x, DataType dtype=DataType::UNDEFINED, Place place = {})
  output : Tensor(out)
  invoke : full_like(x, 0, dtype, place)

- op: broadcast_tensors
  args: (Tensor[] x)
  output: Tensor[]{x.size()}
  infer_meta:
    func: BroadcastTensorsInferMeta
  kernel:
    func: broadcast_tensors
  backward: broadcast_tensors_grad

- op: dirichlet
  args: (Tensor alpha)
  output: Tensor(out)
  infer_meta:
    func: DirichletInferMeta
  kernel:
    func: dirichlet

- op: eig
  args: (Tensor x)
  output: Tensor(out_w), Tensor(out_v)
  infer_meta:
    func: EigInferMeta
  kernel:
    func: eig
  backward: eig_grad

- op: fold
  args: (Tensor x, int[] output_sizes, int[] kernel_sizes,  int[] strides, int[] paddings, int[] dilations)
  output: Tensor(out)
  infer_meta:
    func: FoldInferMeta
  kernel:
    func: fold
  backward: fold_grad

- op: overlap_add
  args: (Tensor x, int hop_length, int axis)
  output: Tensor
  infer_meta:
    func: OverlapAddInferMeta
  kernel:
    func: overlap_add
  backward: overlap_add_grad

- op: uniform_random_inplace
  args: (Tensor x, float min, float max, int seed, int diag_num, int diag_step, float diag_val)
  output: Tensor(out)
  infer_meta:
    func: UniformRandomInplaceInferMeta
  kernel:
    func: uniform_random_inplace
    data_type: x
  inplace: (x -> out)
  backward: uniform_random_inplace_grad

- op: unpool
  args: (Tensor x, Tensor indices, int[] ksize, int[] strides, int[] padding, IntArray output_size, str data_format)
  output: Tensor(out)
  infer_meta:
    func: UnpoolInferMeta
  kernel:
    func: unpool
    data_type: x
  backward: unpool_grad

- op: unpool3d
  args: (Tensor x, Tensor indices, int[] ksize, int[] strides, int[] padding, int[] output_size, str data_format)
  output: Tensor(out)
  infer_meta:
    func: Unpool3dInferMeta
  kernel:
    func: unpool3d
    data_type: x
  backward: unpool3d_grad

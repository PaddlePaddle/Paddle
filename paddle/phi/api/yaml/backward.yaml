- backward_op : acos_grad
  forward : acos (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : acos_grad
  inplace : (out_grad -> x_grad)

- backward_op : acosh_grad
  forward : acosh (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : acosh_grad
  inplace : (out_grad -> x_grad)

- backward_op : addmm_grad
  forward : addmm (Tensor input, Tensor x, Tensor y, float beta=1.0, float alpha=1.0) -> Tensor(out)
  args : (Tensor input, Tensor x, Tensor y, Tensor out_grad, float alpha, float beta)
  output : Tensor(input_grad), Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [input, x, y]
  kernel :
    func : addmm_grad

- backward_op : angle_grad
  forward : angle (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : angle_grad

- backward_op : argsort_grad
  forward : argsort (Tensor x, int axis, bool descending) -> Tensor(out), Tensor(indices)
  args : (Tensor indices, Tensor x, Tensor out_grad, int axis, bool descending)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : argsort_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : as_complex_grad
  forward : as_complex (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  invoke : as_real(out_grad)

- backward_op : as_real_grad
  forward : as_real (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  invoke : as_complex(out_grad)

- backward_op : asin_grad
  forward : asin (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : asin_grad
  inplace : (out_grad -> x_grad)

- backward_op : asinh_grad
  forward : asinh (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : asinh_grad
  inplace : (out_grad -> x_grad)

- backward_op : atan2_grad
  forward : atan2 (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : atan2_grad

- backward_op : atan_grad
  forward : atan (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : atan_grad
  inplace : (out_grad -> x_grad)

- backward_op : atanh_grad
  forward : atanh (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : atanh_grad
  inplace : (out_grad -> x_grad)

- backward_op : bmm_grad
  forward : bmm (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : BmmGradInferMeta
  kernel :
    func : bmm_grad
    data_type : out_grad

- backward_op : broadcast_tensors_grad
  forward : broadcast_tensors (Tensor[] input) -> Tensor[](out)
  args : (Tensor[] input, Tensor[] out_grad)
  output : Tensor[](input_grad)
  infer_meta :
    func : UnchangedMultiInferMeta
    param : [input]
  kernel :
    func : broadcast_tensors_grad
    param : [input, out_grad]
    data_type : out_grad
  no_need_buffer : input

- backward_op : ceil_grad
  forward : ceil(Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [out_grad]
  kernel :
    func : ceil_grad
  inplace : (out_grad -> x_grad)

- backward_op : celu_double_grad
  forward : celu_grad(Tensor x, Tensor grad_out, float alpha) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad, float alpha)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, x]
  kernel :
    func : celu_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : celu_grad
  forward : celu(Tensor x, float alpha) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float alpha)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : celu_grad
  backward : celu_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : cholesky_grad
  forward : cholesky (Tensor x, bool upper) -> Tensor(out)
  args : (Tensor out, Tensor out_grad, bool upper)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : cholesky_grad

- backward_op : cholesky_solve_grad
  forward : cholesky_solve (Tensor x, Tensor y, bool upper) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out, Tensor out_grad, bool upper)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : cholesky_solve_grad

- backward_op : clip_double_grad
  forward : clip_grad (Tensor x, Tensor grad_out, Scalar min = 0., Scalar max = 0.) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_x_grad, Scalar min = 0., Scalar max = 0.)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : clip_grad
    data_type : x

- backward_op : clip_grad
  forward : clip (Tensor x, Scalar min, Scalar max) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, Scalar min = 0., Scalar max = 0.)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : clip_grad
  backward : clip_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : complex_grad
  forward : complex (Tensor real, Tensor imag) -> Tensor(out)
  args : (Tensor real, Tensor imag, Tensor out_grad)
  output : Tensor(real_grad), Tensor(imag_grad)
  infer_meta :
    func : ComplexGradInferMeta
  kernel :
    func : complex_grad
    data_type : real

- backward_op : conj_grad
  forward : conj (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  invoke : conj(out_grad)

- backward_op : cos_double_grad
  forward : cos_grad (Tensor x, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, x]
  kernel :
    func : cos_double_grad
  optional: grad_out
  backward : cos_triple_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : cos_grad
  forward : cos (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : cos_grad
  backward : cos_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : cos_triple_grad
  forward : cos_double_grad (Tensor x, Tensor grad_out_forward, Tensor grad_x_grad_forward) -> Tensor(grad_x), Tensor(grad_out_grad)
  args : (Tensor x, Tensor grad_out_forward, Tensor grad_x_grad_forward, Tensor grad_x_grad, Tensor grad_out_grad_grad)
  output : Tensor(x_grad), Tensor(grad_out_forward_grad), Tensor(grad_x_grad_forward_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, x, grad_x_grad_forward]
  kernel :
    func : cos_triple_grad
  optional: grad_out_forward, grad_x_grad_forward, grad_out_grad_grad
  inplace : (grad_x_grad_forward -> grad_out_forward_grad)

- backward_op : cosh_grad
  forward : cosh (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : cosh_grad
  inplace : (out_grad -> x_grad)

- backward_op : crop_grad
  forward : crop (Tensor x, IntArray shape, IntArray offsets) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray offsets)
  output : Tensor(x_grad)
  infer_meta :
    func : CropGradInferMeta
  kernel :
    func : crop_grad
    data_type : x

- backward_op : cross_grad
  forward : cross (Tensor x, Tensor y, int axis = 9) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad, int axis)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : cross_grad
    data_type : out_grad

- backward_op : det_grad
  forward : det (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : determinant_grad
    data_type : out_grad

- backward_op : diag_grad
  forward : diag (Tensor x, int offset, float padding_value) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int offset)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : diag_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : diagonal_grad
  forward : diagonal (Tensor x, int offset, int axis1, int axis2) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int offset = 0, int axis1 = 0, int axis2 = 1)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : diagonal_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : digamma_grad
  forward : digamma (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : digamma_grad

- backward_op : dist_grad
  forward : dist (Tensor x, Tensor y, float p) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out, Tensor out_grad, float p)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : dist_grad

- backward_op : dot_grad
  forward : dot (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : dot_grad
    data_type : out_grad

- backward_op : eig_grad
  forward : eig (Tensor x) -> Tensor(out_w), Tensor(out_v)
  args : (Tensor out_w, Tensor out_v, Tensor out_w_grad, Tensor out_v_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : EigGradInferMeta
  kernel :
    func : eig_grad
    data_type : out_v

- backward_op : eigh_grad
  forward : eigh (Tensor x, str UPLO) -> Tensor(out_w), Tensor(out_v)
  args : (Tensor out_w, Tensor out_v, Tensor out_w_grad, Tensor out_v_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_v]
  kernel :
    func : eigh_grad
    data_type : out_v

- backward_op : elu_double_grad
  forward : elu_grad (Tensor x, Tensor out, Tensor grad_out, float alpha)-> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad, float alpha)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, x]
  kernel :
    func : elu_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : elu_grad
  forward : elu (Tensor x, float alpha) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, float alpha)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : elu_grad
  backward : elu_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : erf_grad
  forward : erf (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : erf_grad
    data_type : out_grad

- backward_op : erfinv_grad
  forward : erfinv (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : erfinv_grad

- backward_op : exp_grad
  forward : exp (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : exp_grad
  inplace : (out_grad -> x_grad)
  composite : exp_grad(out, out_grad, x_grad)

- backward_op : expm1_grad
  forward : expm1 (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : expm1_grad
  inplace : (out_grad -> x_grad)

- backward_op : fft_c2c_grad
  forward: fft_c2c(Tensor x, int64_t[] axes, str normalization, bool forward) -> Tensor(out)
  args : (Tensor out_grad, int64_t[] axes, str normalization, bool forward)
  output: Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : fft_c2c_grad

- backward_op : fft_c2r_grad
  forward: fft_c2r(Tensor x, int64_t[] axes, str normalization, bool forward, int64_t last_dim_size) -> Tensor(out)
  args : (Tensor out_grad, int64_t[] axes, str normalization, bool forward, int64_t last_dim_size)
  output: Tensor(x_grad)
  infer_meta :
    func : FFTC2RGradInferMeta
  kernel :
    func : fft_c2r_grad
    data_type: out_grad

- backward_op : fft_r2c_grad
  forward: fft_r2c(Tensor x, int64_t[] axes, str normalization, bool forward, bool onesided) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int64_t[] axes, str normalization, bool forward, bool onesided)
  output: Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : fft_r2c_grad
    data_type: out_grad
  no_need_buffer: x

- backward_op : fill_diagonal_grad
  forward : fill_diagonal (Tensor x, float value=0, int offset=0, bool wrap=false) -> Tensor(out)
  args : (Tensor out_grad, float value, int offset, bool wrap)
  output : Tensor(x_grad)
  infer_meta :
    func : FillDiagonalGradInferMeta
  kernel :
    func : fill_diagonal_grad

- backward_op : fill_diagonal_tensor_grad
  forward : fill_diagonal_tensor (Tensor x, Tensor y, int64_t offset, int dim1, int dim2) -> Tensor(out)
  args : (Tensor out_grad, int64_t offset, int dim1, int dim2)
  output : Tensor(x_grad)
  infer_meta :
    func : FillDiagonalTensorGradInferMeta
  kernel :
    func : fill_diagonal_tensor_grad
  inplace : (out_grad -> x_grad)

- backward_op : flip_grad
  forward : flip (Tensor x, int[] axis) -> Tensor(out)
  args : (Tensor out_grad, int[] axis)
  output : Tensor(x_grad)
  invoke : flip(out_grad, axis)

- backward_op : floor_grad
  forward : floor(Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [out_grad]
  kernel :
    func : floor_grad
  inplace : (out_grad -> x_grad)

- backward_op : fold_grad
  forward: fold (Tensor x, int[] output_sizes, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations) -> Tensor(out)
  args: (Tensor x, Tensor out_grad, int[] output_sizes, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations)
  output: Tensor(x_grad)
  infer_meta:
    func: UnchangedInferMeta
    param : [x]
  kernel:
    func: fold_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : frame_grad
  forward : frame(Tensor x, int frame_length, int hop_length, int axis=-1) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int frame_length, int hop_length, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : frame_grad

- backward_op : gather_nd_grad
  forward : gather_nd (Tensor x, Tensor index) -> Tensor(out)
  args : (Tensor x, Tensor index, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : GatherNdGradInferMeta
  kernel :
    func : gather_nd_grad
  no_need_buffer : x

- backward_op : gelu_grad
  forward : gelu(Tensor x,  bool approximate) -> Tensor(out)
  args : (Tensor x, Tensor out_grad,  bool approximate)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : gelu_grad

- backward_op : grid_sample_grad
  forward : grid_sample (Tensor x, Tensor grid, str mode, str padding_mode, bool align_corners) -> Tensor(out)
  args : (Tensor x, Tensor grid, Tensor out_grad, str mode, str padding_mode, bool align_corners)
  output : Tensor(x_grad), Tensor(grid_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, grid]
  kernel :
    func : grid_sample_grad
    data_type : x

- backward_op : gumbel_softmax_grad
  forward : gumbel_softmax (Tensor x, float temperature, bool hard, int axis) -> Tensor(out)
  args : (Tensor out, Tensor out_grad, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : GumbelSoftmaxGradInferMeta
  kernel :
    func : gumbel_softmax_grad

- backward_op : hardshrink_grad
  forward : hardshrink (Tensor x, float threshold) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float threshold)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hard_shrink_grad
  inplace : (out_grad -> x_grad)

- backward_op : hardsigmoid_grad
  forward : hardsigmoid (Tensor x, float slope, float offset) -> Tensor(out)
  args : (Tensor out, Tensor out_grad, float slope, float offset)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : hard_sigmoid_grad
  inplace : (out_grad -> x_grad)

- backward_op : hardtanh_grad
  forward : hardtanh (Tensor x, float t_min=0, float t_max=24) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float t_min, float t_max)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : hardtanh_grad
  inplace : (out_grad -> x_grad)

- backward_op : imag_grad
  forward : imag (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : RealAndImagGradInferMeta
  kernel :
    func : imag_grad
    data_type : complex(out_grad)

- backward_op : index_sample_grad
  forward : index_sample (Tensor x, Tensor index) -> Tensor(out)
  args : (Tensor x, Tensor index, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : index_sample_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : index_select_grad
  forward : index_select(Tensor x, Tensor index, int axis) -> Tensor(out)
  args : (Tensor x, Tensor index, Tensor out_grad, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : index_select_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : inverse_grad
  forward : inverse(Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta:
    func : InverseGradInferMeta
  kernel :
    func : inverse_grad

- backward_op : kron_grad
  forward : kron (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : kron_grad
    data_type : out_grad

- backward_op : kthvalue_grad
  forward : kthvalue(Tensor x, int k, int axis, bool keepdim) -> Tensor(out), Tensor(indices)
  args : (Tensor x, Tensor indices, Tensor out_grad, int k, int axis, bool keepdim)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : kthvalue_grad
    data_type : out_grad

- backward_op : label_smooth_grad
  forward : label_smooth (Tensor label, Tensor prior_dist, float epsilon) -> Tensor(out)
  args : (Tensor out_grad, float epsilon)
  output : Tensor(label_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : label_smooth_grad

- backward_op : leaky_relu_double_grad
  forward : leaky_relu_grad (Tensor x, Tensor grad_out, float negative_slope) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_x_grad, float negative_slope)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [grad_x_grad]
  kernel :
    func : leaky_relu_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : leaky_relu_grad
  forward : leaky_relu (Tensor x, float negative_slope) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float negative_slope)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : leaky_relu_grad
  backward : leaky_relu_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : lerp_grad
  forward : lerp (Tensor x, Tensor y, Tensor weight) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor weight, Tensor out, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : lerp_grad

- backward_op : lgamma_grad
  forward : lgamma(Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : lgamma_grad

- backward_op : log10_grad
  forward : log10 (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : log10_grad
  inplace : (out_grad -> x_grad)

- backward_op : log1p_grad
  forward : log1p (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : log1p_grad
  inplace : (out_grad -> x_grad)

- backward_op : log2_grad
  forward : log2 (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : log2_grad
  inplace : (out_grad -> x_grad)

- backward_op : log_double_grad
  forward : log_grad (Tensor x, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, x]
  kernel :
    func : log_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : log_grad
  forward : log (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : log_grad
  backward : log_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : log_loss_grad
  forward : log_loss (Tensor input, Tensor label, float epsilon) -> Tensor(out)
  args : (Tensor input, Tensor label, Tensor out_grad, float epsilon)
  output : Tensor(input_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [input]
  kernel :
    func : log_loss_grad

- backward_op : logit_grad
  forward : logit (Tensor x, float eps = 1e-6f) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float eps)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : logit_grad

- backward_op : logsigmoid_grad
  forward : logsigmoid (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : logsigmoid_grad
  inplace : (out_grad -> x_grad)

- backward_op : lu_unpack_grad
  forward : lu_unpack (Tensor x, Tensor y, bool unpack_ludata = true, bool unpack_pivots = true) -> Tensor(pmat), Tensor(l), Tensor(u)
  args : (Tensor x, Tensor y, Tensor l, Tensor u, Tensor pmat, Tensor l_grad, Tensor u_grad, bool unpack_ludata, bool unpack_pivots)
  output : Tensor(x_grad)
  infer_meta :
    func : LUUnpackGradInferMeta
  kernel :
    func : lu_unpack_grad

- backward_op : masked_select_grad
  forward : masked_select (Tensor x, Tensor mask) -> Tensor(out)
  args : (Tensor x, Tensor mask, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : masked_select_grad
    data_type : x
  no_need_buffer : x

- backward_op : matrix_power_grad
  forward : matrix_power (Tensor x, int n) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int n)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : matrix_power_grad

- backward_op : maxout_grad
  forward : maxout(Tensor x, int groups, int axis) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad, int groups, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : GeneralUnaryGradInferMeta
    param: [x]
  kernel :
    func : maxout_grad

- backward_op : meshgrid_grad
  forward : meshgrid (Tensor[] inputs) -> Tensor[](outputs)
  args : (Tensor[] inputs, Tensor[] outputs_grad)
  output : Tensor[](inputs_grad){inputs.size()}
  infer_meta :
    func : MeshgridGradInferMeta
  kernel :
    func : meshgrid_grad
    data_type : outputs_grad

- backward_op : mode_grad
  forward : mode(Tensor x,  int axis = -1,  bool keepdim = false) -> Tensor(out), Tensor(indices)
  args : (Tensor x, Tensor indices, Tensor out_grad,  int axis,  bool keepdim)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : mode_grad

- backward_op : multi_dot_grad
  forward : multi_dot (Tensor[] x) -> Tensor(out)
  args : (Tensor[] x, Tensor out_grad)
  output : Tensor[](x_grad) {x.size()}
  infer_meta :
    func : MultiDotGradInferMeta
  kernel :
    func : multi_dot_grad

- backward_op : multiplex_grad
  forward : multiplex (Tensor[] inputs, Tensor index) -> Tensor(out)
  args : (Tensor[] inputs, Tensor index, Tensor out_grad)
  output : Tensor[](inputs_grad){inputs.size()}
  infer_meta :
    func : MultiplexGradInferMeta
    param : [index, out_grad]
  kernel :
    func : multiplex_grad
    param : [index, out_grad]
    data_type : out_grad

- backward_op : mv_grad
  forward : mv (Tensor x, Tensor vec) -> Tensor(out)
  args : (Tensor x, Tensor vec, Tensor out_grad)
  output : Tensor(x_grad), Tensor(vec_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, vec]
  kernel :
    func : mv_grad

- backward_op : nll_loss_grad
  forward : nll_loss (Tensor input, Tensor label, Tensor weight, int64_t ignore_index = -100, str reduction = "mean") -> Tensor(out), Tensor(total_weight)
  args : (Tensor input, Tensor label, Tensor weight, Tensor total_weight, Tensor out_grad, int64_t ignore_index, str reduction)
  output : Tensor(input_grad)
  infer_meta :
    func : NllLossGradInferMeta
  kernel :
    func : nll_loss_grad
    data_type : input
  optional : weight

- backward_op : overlap_add_grad
  forward : overlap_add(Tensor x, int hop_length, int axis) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int hop_length, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : OverlapAddGradInferMeta
  kernel :
    func : overlap_add_grad
    data_type : x

- backward_op : pixel_shuffle_grad
  forward : pixel_shuffle (Tensor x, int upscale_factor=1, str data_format="NCHW") -> Tensor(out)
  args : (Tensor out_grad, int upscale_factor, str data_format)
  output : Tensor(x_grad)
  infer_meta :
    func : PixelShuffleGradInferMeta
  kernel :
    func : pixel_shuffle_grad

- backward_op : poisson_grad
  forward : poisson (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : poisson_grad

- backward_op : pow_double_grad
  forward : pow_grad(Tensor x, Tensor grad_out, Scalar y) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad, Scalar y)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param: [x, grad_out]
  kernel :
    func : pow_double_grad
    data_type : x
  backward : pow_triple_grad
  inplace : (grad_x_grad -> x_grad)

- backward_op : pow_grad
  forward : pow(Tensor x, Scalar y=1.0f) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, Scalar y=-1)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [x]
  kernel :
    func : pow_grad
    data_type : out_grad
  backward: pow_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : pow_triple_grad
  forward : pow_double_grad(Tensor x, Tensor grad_out, Tensor grad_grad_x, Scalar y) -> Tensor(grad_x), Tensor(grad_grad_out)
  args : (Tensor x, Tensor grad_out, Tensor grad_grad_x, Tensor grad_x_grad, Tensor grad_grad_out_grad, Scalar y)
  output : Tensor(x_grad), Tensor(grad_out_grad), Tensor(grad_grad_x_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param: [x, grad_out, grad_grad_x]
  kernel :
    func : pow_triple_grad
    data_type : x

- backward_op : put_along_axis_grad
  forward : put_along_axis (Tensor arr, Tensor indices, Tensor value, int axis, str reduce = "assign") -> Tensor(out)
  args : (Tensor arr, Tensor indices, Tensor out_grad, int axis, str reduce)
  output : Tensor(arr_grad), Tensor(value_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [arr, indices]
  kernel :
    func : put_along_axis_grad

- backward_op : qr_grad
  forward : qr (Tensor x, str mode = "reduced") -> Tensor(q), Tensor(r)
  args : (Tensor x, Tensor q, Tensor r, Tensor q_grad, Tensor r_grad, str mode)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : qr_grad

- backward_op : real_grad
  forward : real (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : RealAndImagGradInferMeta
  kernel :
    func : real_grad
    data_type : complex(out_grad)

- backward_op : reciprocal_grad
  forward : reciprocal (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : reciprocal_grad
  inplace : (out_grad -> x_grad)

- backward_op : relu_double_grad
  forward : relu_grad (Tensor out, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor out, Tensor grad_x_grad)
  output : Tensor(grad_out_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : relu_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : relu_grad
  forward : relu (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : relu_grad
  backward: relu_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : renorm_grad
  forward : renorm (Tensor x, float p, int axis, float max_norm) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float p, int axis, float max_norm)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : renorm_grad

- backward_op : roll_grad
  forward : roll(Tensor x, IntArray shifts, int64_t[] axis) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, IntArray shifts, int64_t[] axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : roll_grad
    data_type : x
  no_need_buffer : x

- backward_op : round_grad
  forward : round(Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param: [out_grad]
  kernel :
    func : round_grad
  inplace : (out_grad -> x_grad)

- backward_op : rsqrt_double_grad
  forward : rsqrt_grad (Tensor out, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor out, Tensor grad_x, Tensor grad_x_grad)
  output : Tensor(out_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [out, out]
  kernel :
    func : rsqrt_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : rsqrt_grad
  forward : rsqrt (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : rsqrt_grad
  backward : rsqrt_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : scale_grad
  forward : scale (Tensor x, Scalar scale, float bias, bool bias_after_scale) -> Tensor(out)
  args : (Tensor out_grad, Scalar scale=1.0)
  output : Tensor(x_grad)
  invoke : scale(out_grad, scale, 0.0f, true)

- backward_op : scatter_grad
  forward : scatter (Tensor x, Tensor index, Tensor updates, bool overwrite=true) -> Tensor(out)
  args : (Tensor index, Tensor updates, Tensor out_grad, bool overwrite)
  output : Tensor(x_grad), Tensor(updates_grad)
  infer_meta :
    func : ScatterGradInferMeta
    param : [index, updates, out_grad, overwrite]
  kernel :
    func : scatter_grad
  no_need_buffer : updates

- backward_op : scatter_nd_add_grad
  forward : scatter_nd_add (Tensor x, Tensor index, Tensor updates) -> Tensor(out)
  args : (Tensor index, Tensor updates, Tensor out_grad)
  output : Tensor(x_grad), Tensor(updates_grad)
  infer_meta :
    func : ScatterNdAddGradInferMeta
    param : [index, updates, out_grad]
  kernel :
    func : scatter_nd_add_grad
  no_need_buffer : updates

- backward_op : selu_grad
  forward : selu (Tensor x, float scale=1.0507009873554804934193349852946, float alpha=1.6732632423543772848170429916717) -> Tensor(out)
  args : (Tensor out, Tensor out_grad, float scale, float alpha)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : selu_grad
    data_type : out

- backward_op : send_u_recv_grad
  forward : send_u_recv (Tensor x, Tensor src_index, Tensor dst_index, str reduce_op = "SUM", IntArray out_size = {0}) -> Tensor(out), Tensor(dst_count)
  args : (Tensor x, Tensor src_index, Tensor dst_index, Tensor out, Tensor dst_count, Tensor out_grad, str reduce_op = "SUM")
  output : Tensor(x_grad)
  infer_meta :
    func : GeneralUnaryGradInferMeta
    param : [x]
  kernel :
    func : send_u_recv_grad
    data_type : out_grad
  optional: out, dst_count

- backward_op : send_ue_recv_grad
  forward : send_ue_recv (Tensor x, Tensor y, Tensor src_index, Tensor dst_index, str message_op="ADD", str reduce_op="SUM", IntArray out_size={0}) -> Tensor(out), Tensor(dst_count)
  args : (Tensor x, Tensor y, Tensor src_index, Tensor dst_index, Tensor out, Tensor dst_count, Tensor out_grad, str message_op, str reduce_op)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : send_ue_recv_grad
    data_type : out_grad
  optional: out, dst_count

- backward_op : send_uv_grad
  forward : send_uv (Tensor x, Tensor y, Tensor src_index, Tensor dst_index, str message_op = "ADD") -> Tensor(out)
  args: (Tensor x, Tensor y, Tensor src_index, Tensor dst_index, Tensor out_grad, str message_op = "ADD")
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : send_uv_grad
    data_type : x

- backward_op : sigmoid_double_grad
  forward : sigmoid_grad (Tensor out, Tensor fwd_grad_out) -> Tensor(grad_x)
  args : (Tensor out, Tensor fwd_grad_out, Tensor grad_x_grad)
  output : Tensor(out_grad), Tensor(fwd_grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [out, fwd_grad_out]
  kernel :
    func : sigmoid_double_grad
  backward : sigmoid_triple_grad
  inplace : (grad_x_grad -> fwd_grad_out_grad)

- backward_op : sigmoid_grad
  forward : sigmoid (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : sigmoid_grad
  backward : sigmoid_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : sigmoid_triple_grad
  forward : sigmoid_double_grad (Tensor out, Tensor fwd_grad_out, Tensor grad_grad_x) -> Tensor(grad_out), Tensor(grad_grad_out)
  args : (Tensor out, Tensor fwd_grad_out, Tensor grad_grad_x, Tensor grad_out_grad, Tensor grad_grad_out_grad)
  output : Tensor(out_grad), Tensor(fwd_grad_out_grad), Tensor(grad_grad_x_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [out, fwd_grad_out, grad_grad_x]
  kernel :
    func : sigmoid_triple_grad
  optional : grad_grad_out_grad
  inplace : (grad_grad_x -> fwd_grad_out_grad)

- backward_op : sign_grad
  forward : sign (Tensor x) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(x_grad)
  invoke : scale(out_grad, 0.0f, 0.0f, true)

- backward_op : silu_grad
  forward : silu (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : silu_grad
  inplace : (out_grad -> x_grad)

- backward_op : sin_double_grad
  forward : sin_grad (Tensor x, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, x]
  kernel :
    func : sin_double_grad
  optional: grad_out
  backward : sin_triple_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : sin_grad
  forward : sin (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : sin_grad
  backward : sin_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : sin_triple_grad
  forward : sin_double_grad (Tensor x, Tensor grad_out_forward, Tensor grad_x_grad_forward) -> Tensor(grad_x), Tensor(grad_out_grad)
  args : (Tensor x, Tensor grad_out_forward, Tensor grad_x_grad_forward, Tensor grad_x_grad, Tensor grad_out_grad_grad)
  output : Tensor(x_grad), Tensor(grad_out_forward_grad), Tensor(grad_x_grad_forward_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [x, x, grad_x_grad_forward]
  kernel :
    func : sin_triple_grad
  optional: grad_out_forward, grad_x_grad_forward, grad_out_grad_grad
  inplace : (grad_x_grad_forward -> grad_out_forward_grad)

- backward_op : sinh_grad
  forward : sinh (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : sinh_grad
  inplace : (out_grad -> x_grad)

- backward_op : slogdet_grad
  forward : slogdet (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : GeneralUnaryGradInferMeta
    param : [x]
  kernel :
    func : slogdet_grad
    data_type : out_grad

- backward_op : softplus_grad
  forward : softplus (Tensor x, float beta, float threshold) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float beta, float threshold)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : softplus_grad
  inplace : (out_grad -> x_grad)

- backward_op : softshrink_grad
  forward : softshrink (Tensor x, float threshold) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float threshold)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : softshrink_grad
  inplace : (out_grad -> x_grad)

- backward_op : softsign_grad
  forward : softsign (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : softsign_grad
  inplace : (out_grad -> x_grad)

- backward_op : solve_grad
  forward : solve (Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor x, Tensor y, Tensor out, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : solve_grad

- backward_op : sqrt_double_grad
  forward : sqrt_grad (Tensor out, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor out, Tensor grad_x, Tensor grad_x_grad)
  output : Tensor(out_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [out, out]
  kernel :
    func : sqrt_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : sqrt_grad
  forward : sqrt (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : sqrt_grad
  composite : sqrt_grad(out, out_grad, x_grad)
  backward : sqrt_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : square_double_grad
  forward : square_grad (Tensor x, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor x, Tensor grad_out, Tensor grad_x_grad)
  output : Tensor(x_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, x]
  kernel :
    func : square_double_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : square_grad
  forward : square (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : square_grad
  backward : square_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : squeeze_double_grad
  forward : squeeze_grad(Tensor xshape, Tensor grad_out, IntArray axis) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray axis)
  output : Tensor(grad_out_grad), Tensor(xshape)
  invoke: squeeze(grad_x_grad, axis)
  intermediate : xshape

- backward_op : squeeze_grad
  forward : squeeze(Tensor x, IntArray axis) -> Tensor(out), Tensor(xshape)
  args : (Tensor xshape, Tensor out_grad, IntArray axis)
  output : Tensor(x_grad)
  infer_meta :
    func : KernelWithXShapeInferMeta
    param: [xshape]
  kernel :
    func : squeeze_grad
    data_type : out_grad
  inplace : (out_grad -> x_grad)
  backward: squeeze_double_grad

- backward_op : stack_grad
  forward : stack (Tensor[] x, int axis) -> Tensor(out)
  args : (Tensor[] x, Tensor out_grad, int axis)
  output : Tensor[](x_grad){x.size()}
  infer_meta :
    func : StackGradInferMeta
    param: [out_grad, axis]
  kernel :
    func : stack_grad
    param : [out_grad, axis]
    data_type : out_grad
  no_need_buffer : x

- backward_op : svd_grad
  forward : svd (Tensor x, bool full_matrices = false) -> Tensor(u), Tensor(s), Tensor(vh)
  args : (Tensor x, Tensor u, Tensor vh, Tensor s, Tensor u_grad, Tensor vh_grad, Tensor s_grad, bool full_matrices)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : svd_grad
  optional: u_grad, vh_grad, s_grad

- backward_op : take_along_axis_grad
  forward : take_along_axis (Tensor arr, Tensor indices, int axis) -> Tensor(out)
  args : (Tensor arr, Tensor indices, Tensor out_grad, int axis)
  output : Tensor(arr_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [arr]
  kernel :
    func : take_along_axis_grad

- backward_op : tan_grad
  forward : tan (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : tan_grad
  inplace : (out_grad -> x_grad)

- backward_op : tanh_double_grad
  forward : tanh_grad (Tensor out, Tensor grad_out) -> Tensor(grad_x)
  args : (Tensor out, Tensor grad_out, Tensor grad_x_grad)
  output : Tensor(out_grad), Tensor(grad_out_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [out, out]
  kernel :
    func : tanh_double_grad
  backward : tanh_triple_grad
  inplace : (grad_x_grad -> grad_out_grad)

- backward_op : tanh_grad
  forward : tanh (Tensor x) -> Tensor(out)
  args : (Tensor out, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out]
  kernel :
    func : tanh_grad
  composite : tanh_grad(out, out_grad, x_grad)
  backward : tanh_double_grad
  inplace : (out_grad -> x_grad)

- backward_op : tanh_shrink_grad
  forward : tanh_shrink (Tensor x) -> Tensor(out)
  args : (Tensor x, Tensor out_grad)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : tanh_shrink_grad
  inplace : (out_grad -> x_grad)

- backward_op : tanh_triple_grad
  forward : tanh_double_grad (Tensor out, Tensor grad_out_forward, Tensor grad_x_grad_forward) -> Tensor(grad_out_new), Tensor(grad_out_grad)
  args : (Tensor out, Tensor grad_out_forward, Tensor grad_x_grad_forward, Tensor grad_out_new_grad, Tensor grad_out_grad_grad)
  output : Tensor(out_grad), Tensor(grad_out_forward_grad), Tensor(grad_x_grad_forward_grad)
  infer_meta :
    func : GeneralTernaryGradInferMeta
    param : [out, out, grad_x_grad_forward]
  kernel :
    func : tanh_triple_grad
  inplace : (grad_x_grad_forward -> grad_out_forward_grad)
  optional : grad_out_new_grad, grad_out_grad_grad

- backward_op : thresholded_relu_grad
  forward : thresholded_relu (Tensor x, float threshold) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, float threshold)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : thresholded_relu_grad
  inplace : (out_grad -> x_grad)

- backward_op : topk_grad
  forward : topk (Tensor x, Scalar k, int axis = -1, bool largest = true, bool sorted = true) -> Tensor(out), Tensor(indices)
  args : (Tensor x, Tensor indices, Tensor out_grad, Scalar k, int axis, bool largest, bool sorted)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : topk_grad
    data_type : out_grad

- backward_op : trace_grad
  forward : trace (Tensor x, int offset, int axis1, int axis2) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int offset, int axis1, int axis2)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : trace_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : trunc_grad
  forward : trunc (Tensor input) -> Tensor(out)
  args : (Tensor out_grad)
  output : Tensor(input_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [out_grad]
  kernel :
    func : trunc_grad

- backward_op : unbind_grad
  forward : unbind (Tensor input, int axis) -> Tensor[](out)
  args : (Tensor[] out_grad, int axis)
  output : Tensor(input_grad)
  invoke : stack(out_grad, axis)

- backward_op : unfold_grad
  forward : unfold (Tensor x, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations) -> Tensor(out)
  args : (Tensor x, Tensor out_grad, int[] kernel_sizes, int[] strides, int[] paddings, int[] dilations)
  output : Tensor(x_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [x]
  kernel :
    func : unfold_grad
    data_type : out_grad
  no_need_buffer : x

- backward_op : unsqueeze_double_grad
  forward : unsqueeze_grad(Tensor xshape, Tensor grad_out, IntArray axes) -> Tensor(grad_x)
  args : (Tensor grad_x_grad, IntArray axes)
  output : Tensor(grad_out_grad), Tensor(xshape)
  invoke : unsqueeze(grad_x_grad, axes)
  intermediate : xshape

- backward_op : unsqueeze_grad
  forward : unsqueeze(Tensor x, IntArray axes) -> Tensor(out), Tensor(xshape)
  args : (Tensor xshape, Tensor out_grad, IntArray axes)
  output : Tensor(x_grad)
  infer_meta :
    func : KernelWithXShapeInferMeta
    param: [xshape]
  kernel :
    func : unsqueeze_grad
    param : [xshape, out_grad]
    data_type : out_grad
  inplace : (out_grad -> x_grad)
  backward : unsqueeze_double_grad

- backward_op : unstack_grad
  forward : unstack (Tensor x, int axis=0, int num=0) -> Tensor[](out)
  args : (Tensor[] out_grad, int axis)
  output : Tensor(x_grad)
  infer_meta :
    func : UnStackGradInferMeta
  kernel :
    func : unstack_grad

- backward_op : warprnnt_grad
  forward : warprnnt (Tensor input, Tensor label, Tensor input_lengths, Tensor label_lengths, int blank = 0, float fastemit_lambda = 0.0) -> Tensor(loss), Tensor(warprnntgrad)
  args : (Tensor input, Tensor input_lengths, Tensor warprnntgrad, Tensor loss_grad, int blank = 0, float fastemit_lambda = 0.0)
  output : Tensor(input_grad)
  infer_meta :
    func : UnchangedInferMeta
    param : [input]
  kernel :
    func : warprnnt_grad
  no_need_buffer : input

- backward_op : where_grad
  forward : where (Tensor condition, Tensor x, Tensor y) -> Tensor(out)
  args : (Tensor condition, Tensor x, Tensor y, Tensor out_grad)
  output : Tensor(x_grad), Tensor(y_grad)
  infer_meta :
    func : GeneralBinaryGradInferMeta
    param : [x, y]
  kernel :
    func : where_grad
  no_need_buffer : x, y

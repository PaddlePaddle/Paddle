// Generated by paddle/phi/api/yaml/generator/tensor_operants_gen.py

#include "paddle/phi/api/include/tensor_operants.h"

#include "paddle/phi/api/include/api.h"


namespace paddle {

namespace operants {

Tensor PhiTensorOperants::exp(const Tensor& x) {
  return paddle::experimental::exp(x);
}

Tensor PhiTensorOperants::floor(const Tensor& x) {
  return paddle::experimental::floor(x);
}

Tensor PhiTensorOperants::gather_nd(const Tensor& x, const Tensor& index) {
  return paddle::experimental::gather_nd(x, index);
}

Tensor PhiTensorOperants::log(const Tensor& x) {
  return paddle::experimental::log(x);
}

Tensor PhiTensorOperants::pow(const Tensor& x, const Scalar& y) {
  return paddle::experimental::pow(x, y);
}

Tensor PhiTensorOperants::roll(const Tensor& x, const IntArray& shifts, const std::vector<int64_t>& axis) {
  return paddle::experimental::roll(x, shifts, axis);
}

Tensor PhiTensorOperants::scale(const Tensor& x, const Scalar& scale, float bias, bool bias_after_scale) {
  return paddle::experimental::scale(x, scale, bias, bias_after_scale);
}

Tensor PhiTensorOperants::scatter(const Tensor& x, const Tensor& index, const Tensor& updates, bool overwrite) {
  return paddle::experimental::scatter(x, index, updates, overwrite);
}

Tensor PhiTensorOperants::scatter_nd_add(const Tensor& x, const Tensor& index, const Tensor& updates) {
  return paddle::experimental::scatter_nd_add(x, index, updates);
}

Tensor PhiTensorOperants::abs(const Tensor& x) {
  return paddle::experimental::abs(x);
}

Tensor PhiTensorOperants::add(const Tensor& x, const Tensor& y) {
  return paddle::experimental::add(x, y);
}

Tensor PhiTensorOperants::assign(const Tensor& x) {
  return paddle::experimental::assign(x);
}

Tensor PhiTensorOperants::divide(const Tensor& x, const Tensor& y) {
  return paddle::experimental::divide(x, y);
}

Tensor PhiTensorOperants::elementwise_pow(const Tensor& x, const Tensor& y) {
  return paddle::experimental::elementwise_pow(x, y);
}

Tensor PhiTensorOperants::expand(const Tensor& x, const IntArray& shape) {
  return paddle::experimental::expand(x, shape);
}

Tensor PhiTensorOperants::matmul(const Tensor& x, const Tensor& y, bool transpose_x, bool transpose_y) {
  return paddle::experimental::matmul(x, y, transpose_x, transpose_y);
}

Tensor PhiTensorOperants::max(const Tensor& x, const IntArray& axis, bool keepdim) {
  return paddle::experimental::max(x, axis, keepdim);
}

Tensor PhiTensorOperants::maximum(const Tensor& x, const Tensor& y) {
  return paddle::experimental::maximum(x, y);
}

Tensor PhiTensorOperants::minimum(const Tensor& x, const Tensor& y) {
  return paddle::experimental::minimum(x, y);
}

Tensor PhiTensorOperants::multiply(const Tensor& x, const Tensor& y) {
  return paddle::experimental::multiply(x, y);
}

Tensor PhiTensorOperants::prod(const Tensor& x, const IntArray& dims, bool keep_dim, bool reduce_all) {
  return paddle::experimental::prod(x, dims, keep_dim, reduce_all);
}

Tensor PhiTensorOperants::subtract(const Tensor& x, const Tensor& y) {
  return paddle::experimental::subtract(x, y);
}

Tensor PhiTensorOperants::sum(const Tensor& x, const IntArray& axis, DataType dtype, bool keepdim) {
  return paddle::experimental::sum(x, axis, dtype, keepdim);
}

Tensor PhiTensorOperants::tile(const Tensor& x, const IntArray& repeat_times) {
  return paddle::experimental::tile(x, repeat_times);
}

}  // namespace operants
}  // namespace paddle


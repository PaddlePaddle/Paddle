// Generated by paddle/phi/api/yaml/generator/tensor_operants_gen.py

#include "paddle/phi/api/include/tensor.h"

#include "paddle/phi/api/include/operants_manager.h"


namespace paddle {

namespace experimental {

Tensor Tensor::operator+(const Tensor &other) const {
  return add(other);
}

Tensor Tensor::operator-(const Tensor &other) const {
  return subtract(other);
}

Tensor Tensor::operator*(const Tensor &other) const {
  return multiply(other);
}

Tensor Tensor::operator/(const Tensor &other) const {
  return divide(other);
}

Tensor Tensor::exp() const {
  return paddle::OperantsManager::Instance().exp(static_cast<const Tensor &>(*this));
}

Tensor Tensor::floor() const {
  return paddle::OperantsManager::Instance().floor(static_cast<const Tensor &>(*this));
}

Tensor Tensor::gather_nd(const Tensor& index) const {
  return paddle::OperantsManager::Instance().gather_nd(static_cast<const Tensor &>(*this), index);
}

Tensor Tensor::log() const {
  return paddle::OperantsManager::Instance().log(static_cast<const Tensor &>(*this));
}

Tensor Tensor::pow(const Scalar& y) const {
  return paddle::OperantsManager::Instance().pow(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::roll(const IntArray& shifts, const std::vector<int64_t>& axis) const {
  return paddle::OperantsManager::Instance().roll(static_cast<const Tensor &>(*this), shifts, axis);
}

Tensor Tensor::scale(const Scalar& scale, float bias, bool bias_after_scale) const {
  return paddle::OperantsManager::Instance().scale(static_cast<const Tensor &>(*this), scale, bias, bias_after_scale);
}

Tensor Tensor::scatter(const Tensor& index, const Tensor& updates, bool overwrite) const {
  return paddle::OperantsManager::Instance().scatter(static_cast<const Tensor &>(*this), index, updates, overwrite);
}

Tensor Tensor::scatter_nd_add(const Tensor& index, const Tensor& updates) const {
  return paddle::OperantsManager::Instance().scatter_nd_add(static_cast<const Tensor &>(*this), index, updates);
}

Tensor Tensor::abs() const {
  return paddle::OperantsManager::Instance().abs(static_cast<const Tensor &>(*this));
}

Tensor Tensor::add(const Tensor& y) const {
  return paddle::OperantsManager::Instance().add(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::assign() const {
  return paddle::OperantsManager::Instance().assign(static_cast<const Tensor &>(*this));
}

Tensor Tensor::divide(const Tensor& y) const {
  return paddle::OperantsManager::Instance().divide(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::elementwise_pow(const Tensor& y) const {
  return paddle::OperantsManager::Instance().elementwise_pow(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::expand(const IntArray& shape) const {
  return paddle::OperantsManager::Instance().expand(static_cast<const Tensor &>(*this), shape);
}

Tensor Tensor::matmul(const Tensor& y, bool transpose_x, bool transpose_y) const {
  return paddle::OperantsManager::Instance().matmul(static_cast<const Tensor &>(*this), y, transpose_x, transpose_y);
}

Tensor Tensor::max(const IntArray& axis, bool keepdim) const {
  return paddle::OperantsManager::Instance().max(static_cast<const Tensor &>(*this), axis, keepdim);
}

Tensor Tensor::maximum(const Tensor& y) const {
  return paddle::OperantsManager::Instance().maximum(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::minimum(const Tensor& y) const {
  return paddle::OperantsManager::Instance().minimum(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::multiply(const Tensor& y) const {
  return paddle::OperantsManager::Instance().multiply(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::prod(const IntArray& dims, bool keep_dim, bool reduce_all) const {
  return paddle::OperantsManager::Instance().prod(static_cast<const Tensor &>(*this), dims, keep_dim, reduce_all);
}

Tensor Tensor::subtract(const Tensor& y) const {
  return paddle::OperantsManager::Instance().subtract(static_cast<const Tensor &>(*this), y);
}

Tensor Tensor::sum(const IntArray& axis, DataType dtype, bool keepdim) const {
  return paddle::OperantsManager::Instance().sum(static_cast<const Tensor &>(*this), axis, dtype, keepdim);
}

Tensor Tensor::tile(const IntArray& repeat_times) const {
  return paddle::OperantsManager::Instance().tile(static_cast<const Tensor &>(*this), repeat_times);
}

}  // namespace experimental
}  // namespace paddle


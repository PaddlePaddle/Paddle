# Copyright (c) 2023 PaddlePaddle Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import shutil

from gather_gemm_scatter_operation import (
    EmitGatherGemmScatterConfigurationLibrary,
)
from library import OperationKind, OperationKindNames, SubstituteTemplate
from manifest import EmitOperationKindLibrary, GeneratorTarget, Manifest


class GatherGemmScatterEmitOperationKindLibrary(EmitOperationKindLibrary):
    def __init__(self, generated_path, kind, args):
        super().__init__(generated_path, kind, args)
        self.emitters = {
            OperationKind.Gemm: EmitGatherGemmScatterConfigurationLibrary
        }
        self.header_template = "#pragma once\n#if defined(PADDLE_WITH_CUTLASS) && SPCONV_WITH_CUTLASS\n#include \"paddle/phi/kernels/sparse/gpu/cutlass_generator/common.h\"\n"
        self.configuration_header_template = """
/*
  Generated by gemm_operation.py - Do not edit.
*/
#pragma once
#if defined(PADDLE_WITH_CUTLASS) && SPCONV_WITH_CUTLASS
"""
        self.entry_template = ""
        self.configuration_prototype_template = ""
        self.configuration_template = ""
        self.namespace_template = """
namespace phi {
namespace sparse {
"""
        self.epilogue_template = """
}  // namespace sparse
}  // namespace phi
#endif
"""
        self.kernels_lists = {
            "hnn75": "static std::vector<gather_hgemm_scatter> sm75_fp16_nn_kernels = {",
            "snn75": "static std::vector<gather_sgemm_f16_scatter> sm75_fp32_nn_kernels = {",
            "hnn80": "static std::vector<gather_hgemm_scatter> sm80_fp16_nn_kernels = {",
            "snn80": "static std::vector<gather_sgemm_scatter> sm80_fp32_nn_kernels = {",
            "snt80": "static std::vector<gather_sgemm_scatter> sm80_fp32_nt_kernels = {",
            "stn80": "static std::vector<gather_sgemm_scatter> sm80_fp32_tn_kernels = {",
        }

    def __enter__(self):
        self.operation_path = os.path.join(
            self.generated_path, OperationKindNames[self.kind]
        )
        os.mkdir(self.operation_path)

        self.top_level_path = os.path.join(
            self.operation_path,
            "all_%s_operations.h.tmp" % OperationKindNames[self.kind],
        )

        self.configuration_path = os.path.join(
            self.operation_path, "configurations.h.tmp"
        ).replace('\\', '/')

        self.top_level_file = open(self.top_level_path, "w")
        self.top_level_file.write(self.header_template)
        self.top_level_file.write(
            '#include "'
            + 'paddle/phi/kernels/sparse/gpu/cutlass_generator/configurations.h"\n'
        )

        self.configuration_file = open(self.configuration_path, "w")
        self.configuration_file.write(self.configuration_header_template)
        self.configuration_file.write(self.namespace_template)
        self.configuration_file.close()

        self.source_files = [
            self.top_level_path,
        ]

        return self

    def emit(self, configuration_name, operations):
        with self.emitters[self.kind](
            self.operation_path, configuration_name
        ) as configuration_emitter:
            for operation in operations:
                configuration_emitter.emit(operation)

            self.source_files.append(configuration_emitter.configuration_path)

        self.configurations.append(configuration_name)

        if operations[0].layout_name() == 'tn':
            self.kernels_lists[
                operations[0].short_math_name()
                + operations[0].layout_name()
                + str(operations[0].arch)
            ] += (
                """
launchKernel<"""
                + configuration_name
                + "<cutlass::gemm::GemmUniversalMode::kGemmSplitKParallel"
                + ">>,"
            )
        else:
            self.kernels_lists[
                operations[0].short_math_name()
                + operations[0].layout_name()
                + str(operations[0].arch)
            ] += (
                """
launchKernel<"""
                + configuration_name
                + "<>>,"
            )

    def __exit__(self, exception_type, exception_value, traceback):
        self.top_level_file.write(
            SubstituteTemplate(
                self.entry_template,
                {'operation_name': OperationKindNames[self.kind]},
            )
        )

        for configuration_name in self.configurations:
            self.top_level_file.write(
                SubstituteTemplate(
                    self.configuration_template,
                    {'configuration_name': configuration_name},
                )
            )

        for k, v in self.kernels_lists.items():
            self.kernels_lists[k] += "\n};\n"
        self.top_level_file.write(self.namespace_template)
        for k, v in self.kernels_lists.items():
            self.top_level_file.write(v)
        self.top_level_file.write(self.epilogue_template)
        self.top_level_file.close()

        self.configuration_file = open(self.configuration_path, "a")
        self.configuration_file.write(self.epilogue_template)
        self.configuration_file.close()


class GatherGemmScatterManifest(Manifest):
    def emit(self, target=GeneratorTarget.Library):
        operation_emitters = {
            GeneratorTarget.Library: GatherGemmScatterEmitOperationKindLibrary
        }

        generated_path = os.path.join(self.curr_build_dir, 'generated')

        # create generated/
        if os.path.exists(generated_path):
            shutil.rmtree(generated_path)

        os.mkdir(generated_path)

        source_files = []

        # for each operation kind, emit initializer for all configurations
        for operation_kind, configurations in self.operations.items():
            with operation_emitters[target](
                generated_path, operation_kind, self.args
            ) as operation_kind_emitter:
                for configuration_name, operations in configurations.items():
                    operation_kind_emitter.emit(configuration_name, operations)

                source_files += operation_kind_emitter.source_files
